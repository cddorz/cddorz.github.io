<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Leetcode复盘 | HLY-Blog</title><meta name="keywords" content="leetcode"><meta name="author" content="HLY"><meta name="copyright" content="HLY"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="1.回文链表题目描述：回文链表：1-&gt;2-&gt;2-&gt;1 true思路： 首先需要记录中间位置，以便翻转，由此想到快慢指针来进行标记 123456789while(fast !&#x3D; null &amp;&amp; fast.next !&#x3D; null)&amp;#123;     fast &#x3D; fast.next.next;     slow &#x3D; slow.next;&amp;#125;&#x2F;&#x2F;遇到的一个小">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode复盘">
<meta property="og:url" content="https://cddorz.github.io/2021/04/22/Leetcode%E5%A4%8D%E7%9B%98/index.html">
<meta property="og:site_name" content="HLY-Blog">
<meta property="og:description" content="1.回文链表题目描述：回文链表：1-&gt;2-&gt;2-&gt;1 true思路： 首先需要记录中间位置，以便翻转，由此想到快慢指针来进行标记 123456789while(fast !&#x3D; null &amp;&amp; fast.next !&#x3D; null)&amp;#123;     fast &#x3D; fast.next.next;     slow &#x3D; slow.next;&amp;#125;&#x2F;&#x2F;遇到的一个小">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-2d53a7b90e55544f9b59dd46768052d1_720w.jpg?source=1940efc">
<meta property="article:published_time" content="2021-04-22T01:58:33.000Z">
<meta property="article:modified_time" content="2021-09-01T12:14:34.638Z">
<meta property="article:author" content="HLY">
<meta property="article:tag" content="leetcode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic4.zhimg.com/80/v2-2d53a7b90e55544f9b59dd46768052d1_720w.jpg?source=1940efc"><link rel="shortcut icon" href="/img/tubiao.jpg"><link rel="canonical" href="https://cddorz.github.io/2021/04/22/Leetcode%E5%A4%8D%E7%9B%98/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: {"text":"I,LOVE,YOU","fontSize":"15px"},
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-09-01 20:14:34'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><link rel="stylesheet" href="/clock/css/clock.css"/><link rel="stylesheet" href="/news/css/news.css"/><link rel="stylesheet" href="/css/1.css"/><link rel="stylesheet" href="/css/flipcountdown.css"><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="HLY-Blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/tubiao.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/-%E9%9F%B3%E4%B9%90"><i class="fa-fw /music/"></i><span> 清单|| fa fa-heartbeat</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://pic4.zhimg.com/80/v2-2d53a7b90e55544f9b59dd46768052d1_720w.jpg?source=1940ef5c)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">HLY-Blog</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/-%E9%9F%B3%E4%B9%90"><i class="fa-fw /music/"></i><span> 清单|| fa fa-heartbeat</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">Leetcode复盘</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-04-22T01:58:33.000Z" title="发表于 2021-04-22 09:58:33">2021-04-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-09-01T12:14:34.638Z" title="更新于 2021-09-01 20:14:34">2021-09-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2021/04/22/Leetcode%E5%A4%8D%E7%9B%98/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2021/04/22/Leetcode%E5%A4%8D%E7%9B%98/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1-回文链表"><a href="#1-回文链表" class="headerlink" title="1.回文链表"></a>1.回文链表</h2><h4 id="题目描述：回文链表：1-gt-2-gt-2-gt-1-true"><a href="#题目描述：回文链表：1-gt-2-gt-2-gt-1-true" class="headerlink" title="题目描述：回文链表：1-&gt;2-&gt;2-&gt;1 true"></a>题目描述：回文链表：1-&gt;2-&gt;2-&gt;1 true</h4><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><ul>
<li><p>首先需要记录中间位置，以便翻转，由此想到快慢指针来进行标记</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">     fast = fast.next.next;</span><br><span class="line">     slow = slow.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遇到的一个小坑！后面解释</span></span><br><span class="line"> <span class="keyword">if</span>(fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">     slow = slow.next;</span><br><span class="line"> &#125;</span><br><span class="line">当fast指针遍历到末尾时，slow指针遍历到中间</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>其次是翻转链表，这里定义pre，prepre指针来直接翻转链表，破坏了链表结构，有坑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ListNode pre&#x3D;head,prepre&#x3D;null;</span><br><span class="line"> while(fast !&#x3D; null &amp;&amp; fast.next !&#x3D; null)&#123;</span><br><span class="line">           pre &#x3D; slow;</span><br><span class="line">           slow &#x3D; slow.next;</span><br><span class="line">           fast &#x3D; fast.next.next;</span><br><span class="line">           pre.next &#x3D; prepre;</span><br><span class="line">           prepre &#x3D; pre;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>最后，比较pre和slow</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while(pre!&#x3D;null&amp;&amp;slow!&#x3D;null)&#123;</span><br><span class="line">            if(slow.val!&#x3D;pre.val)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            pre&#x3D;pre.next;</span><br><span class="line">            slow&#x3D;slow.next;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 回文链表：1-&gt;2-&gt;2-&gt;1 true</span></span><br><span class="line"><span class="comment"> * 通过pre 和 prepre指针来反转链表</span></span><br><span class="line"><span class="comment"> * fast指针走完，slow到一半</span></span><br><span class="line"><span class="comment"> * 只是破坏了链表的结构</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-01 20:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">huiwenlianbiao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结构体链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode() &#123;&#125;</span><br><span class="line">        ListNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">        ListNode(<span class="keyword">int</span> val, ListNode next) &#123; <span class="keyword">this</span>.val = val; <span class="keyword">this</span>.next = next; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>&amp;&amp;head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//prepre pre 用来反转链表</span></span><br><span class="line">        ListNode slow=head,fast=head;</span><br><span class="line">        ListNode pre=head,prepre=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            pre.next = prepre;</span><br><span class="line">            prepre = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pre!=<span class="keyword">null</span>&amp;&amp;slow!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(slow.val!=pre.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre=pre.next;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>==坑！！！！==</p>
<p>一开始不知道为啥会有 if(fast!=null){slow = slow.next;}这一段代码，因为如果是1-&gt;2-&gt;3-&gt;2-&gt;1的回文链表，这样就会让slow只有2-&gt;1，除去了3的比较，一开始我一直以为pre和slow是同步的，这样才能翻转比较，但后来仔细看了看代码，pre其实是比slow晚一步的，因为这种pre的方式是破坏了链表结构，链表的前段部分是翻转了的，所以如果pre和slow是同步的话，3其实有两个next，就会出现错误。</p>
<p>所以如果是奇数链表，那么pre和slow都是从3的前一个，后一个元素开始比较，-如果是偶数链表，当然也不会出现这种情况。</p>
<h2 id="2-括号匹配"><a href="#2-括号匹配" class="headerlink" title="2.括号匹配"></a>2.括号匹配</h2><p>算是一个比较经典的问题了，首先需要了解几个Java的容器，Map、HashMap、Deque（栈）</p>
<h4 id="题目描述：给定一个只包括-39-39-，-39-39-，-39-39-，-39-39-，-39-39-，-39-39-的字符串-s-，判断字符串是否有效。"><a href="#题目描述：给定一个只包括-39-39-，-39-39-，-39-39-，-39-39-，-39-39-，-39-39-的字符串-s-，判断字符串是否有效。" class="headerlink" title="题目描述：给定一个只包括&#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串 s ，判断字符串是否有效。"></a>题目描述：给定一个只包括<code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</h4><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><ul>
<li><p>首先需要思考的是怎么匹配前后括号，因为输入形式是”{[]}”、”()[]{}”这样的，匹配的时候需要，匹配好一对括号就删除，因此想到了栈结构，通过压栈和弹栈来实现</p>
</li>
<li><p>接下来，就考虑如何匹配，想到用HashMap 的k-v键值对来存储括号，因为后括号在前括号之后，所以k存储后括号，v存储前括号，如果遇到前括号，就压栈，如果遇到后括号，看看栈顶和其匹不匹配，匹配就把前括号弹栈。</p>
</li>
<li><p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 括号匹配</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-01 20:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">matching</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="comment">//如果长度是奇数，一定不匹配</span></span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character, Character&gt; pairs = <span class="keyword">new</span> HashMap&lt;Character,Character&gt;() &#123;&#123;</span><br><span class="line">            put(<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            put(<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">            put(<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        Deque&lt;Character&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//遍历s</span></span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (pairs.containsKey(ch)) &#123;</span><br><span class="line">                <span class="comment">//判断括号是否匹配</span></span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty() || !stack.peek().equals(pairs.get(ch))) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="3-x的n次幂-递归-快速幂"><a href="#3-x的n次幂-递归-快速幂" class="headerlink" title="3.x的n次幂(递归+快速幂)"></a>3.x的n次幂(递归+快速幂)</h2><h3 id="题目描述：实现-pow-x-n-，即计算-x-的-n-次幂函数（即，x-n-）"><a href="#题目描述：实现-pow-x-n-，即计算-x-的-n-次幂函数（即，x-n-）" class="headerlink" title="题目描述：实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，x^n^）"></a>题目描述：实现 <a target="_blank" rel="noopener" href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数（即，x^n^）</h3><h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><ul>
<li>首先想到，从左至右<em>x</em>→<em>x</em>^2^→<em>x</em>^4^→<em>x</em>^9^→<em>x</em>^19^→<em>x</em>^38^→<em>x</em>^77^，每次都将上次的结果进行平方，但有些步骤需要多*一个x，这就会比较困难，如何判断到底要不要多×一个x</li>
<li>但如果我们从右往左看，分治的思想就十分明显：<ul>
<li>当我们要计算 x^n^时，可以先递归的算出y = x^[n/2]^,其中[a]表示对a向下取整</li>
<li>根据递归计算的结果，如果n为偶数，那么x^n^ = y*y，如果n为奇数，那么x^n^ = y * y * x</li>
<li>递归的边界为 n = 0，任意数的 0次方均为 1。</li>
<li>由于每次递归都会使得指数减少一半，因此递归的层数为 <em>O</em>(log<em>n</em>)</li>
</ul>
</li>
</ul>
<p>完整代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速幂+递归实现x的n次幂</span></span><br><span class="line"><span class="comment"> * 从右向左分析</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-01 23:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">pow</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> N = n;</span><br><span class="line">            <span class="comment">//若n是负数，则1/</span></span><br><span class="line">            <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> N)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (N == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">double</span> y = quickMul(x, N / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span> ? y * y : y * y * x;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul>
<li>时间复杂度：O(logn)，即为递归的层数。</li>
</ul>
<ul>
<li>空间复杂度：O(logn)，即为递归的层数。这是由于递归的函数调用会使用栈空间。</li>
</ul>
<h2 id="4-牛顿迭代法实现完全平方数的判断"><a href="#4-牛顿迭代法实现完全平方数的判断" class="headerlink" title="4.牛顿迭代法实现完全平方数的判断"></a>4.牛顿迭代法实现完全平方数的判断</h2><p>![G_YXC__JI@5_P_L~22`G5_0.png](<a target="_blank" rel="noopener" href="https://i.loli.net/2021/04/22/d9fgKHIMhUOjnpZ.png">https://i.loli.net/2021/04/22/d9fgKHIMhUOjnpZ.png</a>)</p>
<p>由于这种解法太过神仙，就不多解释了，看图就好，这只是一种无限接近的解法，会有误差，但误差在允许的范围之内。</p>
<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> x = num / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (x * x &gt; num) &#123;</span><br><span class="line">      x = (x + num / x) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (x * x == num);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二分法："><a href="#二分法：" class="headerlink" title="二分法："></a>二分法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> left = <span class="number">2</span>, right = num / <span class="number">2</span>, x, guessSquared;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">      x = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">      guessSquared = x * x;</span><br><span class="line">      <span class="keyword">if</span> (guessSquared == num) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (guessSquared &gt; num) &#123;</span><br><span class="line">        right = x - <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left = x + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-判断是否是对称二叉树"><a href="#5-判断是否是对称二叉树" class="headerlink" title="5.判断是否是对称二叉树"></a>5.判断是否是对称二叉树</h2><h4 id="思路：比较左孩子的与右孩子值是否相等，由此想到递归实现，比较容易理解，就不加赘述了。"><a href="#思路：比较左孩子的与右孩子值是否相等，由此想到递归实现，比较容易理解，就不加赘述了。" class="headerlink" title="思路：比较左孩子的与右孩子值是否相等，由此想到递归实现，比较容易理解，就不加赘述了。"></a>思路：比较左孩子的与右孩子值是否相等，由此想到递归实现，比较容易理解，就不加赘述了。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过递归实现判断是否是对称二叉树</span></span><br><span class="line"><span class="comment"> * 递归终止条件：两个节点都为空；其中一个节点为空；两个节点值不相等</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-02 10:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">isSymmetric</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用递归函数，比较左节点，右节点</span></span><br><span class="line">        <span class="keyword">return</span> dfs(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(TreeNode left, TreeNode right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归的终止条件是两个节点都为空</span></span><br><span class="line">        <span class="comment">//或者两个节点中有一个为空</span></span><br><span class="line">        <span class="comment">//或者两个节点的值不相等</span></span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span> &amp;&amp; right==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span> || right==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left.val!=right.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再递归的比较 左节点的左孩子 和 右节点的右孩子</span></span><br><span class="line">        <span class="comment">//以及比较  左节点的右孩子 和 右节点的左孩子</span></span><br><span class="line">        <span class="keyword">return</span> dfs(left.left,right.right) &amp;&amp; dfs(left.right,right.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode() &#123;&#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="6-617-合并二叉树"><a href="#6-617-合并二叉树" class="headerlink" title="6. 617 合并二叉树"></a>6. 617 合并二叉树</h2><h4 id="思路：前序递归遍历二叉树，并将值相加"><a href="#思路：前序递归遍历二叉树，并将值相加" class="headerlink" title="思路：前序递归遍历二叉树，并将值相加"></a>思路：前序递归遍历二叉树，并将值相加</h4><ul>
<li><p>递归终止条件,两节点有一个或两个节点为null就返回</p>
</li>
<li><p>递归函数内,将两个树的节点相加后,再递归执行两节点的左节点和右节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">dfs</span><span class="params">(TreeNode r1, TreeNode r2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (r1 == <span class="keyword">null</span> || r2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> r1 == <span class="keyword">null</span> ? r2 : r1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//树2合并到树1上</span></span><br><span class="line">        <span class="comment">//前序遍历二叉树</span></span><br><span class="line">        r1.val += r2.val;</span><br><span class="line">        r1.left = dfs(r1.left, r2.left);</span><br><span class="line">        r1.right = dfs(r1.right, r2.right);</span><br><span class="line">        <span class="keyword">return</span> r1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>完整代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归法合并二叉树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-02 15:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">merge</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="keyword">null</span> || root2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root1 == <span class="keyword">null</span> ? root2 : root1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(root1, root2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">dfs</span><span class="params">(TreeNode r1, TreeNode r2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (r1 == <span class="keyword">null</span> || r2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> r1 == <span class="keyword">null</span> ? r2 : r1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//树2合并到树1上</span></span><br><span class="line">        <span class="comment">//前序遍历二叉树</span></span><br><span class="line">        r1.val += r2.val;</span><br><span class="line">        r1.left = dfs(r1.left, r2.left);</span><br><span class="line">        r1.right = dfs(r1.right, r2.right);</span><br><span class="line">        <span class="keyword">return</span> r1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="7-反转链表"><a href="#7-反转链表" class="headerlink" title="7.反转链表"></a>7.反转链表</h2><h3 id="思路-递归遍历到最后一个节点-然后反转"><a href="#思路-递归遍历到最后一个节点-然后反转" class="headerlink" title="思路:递归遍历到最后一个节点,然后反转"></a>思路:递归遍历到最后一个节点,然后反转</h3><ul>
<li><p>递归终止条件: head == null  or  head.next == null</p>
</li>
<li><p>递归函数内容:将指针反转,注意节点下一位必须指向null,否则不算成功</p>
</li>
<li><p>时间复杂度:O(n),n为节点个数们,需要遍历n个节点进行反转</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归实现反转链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-02 23:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">reverseList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode newhead = reverseList(head.next);</span><br><span class="line">        <span class="comment">//反转指针</span></span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="8-移动零-leectcode-283"><a href="#8-移动零-leectcode-283" class="headerlink" title="8.移动零 leectcode 283"></a>8.移动零 leectcode 283</h2><h3 id="描述：给定一个数组-nums，编写一个函数将所有-0-移动到数组的末尾，同时保持非零元素的相对顺序。"><a href="#描述：给定一个数组-nums，编写一个函数将所有-0-移动到数组的末尾，同时保持非零元素的相对顺序。" class="headerlink" title="描述：给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。"></a>描述：给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</h3><h3 id="思路：快排实现移动0，因为除了特殊情况外，快排是所有排序中性能最好的算法。将第一个元素作为基准值，从左至右遍历，如果不为0，则交换，使得所有不为0的元素在数组左侧（数组分治思想"><a href="#思路：快排实现移动0，因为除了特殊情况外，快排是所有排序中性能最好的算法。将第一个元素作为基准值，从左至右遍历，如果不为0，则交换，使得所有不为0的元素在数组左侧（数组分治思想" class="headerlink" title="思路：快排实现移动0，因为除了特殊情况外，快排是所有排序中性能最好的算法。将第一个元素作为基准值，从左至右遍历，如果不为0，则交换，使得所有不为0的元素在数组左侧（数组分治思想"></a>思路：快排实现移动0，因为除了特殊情况外，快排是所有排序中性能最好的算法。将第一个元素作为基准值，从左至右遍历，如果不为0，则交换，使得所有不为0的元素在数组左侧（数组分治思想</h3><p>快排：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day3;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快排实现数组中0都在数组的末尾</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-03 22:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">moveZero</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">                temp = nums[i];</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j] = temp;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="9-给定一个整数数组-nums-，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。"><a href="#9-给定一个整数数组-nums-，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。" class="headerlink" title="9.给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。"></a>9.给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</h2><h3 id="要点："><a href="#要点：" class="headerlink" title="要点："></a>要点：</h3><ul>
<li>连续子数组</li>
<li>最大和</li>
</ul>
<h3 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h3><ul>
<li><p>整数数组有正有负</p>
</li>
<li><p>sum 保存动态最大和，又可能出现负数情况</p>
</li>
<li><p>动态规划，ans 保存最后结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day4;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-04 10:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">max</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 保存结果</span></span><br><span class="line">        <span class="keyword">int</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="comment">// 如果sum为负数，直接赋值num</span></span><br><span class="line">            <span class="keyword">if</span>(sum &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                sum = num;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sum += num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 动态规划</span></span><br><span class="line">            ans = Math.max(sum,ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="10、二叉树最大深度"><a href="#10、二叉树最大深度" class="headerlink" title="10、二叉树最大深度"></a>10、二叉树最大深度</h2><h3 id="思路：简单动态规划实现"><a href="#思路：简单动态规划实现" class="headerlink" title="思路：简单动态规划实现"></a>思路：简单动态规划实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day4;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个二叉树，找出其最大深度。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-04 21:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">maxDepth</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        <span class="keyword">int</span> left = maxDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = maxDepth(root.right);</span><br><span class="line">        <span class="comment">// 动态规划</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="11、给定一个大小为-n-的数组，找到其中的多数元素。多数元素是指在数组中出现次数-大于-⌊-n-2-⌋-的元素。"><a href="#11、给定一个大小为-n-的数组，找到其中的多数元素。多数元素是指在数组中出现次数-大于-⌊-n-2-⌋-的元素。" class="headerlink" title="11、给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。"></a>11、给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。</h2><h3 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h3><ul>
<li>找众数，首先想到用额外的空间map来存放key–遍历的数，value–出现的次数</li>
<li>但空间复杂度比较高，由此想到用一个变量来存放众数出现的次数</li>
<li>若不是<strong>candidata</strong> 则 -1，若是则 +1</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day4;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目：给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。</span></span><br><span class="line"><span class="comment"> * 摩尔投票法：</span></span><br><span class="line"><span class="comment"> * 我们遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0</span></span><br><span class="line"><span class="comment"> * 我们先将 x 的值赋予 candidate，随后我们判断 x：</span></span><br><span class="line"><span class="comment"> * 如果 x 与 candidate 相等，那么计数器 count 的值增加 1；</span></span><br><span class="line"><span class="comment"> * 如果 x 与 candidate 不等，那么计数器 count 的值减少 1。</span></span><br><span class="line"><span class="comment"> * 在遍历完成后，candidate 即为整个数组的众数。</span></span><br><span class="line"><span class="comment"> * nums:      [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]</span></span><br><span class="line"><span class="comment"> * candidate:  7  7  7  7  7  7   5  5   5  5  5  5   7  7  7  7</span></span><br><span class="line"><span class="comment"> * count:      1  2  1  2  1  0   1  0   1  2  1  0   1  2  3  4</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-04 23:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">most</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> candidate = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                candidate = num;</span><br><span class="line">            &#125;</span><br><span class="line">            count += (num == candidate) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="12、给定一个链表，判断链表中是否有环。"><a href="#12、给定一个链表，判断链表中是否有环。" class="headerlink" title="12、给定一个链表，判断链表中是否有环。"></a>12、给定一个链表，判断链表中是否有环。</h2><h3 id="思路：快慢指针，若链表有环，则快指针一定追上慢指针，且快指针只能比慢指针快偶数倍，如果是奇数倍，若环内元素为偶数，则永远不会相遇（画图可解"><a href="#思路：快慢指针，若链表有环，则快指针一定追上慢指针，且快指针只能比慢指针快偶数倍，如果是奇数倍，若环内元素为偶数，则永远不会相遇（画图可解" class="headerlink" title="思路：快慢指针，若链表有环，则快指针一定追上慢指针，且快指针只能比慢指针快偶数倍，如果是奇数倍，若环内元素为偶数，则永远不会相遇（画图可解"></a>思路：快慢指针，若链表有环，则快指针一定追上慢指针，且快指针只能比慢指针快偶数倍，如果是奇数倍，若环内元素为偶数，则永远不会相遇（画图可解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day5;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个链表，判断链表中是否有环。</span></span><br><span class="line"><span class="comment"> * 解法：快慢指针，快指针先进入环，如果快指针追上慢指针，证明有环</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-05 14:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">cycle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head.next;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-翻转二叉树"><a href="#13-翻转二叉树" class="headerlink" title="13.翻转二叉树"></a>13.翻转二叉树</h2><h3 id="思路：递归实现"><a href="#思路：递归实现" class="headerlink" title="思路：递归实现"></a>思路：递归实现</h3><ul>
<li>递归终止条件：root 为 null，则返回root</li>
<li>递归函数内交换当前节点左右子树，在递归交换子树的左右子树</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day5;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 翻转一棵二叉树。</span></span><br><span class="line"><span class="comment"> * 递归实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-05 17:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">invert</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归函数的终止条件，节点为空时返回</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//下面三句是将当前节点的左右子树交换</span></span><br><span class="line">        TreeNode tmp = root.right;</span><br><span class="line">        root.right = root.left;</span><br><span class="line">        root.left = tmp;</span><br><span class="line">        <span class="comment">//递归交换当前节点的 左子树</span></span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        <span class="comment">//递归交换当前节点的 右子树</span></span><br><span class="line">        invertTree(root.right);</span><br><span class="line">        <span class="comment">//函数返回时就表示当前这个节点，以及它的左右子树</span></span><br><span class="line">        <span class="comment">//都已经交换完了</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14、相交链表"><a href="#14、相交链表" class="headerlink" title="14、相交链表"></a>14、相交链表</h2><h3 id="思路：因为两链表相交，所以两链表有一部分重合，一部分不同，若让两指针分别走A-B，B-A的路程，则两指针，一定会在相交的起始节点相遇"><a href="#思路：因为两链表相交，所以两链表有一部分重合，一部分不同，若让两指针分别走A-B，B-A的路程，则两指针，一定会在相交的起始节点相遇" class="headerlink" title="思路：因为两链表相交，所以两链表有一部分重合，一部分不同，若让两指针分别走A+B，B+A的路程，则两指针，一定会在相交的起始节点相遇"></a>思路：因为两链表相交，所以两链表有一部分重合，一部分不同，若让两指针分别走A+B，B+A的路程，则两指针，一定会在相交的起始节点相遇</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day5;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 编写一个程序，找到两个单链表相交的起始节点。</span></span><br><span class="line"><span class="comment"> * A+B = B+A 因为相交，所以最后一段相同，所以a，b指针分别走A+B以及B+A，则一定a会=b</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-05 23:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xiangjiao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode a = headA;</span><br><span class="line">        ListNode b = headB;</span><br><span class="line">        <span class="keyword">while</span>(a != b)&#123;</span><br><span class="line">            a = (a==<span class="keyword">null</span>) ? headB : a.next;</span><br><span class="line">            b = (b==<span class="keyword">null</span>) ? headA : b.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15、（448）给你一个含-n-个整数的数组-nums-，其中-nums-i-在区间-1-n-内。请你找出所有在-1-n-范围内但没有出现在-nums-中的数字，并以数组的形式返回结果。"><a href="#15、（448）给你一个含-n-个整数的数组-nums-，其中-nums-i-在区间-1-n-内。请你找出所有在-1-n-范围内但没有出现在-nums-中的数字，并以数组的形式返回结果。" class="headerlink" title="15、（448）给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。"></a>15、（448）给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。</h2><h3 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h3><ul>
<li>首先，可以考虑用哈希表记录，但空间复杂度较高</li>
<li>用nums本身来记录，就是每遍历一个 x 就让 nums[x-1] 增加n，这样 x 对应下标的数一定 &gt; n，最后再遍历，，判断小于 n 的数的下标加入数组即可</li>
<li>注意，有可能 num 已经加过 n 了，所以要对 num 取余</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day6;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</span></span><br><span class="line"><span class="comment"> * 找到所有在 [1, n] 范围之间没有出现在数组中的数字。</span></span><br><span class="line"><span class="comment"> * 解法：遍历数组，遍历一次x就使nums[x-1] + n，这样如果数组中没有的数字，那么他们-1对应的下标的数应该&lt;=n</span></span><br><span class="line"><span class="comment"> * 由此筛选出不是数组中的数字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-06 15:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">findDisappear</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="comment">//有可能这个x已经加过n了，除于还原原来的数字</span></span><br><span class="line">            <span class="keyword">int</span> x = (num - <span class="number">1</span>) % n;</span><br><span class="line">            nums[x]+=n;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt;= n)&#123;</span><br><span class="line">                list.add(i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="16、汉明距离"><a href="#16、汉明距离" class="headerlink" title="16、汉明距离"></a>16、汉明距离</h2><h3 id="思路：简单的位运算"><a href="#思路：简单的位运算" class="headerlink" title="思路：简单的位运算"></a>思路：简单的位运算</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day6;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。</span></span><br><span class="line"><span class="comment"> * 给出两个整数 x 和 y，计算它们之间的汉明距离。</span></span><br><span class="line"><span class="comment"> * x  y 异或不同位为1，统计异或结果1的数目即为答案</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-06 9:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hamming</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//异或。统计xor为1的个数即可</span></span><br><span class="line">        <span class="keyword">int</span> xor = x ^ y;</span><br><span class="line">        <span class="keyword">int</span> distance = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//右移位统计xor的1</span></span><br><span class="line">        <span class="keyword">while</span> (xor != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 因为若二进制末位为1，则 % 2 一定为1</span></span><br><span class="line">            <span class="keyword">if</span> (xor % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                distance += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 右移，判断下一位</span></span><br><span class="line">            xor = xor &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> distance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="17-最大路径"><a href="#17-最大路径" class="headerlink" title="17.最大路径"></a>17.最大路径</h2><h3 id="描述：-给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。"><a href="#描述：-给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。" class="headerlink" title="描述： 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。"></a>描述： 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</h3><h3 id="思路：动态规划算法"><a href="#思路：动态规划算法" class="headerlink" title="思路：动态规划算法"></a>思路：动态规划算法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day6;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-06 23:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">zuidaluj</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        depth(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 访问到空节点了，返回0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左儿子为根的子树的深度</span></span><br><span class="line">        <span class="keyword">int</span> L = depth(node.left);</span><br><span class="line">        <span class="comment">// 右儿子为根的子树的深度</span></span><br><span class="line">        <span class="keyword">int</span> R = depth(node.right);</span><br><span class="line">        <span class="comment">// 计算d_node即L+R+1 并更新ans</span></span><br><span class="line">        ans = Math.max(ans, L+R);</span><br><span class="line">        <span class="comment">// 返回该节点为根的子树的深度</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(L, R)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="18-爬楼梯"><a href="#18-爬楼梯" class="headerlink" title="18.爬楼梯"></a>18.爬楼梯</h2><h3 id="思路：动态规划"><a href="#思路：动态规划" class="headerlink" title="思路：动态规划"></a>思路：动态规划</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day7;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</span></span><br><span class="line"><span class="comment"> * 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</span></span><br><span class="line"><span class="comment"> * 递归实现会超时，why？递归实现时间复杂度为2^n</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-07 10:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">climb</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="19-（121）股票的最大利润"><a href="#19-（121）股票的最大利润" class="headerlink" title="19.（121）股票的最大利润"></a>19.（121）股票的最大利润</h2><h3 id="思路：动态规划，更新最小值，动态规划利润"><a href="#思路：动态规划，更新最小值，动态规划利润" class="headerlink" title="思路：动态规划，更新最小值，动态规划利润"></a>思路：动态规划，更新最小值，动态规划利润</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day7;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 股票问题（动态规划）比较简单</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-07 20:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">max</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min=prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : prices)&#123;</span><br><span class="line">            <span class="keyword">if</span>(min&gt;=i)&#123;</span><br><span class="line">                min = i;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res,i-min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="20-139-单词拆分"><a href="#20-139-单词拆分" class="headerlink" title="20.(139) 单词拆分"></a>20.(139) 单词拆分</h2><h3 id="描述：给定一个非空字符串-s-和一个包含非空单词的列表-wordDict，判定-s-是否可以被空格拆分为一个或多个在字典中出现的单词。"><a href="#描述：给定一个非空字符串-s-和一个包含非空单词的列表-wordDict，判定-s-是否可以被空格拆分为一个或多个在字典中出现的单词。" class="headerlink" title="描述：给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。"></a>描述：给定一个<strong>非空</strong>字符串 <em>s</em> 和一个包含<strong>非空</strong>单词的列表 <em>wordDict</em>，判定 <em>s</em> 是否可以被空格拆分为一个或多个在字典中出现的单词。</h3><h3 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h3><ul>
<li>动态规划，ｄｐ［ｉ］表示ｓ前ｉ个字符能否拆分</li>
<li>转移方程：dp[j] = dp[i] &amp;&amp; check(s[i+1, j])</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 动态规划算法，dp[i]表示s前i个字符能否拆分</span></span><br><span class="line"><span class="comment"> * 转移方程：dp[j] = dp[i] &amp;&amp; check(s[i+1, j]);</span></span><br><span class="line"><span class="comment"> * check(s[i+1, j])就是判断i+1到j这一段字符是否能够拆分</span></span><br><span class="line"><span class="comment"> * 其实，调整遍历顺序，这等价于s[i+1, j]是否是wordDict中的元素</span></span><br><span class="line"><span class="comment"> * 这个举个例子就很容易理解。</span></span><br><span class="line"><span class="comment"> * 假如wordDict=[&quot;apple&quot;, &quot;pen&quot;, &quot;code&quot;],s = &quot;applepencode&quot;;</span></span><br><span class="line"><span class="comment"> * dp[8] = dp[5] + check(&quot;pen&quot;)</span></span><br><span class="line"><span class="comment"> * 翻译一下：前八位能否拆分取决于前五位能否拆分，加上五到八位是否属于字典</span></span><br><span class="line"><span class="comment"> * (注意：i的顺序是从j-1 -&gt; 0哦~,因为substring（x，y）x--&gt;0开始索引 y---&gt;1开始索引)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-08 20:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">chaifen</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;String,Boolean&gt; map =  <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//检查s是否属于字典</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.getOrDefault(s,<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(String word : wordDict)&#123;</span><br><span class="line">            map.put(word,<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; s.length();j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = j-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">                <span class="comment">// dp[8] = dp[5] + check(&quot;pen&quot;)</span></span><br><span class="line">                dp[j] = dp[i] &amp;&amp; check(s.substring(i,j));</span><br><span class="line">                <span class="keyword">if</span>(dp[j])&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="21（79）单词搜索"><a href="#21（79）单词搜索" class="headerlink" title="21（79）单词搜索"></a>21（79）单词搜索</h2><h3 id="描述：给定一个-m-x-n-二维字符网格-board-和一个字符串单词-word-。如果-word-存在于网格中，返回-true-；否则，返回-false-。"><a href="#描述：给定一个-m-x-n-二维字符网格-board-和一个字符串单词-word-。如果-word-存在于网格中，返回-true-；否则，返回-false-。" class="headerlink" title="描述：给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。"></a>描述：给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</h3></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">HLY</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://cddorz.github.io/2021/04/22/Leetcode%E5%A4%8D%E7%9B%98/">https://cddorz.github.io/2021/04/22/Leetcode%E5%A4%8D%E7%9B%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://cddorz.github.io" target="_blank">HLY-Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/leetcode/">leetcode</a></div><div class="post_share"><div class="social-share" data-image="https://pic4.zhimg.com/80/v2-2d53a7b90e55544f9b59dd46768052d1_720w.jpg?source=1940efc" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/05/31/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"><img class="prev-cover" data-lazy-src="https://pic1.zhimg.com/80/v2-39991d03db9215ec8781bc774341034c_720w.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">算法总结</div></div></a></div><div class="next-post pull-right"><a href="/2021/04/21/ThreadAndJUc/"><img class="next-cover" data-lazy-src="https://pic1.zhimg.com/80/v2-970266ced5316a103faa86bbf3f7f89b_720w.jpg?source=1940ef5c" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">ThreadAndJUc</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" data-lazy-src="/img/tubiao.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">HLY</div><div class="author-info__description">人生未完成...</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/cddorz"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/orzcdd" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2878153350@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">西电大二学生，学习后端开发，还是好好当后端奋斗人。</div></div></div><div class="card-widget card-history"><div class="card-content"><div class="item-headline"><i class="fas fa-paw fa-spin"></i><span>历史上的今天</span></div><div id="history-news" style="height: 100px;overflow: hidden;"><div id="history-card"></div></div></div></div><div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="clock"><img v-if="!clockshow" src="/images/loading.gif" style="height:120px;width:100%"/><table class="clock" v-if="clockshow"><tbody><tr><td class="clockdate">{{date}}</td><td class="weatherimg" align="center" valign="middle"><img id="weatherimg" :src="weatherimg"/></td><td class="temperature" align="center" valign="middle">{{temperature+ "*C"}}</td><td class="humidityimg"><img id="humidityimg" :src="humidityimg"/></td><td class="humidity">{{humidity + "%"}}</td></tr><tr class="time"><td colspan="5">{{time}}</td></tr><tr><td class="usaqi" colspan="1">{{usaqi + ' ' + 'US' + ' ' +'AQI' }}</td><td class="city" colspan="3">{{city}}</td><td class="daylight" colspan="1">{{daylight}}</td></tr></tbody></table></div></div></div></div></div><div class="card-widget card-recent-post"><div id="gamenews"><div class="card-content"><div class="item-headline"><i class="fas fa-cube"></i><span>ROLL资讯</span><i class="fas fa-retweet" @click="changetype(current)" style="float:right;margin-top:8px"></i></div><div class="newsbar"><span v-for="(type, index) in listtype" v-on:click="addClass(index)" v-bind:class="{ listtypeon:index==current}">{{type}}</span></div><div class="aside-list"><div class="aside-list-item" v-for="(news,index) in newsvue"><a class="thumbnail" href="javascript:void(0)" @click="getnewsdata(index)" :title="news.title"><img class="loaded" onerror="this.onerror=null;this.src='/img/404.jpg'" data-ll-status="loaded" :src="news.imgList[0]"/></a><div class="content"><a class="title" href="javascript:void(0)" @click="getnewsdata(index)" :title="news.title">{{news.title}}</a><time>{{news.postTime}}</time></div></div></div></div><div id="newsmodal"><button class="modalclose" @click="hidemodle()">关闭</button><h2>{{newpostvue.title}} </h2><h4>{{newpostvue.ptime}} &nbsp;&nbsp; {{newpostvue.source}}</h4><div v-html="newpostvue.content"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="toc-number">1.</span> <span class="toc-text">1.回文链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8%EF%BC%9A1-gt-2-gt-2-gt-1-true"><span class="toc-number">1.0.1.</span> <span class="toc-text">题目描述：回文链表：1-&gt;2-&gt;2-&gt;1 true</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A"><span class="toc-number">1.0.2.</span> <span class="toc-text">思路：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D"><span class="toc-number">2.</span> <span class="toc-text">2.括号匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%8C%85%E6%8B%AC-39-39-%EF%BC%8C-39-39-%EF%BC%8C-39-39-%EF%BC%8C-39-39-%EF%BC%8C-39-39-%EF%BC%8C-39-39-%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2-s-%EF%BC%8C%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E6%9C%89%E6%95%88%E3%80%82"><span class="toc-number">2.0.1.</span> <span class="toc-text">题目描述：给定一个只包括&#39;(&#39;，&#39;)&#39;，&#39;&amp;#123;&#39;，&#39;&amp;#125;&#39;，&#39;[&#39;，&#39;]&#39; 的字符串 s ，判断字符串是否有效。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A-1"><span class="toc-number">2.0.2.</span> <span class="toc-text">思路：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-x%E7%9A%84n%E6%AC%A1%E5%B9%82-%E9%80%92%E5%BD%92-%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="toc-number">3.</span> <span class="toc-text">3.x的n次幂(递归+快速幂)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A%E5%AE%9E%E7%8E%B0-pow-x-n-%EF%BC%8C%E5%8D%B3%E8%AE%A1%E7%AE%97-x-%E7%9A%84-n-%E6%AC%A1%E5%B9%82%E5%87%BD%E6%95%B0%EF%BC%88%E5%8D%B3%EF%BC%8Cx-n-%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">题目描述：实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，x^n^）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A-2"><span class="toc-number">3.2.</span> <span class="toc-text">思路：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">3.2.1.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0%E7%9A%84%E5%88%A4%E6%96%AD"><span class="toc-number">4.</span> <span class="toc-text">4.牛顿迭代法实现完全平方数的判断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%B3%95%EF%BC%9A"><span class="toc-number">4.0.1.</span> <span class="toc-text">二分法：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.</span> <span class="toc-text">5.判断是否是对称二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E6%AF%94%E8%BE%83%E5%B7%A6%E5%AD%A9%E5%AD%90%E7%9A%84%E4%B8%8E%E5%8F%B3%E5%AD%A9%E5%AD%90%E5%80%BC%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89%EF%BC%8C%E7%94%B1%E6%AD%A4%E6%83%B3%E5%88%B0%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%EF%BC%8C%E6%AF%94%E8%BE%83%E5%AE%B9%E6%98%93%E7%90%86%E8%A7%A3%EF%BC%8C%E5%B0%B1%E4%B8%8D%E5%8A%A0%E8%B5%98%E8%BF%B0%E4%BA%86%E3%80%82"><span class="toc-number">5.0.1.</span> <span class="toc-text">思路：比较左孩子的与右孩子值是否相等，由此想到递归实现，比较容易理解，就不加赘述了。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.</span> <span class="toc-text">6. 617 合并二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%89%8D%E5%BA%8F%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8C%E5%B9%B6%E5%B0%86%E5%80%BC%E7%9B%B8%E5%8A%A0"><span class="toc-number">6.0.1.</span> <span class="toc-text">思路：前序递归遍历二叉树，并将值相加</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">7.</span> <span class="toc-text">7.反转链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E5%88%B0%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9-%E7%84%B6%E5%90%8E%E5%8F%8D%E8%BD%AC"><span class="toc-number">7.1.</span> <span class="toc-text">思路:递归遍历到最后一个节点,然后反转</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E7%A7%BB%E5%8A%A8%E9%9B%B6-leectcode-283"><span class="toc-number">8.</span> <span class="toc-text">8.移动零 leectcode 283</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%EF%BC%9A%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84-nums%EF%BC%8C%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E5%B0%86%E6%89%80%E6%9C%89-0-%E7%A7%BB%E5%8A%A8%E5%88%B0%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%AB%E5%B0%BE%EF%BC%8C%E5%90%8C%E6%97%B6%E4%BF%9D%E6%8C%81%E9%9D%9E%E9%9B%B6%E5%85%83%E7%B4%A0%E7%9A%84%E7%9B%B8%E5%AF%B9%E9%A1%BA%E5%BA%8F%E3%80%82"><span class="toc-number">8.1.</span> <span class="toc-text">描述：给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%BF%AB%E6%8E%92%E5%AE%9E%E7%8E%B0%E7%A7%BB%E5%8A%A80%EF%BC%8C%E5%9B%A0%E4%B8%BA%E9%99%A4%E4%BA%86%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5%E5%A4%96%EF%BC%8C%E5%BF%AB%E6%8E%92%E6%98%AF%E6%89%80%E6%9C%89%E6%8E%92%E5%BA%8F%E4%B8%AD%E6%80%A7%E8%83%BD%E6%9C%80%E5%A5%BD%E7%9A%84%E7%AE%97%E6%B3%95%E3%80%82%E5%B0%86%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E4%BD%9C%E4%B8%BA%E5%9F%BA%E5%87%86%E5%80%BC%EF%BC%8C%E4%BB%8E%E5%B7%A6%E8%87%B3%E5%8F%B3%E9%81%8D%E5%8E%86%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%8D%E4%B8%BA0%EF%BC%8C%E5%88%99%E4%BA%A4%E6%8D%A2%EF%BC%8C%E4%BD%BF%E5%BE%97%E6%89%80%E6%9C%89%E4%B8%8D%E4%B8%BA0%E7%9A%84%E5%85%83%E7%B4%A0%E5%9C%A8%E6%95%B0%E7%BB%84%E5%B7%A6%E4%BE%A7%EF%BC%88%E6%95%B0%E7%BB%84%E5%88%86%E6%B2%BB%E6%80%9D%E6%83%B3"><span class="toc-number">8.2.</span> <span class="toc-text">思路：快排实现移动0，因为除了特殊情况外，快排是所有排序中性能最好的算法。将第一个元素作为基准值，从左至右遍历，如果不为0，则交换，使得所有不为0的元素在数组左侧（数组分治思想</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E6%95%B0%E7%BB%84-nums-%EF%BC%8C%E6%89%BE%E5%88%B0%E4%B8%80%E4%B8%AA%E5%85%B7%E6%9C%89%E6%9C%80%E5%A4%A7%E5%92%8C%E7%9A%84%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%EF%BC%88%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%B0%91%E5%8C%85%E5%90%AB%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%EF%BC%89%EF%BC%8C%E8%BF%94%E5%9B%9E%E5%85%B6%E6%9C%80%E5%A4%A7%E5%92%8C%E3%80%82"><span class="toc-number">9.</span> <span class="toc-text">9.给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%EF%BC%9A"><span class="toc-number">9.1.</span> <span class="toc-text">要点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A-3"><span class="toc-number">9.2.</span> <span class="toc-text">思路：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-number">10.</span> <span class="toc-text">10、二叉树最大深度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AE%9E%E7%8E%B0"><span class="toc-number">10.1.</span> <span class="toc-text">思路：简单动态规划实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%A4%A7%E5%B0%8F%E4%B8%BA-n-%E7%9A%84%E6%95%B0%E7%BB%84%EF%BC%8C%E6%89%BE%E5%88%B0%E5%85%B6%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0%E3%80%82%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0%E6%98%AF%E6%8C%87%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0-%E5%A4%A7%E4%BA%8E-%E2%8C%8A-n-2-%E2%8C%8B-%E7%9A%84%E5%85%83%E7%B4%A0%E3%80%82"><span class="toc-number">11.</span> <span class="toc-text">11、给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n&#x2F;2 ⌋ 的元素。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A-4"><span class="toc-number">11.1.</span> <span class="toc-text">思路：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%EF%BC%8C%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF%E3%80%82"><span class="toc-number">12.</span> <span class="toc-text">12、给定一个链表，判断链表中是否有环。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%EF%BC%8C%E8%8B%A5%E9%93%BE%E8%A1%A8%E6%9C%89%E7%8E%AF%EF%BC%8C%E5%88%99%E5%BF%AB%E6%8C%87%E9%92%88%E4%B8%80%E5%AE%9A%E8%BF%BD%E4%B8%8A%E6%85%A2%E6%8C%87%E9%92%88%EF%BC%8C%E4%B8%94%E5%BF%AB%E6%8C%87%E9%92%88%E5%8F%AA%E8%83%BD%E6%AF%94%E6%85%A2%E6%8C%87%E9%92%88%E5%BF%AB%E5%81%B6%E6%95%B0%E5%80%8D%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%98%AF%E5%A5%87%E6%95%B0%E5%80%8D%EF%BC%8C%E8%8B%A5%E7%8E%AF%E5%86%85%E5%85%83%E7%B4%A0%E4%B8%BA%E5%81%B6%E6%95%B0%EF%BC%8C%E5%88%99%E6%B0%B8%E8%BF%9C%E4%B8%8D%E4%BC%9A%E7%9B%B8%E9%81%87%EF%BC%88%E7%94%BB%E5%9B%BE%E5%8F%AF%E8%A7%A3"><span class="toc-number">12.1.</span> <span class="toc-text">思路：快慢指针，若链表有环，则快指针一定追上慢指针，且快指针只能比慢指针快偶数倍，如果是奇数倍，若环内元素为偶数，则永远不会相遇（画图可解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">13.</span> <span class="toc-text">13.翻转二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0"><span class="toc-number">13.1.</span> <span class="toc-text">思路：递归实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E3%80%81%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8"><span class="toc-number">14.</span> <span class="toc-text">14、相交链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%9B%A0%E4%B8%BA%E4%B8%A4%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4%EF%BC%8C%E6%89%80%E4%BB%A5%E4%B8%A4%E9%93%BE%E8%A1%A8%E6%9C%89%E4%B8%80%E9%83%A8%E5%88%86%E9%87%8D%E5%90%88%EF%BC%8C%E4%B8%80%E9%83%A8%E5%88%86%E4%B8%8D%E5%90%8C%EF%BC%8C%E8%8B%A5%E8%AE%A9%E4%B8%A4%E6%8C%87%E9%92%88%E5%88%86%E5%88%AB%E8%B5%B0A-B%EF%BC%8CB-A%E7%9A%84%E8%B7%AF%E7%A8%8B%EF%BC%8C%E5%88%99%E4%B8%A4%E6%8C%87%E9%92%88%EF%BC%8C%E4%B8%80%E5%AE%9A%E4%BC%9A%E5%9C%A8%E7%9B%B8%E4%BA%A4%E7%9A%84%E8%B5%B7%E5%A7%8B%E8%8A%82%E7%82%B9%E7%9B%B8%E9%81%87"><span class="toc-number">14.1.</span> <span class="toc-text">思路：因为两链表相交，所以两链表有一部分重合，一部分不同，若让两指针分别走A+B，B+A的路程，则两指针，一定会在相交的起始节点相遇</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E3%80%81%EF%BC%88448%EF%BC%89%E7%BB%99%E4%BD%A0%E4%B8%80%E4%B8%AA%E5%90%AB-n-%E4%B8%AA%E6%95%B4%E6%95%B0%E7%9A%84%E6%95%B0%E7%BB%84-nums-%EF%BC%8C%E5%85%B6%E4%B8%AD-nums-i-%E5%9C%A8%E5%8C%BA%E9%97%B4-1-n-%E5%86%85%E3%80%82%E8%AF%B7%E4%BD%A0%E6%89%BE%E5%87%BA%E6%89%80%E6%9C%89%E5%9C%A8-1-n-%E8%8C%83%E5%9B%B4%E5%86%85%E4%BD%86%E6%B2%A1%E6%9C%89%E5%87%BA%E7%8E%B0%E5%9C%A8-nums-%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%8C%E5%B9%B6%E4%BB%A5%E6%95%B0%E7%BB%84%E7%9A%84%E5%BD%A2%E5%BC%8F%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E3%80%82"><span class="toc-number">15.</span> <span class="toc-text">15、（448）给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A-5"><span class="toc-number">15.1.</span> <span class="toc-text">思路：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16%E3%80%81%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB"><span class="toc-number">16.</span> <span class="toc-text">16、汉明距离</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E7%AE%80%E5%8D%95%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">16.1.</span> <span class="toc-text">思路：简单的位运算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84"><span class="toc-number">17.</span> <span class="toc-text">17.最大路径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%EF%BC%9A-%E7%BB%99%E5%AE%9A%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8C%E4%BD%A0%E9%9C%80%E8%A6%81%E8%AE%A1%E7%AE%97%E5%AE%83%E7%9A%84%E7%9B%B4%E5%BE%84%E9%95%BF%E5%BA%A6%E3%80%82%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84%E9%95%BF%E5%BA%A6%E6%98%AF%E4%BB%BB%E6%84%8F%E4%B8%A4%E4%B8%AA%E7%BB%93%E7%82%B9%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E3%80%82%E8%BF%99%E6%9D%A1%E8%B7%AF%E5%BE%84%E5%8F%AF%E8%83%BD%E7%A9%BF%E8%BF%87%E4%B9%9F%E5%8F%AF%E8%83%BD%E4%B8%8D%E7%A9%BF%E8%BF%87%E6%A0%B9%E7%BB%93%E7%82%B9%E3%80%82"><span class="toc-number">17.1.</span> <span class="toc-text">描述： 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95"><span class="toc-number">17.2.</span> <span class="toc-text">思路：动态规划算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-number">18.</span> <span class="toc-text">18.爬楼梯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">18.1.</span> <span class="toc-text">思路：动态规划</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%EF%BC%88121%EF%BC%89%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6"><span class="toc-number">19.</span> <span class="toc-text">19.（121）股票的最大利润</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E6%9B%B4%E6%96%B0%E6%9C%80%E5%B0%8F%E5%80%BC%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%88%A9%E6%B6%A6"><span class="toc-number">19.1.</span> <span class="toc-text">思路：动态规划，更新最小值，动态规划利润</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="toc-number">20.</span> <span class="toc-text">20.(139) 单词拆分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%EF%BC%9A%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E9%9D%9E%E7%A9%BA%E5%AD%97%E7%AC%A6%E4%B8%B2-s-%E5%92%8C%E4%B8%80%E4%B8%AA%E5%8C%85%E5%90%AB%E9%9D%9E%E7%A9%BA%E5%8D%95%E8%AF%8D%E7%9A%84%E5%88%97%E8%A1%A8-wordDict%EF%BC%8C%E5%88%A4%E5%AE%9A-s-%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E7%A9%BA%E6%A0%BC%E6%8B%86%E5%88%86%E4%B8%BA%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E5%9C%A8%E5%AD%97%E5%85%B8%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E5%8D%95%E8%AF%8D%E3%80%82"><span class="toc-number">20.1.</span> <span class="toc-text">描述：给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A-6"><span class="toc-number">20.2.</span> <span class="toc-text">思路：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21%EF%BC%8879%EF%BC%89%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2"><span class="toc-number">21.</span> <span class="toc-text">21（79）单词搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%EF%BC%9A%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA-m-x-n-%E4%BA%8C%E7%BB%B4%E5%AD%97%E7%AC%A6%E7%BD%91%E6%A0%BC-board-%E5%92%8C%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8D%95%E8%AF%8D-word-%E3%80%82%E5%A6%82%E6%9E%9C-word-%E5%AD%98%E5%9C%A8%E4%BA%8E%E7%BD%91%E6%A0%BC%E4%B8%AD%EF%BC%8C%E8%BF%94%E5%9B%9E-true-%EF%BC%9B%E5%90%A6%E5%88%99%EF%BC%8C%E8%BF%94%E5%9B%9E-false-%E3%80%82"><span class="toc-number">21.1.</span> <span class="toc-text">描述：给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</span></a></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/09/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式"><img data-lazy-src="https://pic4.zhimg.com/80/v2-3c93265c69c1e73580fcaaa6ea83d8db_720w.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式"/></a><div class="content"><a class="title" href="/2021/09/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式">设计模式</a><time datetime="2021-09-06T02:20:15.000Z" title="发表于 2021-09-06 10:20:15">2021-09-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/07/12/JavaSE-01/" title="JavaSE-01"><img data-lazy-src="https://pic1.zhimg.com/80/v2-39991d03db9215ec8781bc774341034c_720w.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaSE-01"/></a><div class="content"><a class="title" href="/2021/07/12/JavaSE-01/" title="JavaSE-01">JavaSE-01</a><time datetime="2021-07-12T14:47:02.000Z" title="发表于 2021-07-12 22:47:02">2021-07-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/31/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" title="算法总结"><img data-lazy-src="https://pic1.zhimg.com/80/v2-39991d03db9215ec8781bc774341034c_720w.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法总结"/></a><div class="content"><a class="title" href="/2021/05/31/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" title="算法总结">算法总结</a><time datetime="2021-05-31T02:53:05.000Z" title="发表于 2021-05-31 10:53:05">2021-05-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/22/Leetcode%E5%A4%8D%E7%9B%98/" title="Leetcode复盘"><img data-lazy-src="https://pic4.zhimg.com/80/v2-2d53a7b90e55544f9b59dd46768052d1_720w.jpg?source=1940efc" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Leetcode复盘"/></a><div class="content"><a class="title" href="/2021/04/22/Leetcode%E5%A4%8D%E7%9B%98/" title="Leetcode复盘">Leetcode复盘</a><time datetime="2021-04-22T01:58:33.000Z" title="发表于 2021-04-22 09:58:33">2021-04-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/21/ThreadAndJUc/" title="ThreadAndJUc"><img data-lazy-src="https://pic1.zhimg.com/80/v2-970266ced5316a103faa86bbf3f7f89b_720w.jpg?source=1940ef5c" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ThreadAndJUc"/></a><div class="content"><a class="title" href="/2021/04/21/ThreadAndJUc/" title="ThreadAndJUc">ThreadAndJUc</a><time datetime="2021-04-21T03:14:43.000Z" title="发表于 2021-04-21 11:14:43">2021-04-21</time></div></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://pic4.zhimg.com/80/v2-2d53a7b90e55544f9b59dd46768052d1_720w.jpg?source=1940ef5c)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By HLY</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><span id="runtime"></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    let initData = {
      el: '#vcomment',
      appId: 'wVtvHWcQyk4142xnTO44te1Q-gzGzoHsz',
      appKey: 'sFGRGhXB5BisLaQGUEs5JVPv',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    }

    if (true) { 
      initData.requiredFields= ('nick,mail'.split(','))
    }
    
    if (false) {
      const otherData = false
      initData = Object.assign({}, initData, otherData)
    }
    
    const valine = new Valine(initData)
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><script src="/clock/js/clock.js"></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><script src="/news/js/keys.js"></script><script src="/news/js/news.js"></script><script src="/js/history.js"></script><script src="/js/historyroll.js"></script><script src="/clock/js/vue.min.js"></script><script src="/js/flipcountdown.js"></script><script data-pjax src="/js/runtime.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" async="async" mobile="true"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>
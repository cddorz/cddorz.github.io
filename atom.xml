<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HLY-Blog</title>
  
  <subtitle>保持少年，精神富足</subtitle>
  <link href="https://cddorz.github.io/atom.xml" rel="self"/>
  
  <link href="https://cddorz.github.io/"/>
  <updated>2021-12-21T15:09:34.811Z</updated>
  <id>https://cddorz.github.io/</id>
  
  <author>
    <name>HLY</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>machine-learning</title>
    <link href="https://cddorz.github.io/2021/12/21/machine-learning/"/>
    <id>https://cddorz.github.io/2021/12/21/machine-learning/</id>
    <published>2021-12-21T14:47:39.000Z</published>
    <updated>2021-12-21T15:09:34.811Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><h3 id="1-2-机器学习是什么？"><a href="#1-2-机器学习是什么？" class="headerlink" title="1.2 机器学习是什么？"></a>1.2 机器学习是什么？</h3><p>近一点的定义，由<strong>Tom Mitchell</strong>提出，来自卡内基梅隆大学，<strong>Tom</strong>定义的机器学习是，一个好的学习问题定义如下，他说，一个程序被认为能从经验<strong>E</strong>中学习，解决任务<strong>T</strong>，达到性能度量值<strong>P</strong>，当且仅当，有了经验<strong>E</strong>后，经过<strong>P</strong>评判，程序在处理T时的性能有所提升。我认为经验<strong>E</strong> 就是程序上万次的自我练习的经验而任务<strong>T</strong> 就是下棋。性能度量值<strong>P</strong>呢，就是它在与一些新的对手比赛时，赢得比赛的概率。</p><h3 id="1-3-监督学习"><a href="#1-3-监督学习" class="headerlink" title="1.3 监督学习"></a>1.3 监督学习</h3><p>横轴表示房子的面积，单位是平方英尺，纵轴表示房价，单位是千美元。那基于这组数据，假如你有一个朋友，他有一套750平方英尺房子，现在他希望把房子卖掉，他想知道这房子能卖多少钱。</p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.loli.net/2021/12/21/6AXrho7RUZlgIJj.png" alt="房价预测.png"></p><p>我们应用学习算法，可以在这组数据中画一条直线，或者换句话说，拟合一条直线，根据这条线我们可以推测出，这套房子可能卖$150,000，当然这不是唯一的算法。可能还有更好的，比如我们不用直线拟合这些数据，用二次方程去拟合可能效果会更好。根据二次方程的曲线，我们可以从这个点推测出，这套房子能卖接近$200,000。</p><p>可以看出，监督学习指的就是我们给学习算法一个数据集。这个数据集由“正确答案”组成。在房价的例子中，我们给了一系列房子的数据，我们给定数据集中每个样本的正确价格，即它们实际的售价然后运用学习算法，算出更多的正确答案。比如你朋友那个新房子的价格。用术语来讲，这叫做回归问题。我们试着推测出一个连续值的结果，即房子的价格。</p><p>一般房子的价格会记到美分，所以房价实际上是一系列离散的值，但是我们通常又把房价看成实数，看成是标量，所以又把它看成一个连续的数值。</p><p>回归这个词的意思是，我们在试着推测出这一系列连续值属性。</p><p>假设说你想通过查看病历来推测乳腺癌良性与否，假如有人检测出乳腺肿瘤，恶性肿瘤有害并且十分危险，而良性的肿瘤危害就没那么大，所以人们显然会很在意这个问题。</p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.loli.net/2021/12/21/ZifO6VDo2eWsXBg.png" alt="肿瘤.png"></p><p>让我们来看一组数据：这个数据集中，横轴表示肿瘤的大小，纵轴上，我标出1和0表示是或者不是恶性肿瘤。我们之前见过的肿瘤，如果是恶性则记为1，不是恶性，或者说良性记为0。</p><p>我有5个良性肿瘤样本，在1的位置有5个恶性肿瘤样本。现在我们有一个朋友很不幸检查出乳腺肿瘤。假设说她的肿瘤大概这么大，那么机器学习的问题就在于，你能否估算出肿瘤是恶性的或是良性的概率。用术语来讲，这是一个分类问题。</p><p>分类指的是，我们试着推测出离散的输出值：0或1良性或恶性，而事实上在分类问题中，输出可能不止两个值。比如说可能有三种乳腺癌，所以你希望预测离散输出0、1、2、3。0 代表良性，1 表示第1类乳腺癌，2表示第2类癌症，3表示第3类，但这也是分类问题。</p><p>因为这几个离散的输出分别对应良性，第一类第二类或者第三类癌症，在分类问题中我们可以用另一种方式绘制这些数据点。</p><p>现在我用不同的符号来表示这些数据。既然我们把肿瘤的尺寸看做区分恶性或良性的特征，那么我可以这么画，我用不同的符号来表示良性和恶性肿瘤。或者说是负样本和正样本现在我们不全部画<strong>X</strong>，良性的肿瘤改成用 <strong>O</strong> 表示，恶性的继续用 <strong>X</strong> 表示。来预测肿瘤的恶性与否。</p><p>在其它一些机器学习问题中，可能会遇到不止一种特征。举个例子，我们不仅知道肿瘤的尺寸，还知道对应患者的年龄。在其他机器学习问题中，我们通常有更多的特征，我朋友研究这个问题时，通常采用这些特征，比如肿块密度，肿瘤细胞尺寸的一致性和形状的一致性等等，还有一些其他的特征。这就是我们即将学到最有趣的学习算法之一。</p><p>那种算法不仅能处理2种3种或5种特征，即使有无限多种特征都可以处理。</p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.loli.net/2021/12/21/dQGptunEq1CXJiz.png" alt="3.png"></p><p>上图中，我列举了总共5种不同的特征，坐标轴上的两种和右边的3种，但是在一些学习问题中，你希望不只用3种或5种特征。相反，你想用无限多种特征，好让你的算法可以利用大量的特征，或者说线索来做推测。那你怎么处理无限多个特征，甚至怎么存储这些特征都存在问题，你电脑的内存肯定不够用</p><p>监督学习其基本思想是，我们数据集中的每个样本都有相应的“正确答案”。再根据这些样本作出预测，就像房子和肿瘤的例子中做的那样。回归问题，即通过回归来推出一个连续的输出，分类问题，其目标是推出一组离散的结果。</p><h3 id="1-4-无监督学习"><a href="#1-4-无监督学习" class="headerlink" title="1.4 无监督学习"></a>1.4 无监督学习</h3><p>在无监督学习中，我们已知的数据。看上去有点不一样，不同于监督学习的数据的样子，即无监督学习中没有任何的标签或者是有相同的标签或者就是没标签。所以我们已知数据集，却不知如何处理，也未告知每个数据点是什么。别的都不知道，就是一个数据集。你能从数据中找到某种结构吗？针对数据集，无监督学习就能判断出数据有两个不同的聚集簇。这是一个，那是另一个，二者不同。是的，无监督学习算法可能会把这些数据分成两个不同的簇。所以叫做聚类算法。事实证明，它能被用在很多地方。</p><p>聚类应用的一个例子就是在谷歌新闻中。如果你以前从来没见过它，你可以到这个URL网址news.google.com去看看。谷歌新闻每天都在，收集非常多，非常多的网络的新闻内容。它再将这些新闻分组，组成有关联的新闻。所以谷歌新闻做的就是搜索非常多的新闻事件，自动地把它们聚类到一起。所以，这些新闻事件全是同一主题的，所以显示到一起。</p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.loli.net/2021/12/21/d3XuyOhGvUBQIMq.png" alt="DNA.png"></p><p>其中就有基因学的理解应用。一个<strong>DNA</strong>微观数据的例子。基本思想是输入一组不同个体，对其中的每个个体，你要分析出它们是否有一个特定的基因。技术上，你要分析多少特定基因已经表达。所以这些颜色，红，绿，灰等等颜色，这些颜色展示了相应的程度，即不同的个体是否有着一个特定的基因。你能做的就是运行一个聚类算法，把个体聚类到不同的类或不同类型的组（人）……</p><p>所以这个就是无监督学习，因为我们没有提前告知算法一些信息，比如，这是第一类的人，那些是第二类的人，还有第三类，等等。我们只是说，是的，这是有一堆数据。我不知道数据里面有什么。我不知道谁是什么类型。我甚至不知道人们有哪些不同的类型，这些类型又是什么。但你能自动地找到数据中的结构吗？就是说你要自动地聚类那些个体到各个类，我没法提前知道哪些是哪些。因为我们没有给算法正确答案来回应数据集中的数据，所以这就是无监督学习。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h2&gt;&lt;h3 id=&quot;1-2-机器学习是什么？&quot;&gt;&lt;a href=&quot;#1-2-机器学习是什么？&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="AI" scheme="https://cddorz.github.io/categories/AI/"/>
    
    
    <category term="机器学习" scheme="https://cddorz.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://cddorz.github.io/2021/09/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://cddorz.github.io/2021/09/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-09-06T02:20:15.000Z</published>
    <updated>2021-09-06T02:31:08.831Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="单例模式（Singletion）"><a href="#单例模式（Singletion）" class="headerlink" title="单例模式（Singletion）"></a>单例模式（Singletion）</h3><hr><h4 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h4><p>确保一个类只有一个实例，并提供该实例的全局访问点</p><h4 id="Class-Diagram"><a href="#Class-Diagram" class="headerlink" title="Class Diagram"></a>Class Diagram</h4><p>使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。</p><p>私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/eca1f422-8381-409b-ad04-98ef39ae38ba.png" alt="img"></p><h4 id="双重校验锁-线程安全"><a href="#双重校验锁-线程安全" class="headerlink" title="双重校验锁-线程安全"></a>双重校验锁-线程安全</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singletion</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqurInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Q-为什么在第一个判断语句内加锁？"><a href="#Q-为什么在第一个判断语句内加锁？" class="headerlink" title="Q.为什么在第一个判断语句内加锁？"></a>Q.为什么在第一个判断语句内加锁？</h5><h5 id="A-因为这也能保证-uniqueInstance-被实例化以后，调用该方法的线程可以直接退出，不用等待。"><a href="#A-因为这也能保证-uniqueInstance-被实例化以后，调用该方法的线程可以直接退出，不用等待。" class="headerlink" title="A.因为这也能保证 uniqueInstance 被实例化以后，调用该方法的线程可以直接退出，不用等待。"></a>A.因为这也能保证 uniqueInstance 被实例化以后，调用该方法的线程可以直接退出，不用等待。</h5><h5 id="Q-为什么要有两个-if-判断语句？"><a href="#Q-为什么要有两个-if-判断语句？" class="headerlink" title="Q.为什么要有两个 if 判断语句？"></a>Q.为什么要有两个 if 判断语句？</h5><h5 id="A-如果只使用了一个-if-语句。在-uniqueInstance-null-的情况下，如果两个线程都执行了-if-语句，那么两个线程都会进入-if-语句块内。虽然在-if-语句块内有加锁操作，但是两个线程都会执行-uniqueInstance-new-Singleton-这条语句，只是先后的问题，那么就会进行两次实例化。因此必须使用双重校验锁，也就是需要使用两个-if-语句：第一个-if-语句用来避免-uniqueInstance-已经被实例化之后的加锁操作，而第二个-if-语句进行了加锁，所以只能有一个线程进入，就不会出-uniqueInstance-null-时两个线程同时进行实例化操作。"><a href="#A-如果只使用了一个-if-语句。在-uniqueInstance-null-的情况下，如果两个线程都执行了-if-语句，那么两个线程都会进入-if-语句块内。虽然在-if-语句块内有加锁操作，但是两个线程都会执行-uniqueInstance-new-Singleton-这条语句，只是先后的问题，那么就会进行两次实例化。因此必须使用双重校验锁，也就是需要使用两个-if-语句：第一个-if-语句用来避免-uniqueInstance-已经被实例化之后的加锁操作，而第二个-if-语句进行了加锁，所以只能有一个线程进入，就不会出-uniqueInstance-null-时两个线程同时进行实例化操作。" class="headerlink" title="A.如果只使用了一个 if 语句。在 uniqueInstance == null 的情况下，如果两个线程都执行了 if 语句，那么两个线程都会进入 if 语句块内。虽然在 if 语句块内有加锁操作，但是两个线程都会执行 uniqueInstance = new Singleton(); 这条语句，只是先后的问题，那么就会进行两次实例化。因此必须使用双重校验锁，也就是需要使用两个 if 语句：第一个 if 语句用来避免 uniqueInstance 已经被实例化之后的加锁操作，而第二个 if 语句进行了加锁，所以只能有一个线程进入，就不会出 uniqueInstance == null 时两个线程同时进行实例化操作。"></a>A.如果只使用了一个 if 语句。在 uniqueInstance == null 的情况下，如果两个线程都执行了 if 语句，那么两个线程都会进入 if 语句块内。虽然在 if 语句块内有加锁操作，但是两个线程都会执行 <code>uniqueInstance = new Singleton();</code> 这条语句，只是先后的问题，那么就会进行两次实例化。因此必须使用双重校验锁，也就是需要使用两个 if 语句：第一个 if 语句用来避免 uniqueInstance 已经被实例化之后的加锁操作，而第二个 if 语句进行了加锁，所以只能有一个线程进入，就不会出 uniqueInstance == null 时两个线程同时进行实例化操作。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">        uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Q-unique-Instance-为什么使用-volatile-关键字修饰？"><a href="#Q-unique-Instance-为什么使用-volatile-关键字修饰？" class="headerlink" title="Q.unique Instance 为什么使用 volatile 关键字修饰？"></a>Q.unique Instance 为什么使用 volatile 关键字修饰？</h5><h5 id="A-因为unique-Instance-new-Singleton-这段代码分三步执行："><a href="#A-因为unique-Instance-new-Singleton-这段代码分三步执行：" class="headerlink" title="A. 因为unique Instance = new Singleton(); 这段代码分三步执行："></a>A. 因为unique Instance = new Singleton(); 这段代码分三步执行：</h5><ul><li>为 uniqueInstance 分配内存空间</li><li>初始化 uniqueInstance </li><li>将 uniqueInstance 指向分配的内存地址</li></ul><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1&gt;3&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p><p>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p><h3 id="简单工厂（Simple-Factory）"><a href="#简单工厂（Simple-Factory）" class="headerlink" title="简单工厂（Simple Factory）"></a>简单工厂（Simple Factory）</h3><hr><h4 id="Intent-1"><a href="#Intent-1" class="headerlink" title="Intent"></a>Intent</h4><p>在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的接口。</p><h4 id="Class-Diagram-1"><a href="#Class-Diagram-1" class="headerlink" title="Class Diagram"></a>Class Diagram</h4><p>简单工厂把实例化的操作单独放在一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用那个具体子类来实例化。</p><p>==这样做能把客户类和具体子类的实现解耦==，客户类不再需要知道有哪些子类以及应当实例化哪个子类。客户类往往有多个，如果不使用简单工厂，那么所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/40c0c17e-bba6-4493-9857-147c0044a018.png" alt="img"></p><h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct1</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct2</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下的 Client 类包含了实例化的代码，这是一种错误的实现。如果在客户类中存在这种实例化代码，就需要考虑将代码放到简单工厂中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> type = <span class="number">1</span>;</span><br><span class="line">        Product product;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">            product = <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">            product = <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            product = <span class="keyword">new</span> ConcreteProduct();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// do something with the product</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下的 SimpleFactory 是简单工厂实现，它被所有需要进行实例化的客户类调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleFactory simpleFactory = <span class="keyword">new</span> SimpleFactory();</span><br><span class="line">        Product product = simpleFactory.createProduct(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// do something with the product</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="观察者（Observer）"><a href="#观察者（Observer）" class="headerlink" title="观察者（Observer）"></a>观察者（Observer）</h3><hr><h4 id="Intent-2"><a href="#Intent-2" class="headerlink" title="Intent"></a>Intent</h4><p>定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会受到通知并且自动更新状态。</p><p>主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7a3c6a30-c735-4edb-8115-337288a4f0f2.jpg" alt="img"></p><h3 id="https-cyc2018-xyz-其它-设计模式-设计模式-观察者-html-class-diagram-Class-Diagram"><a href="#https-cyc2018-xyz-其它-设计模式-设计模式-观察者-html-class-diagram-Class-Diagram" class="headerlink" title="[#](https://cyc2018.xyz/其它/设计模式/设计模式 - 观察者.html#class-diagram)Class Diagram"></a>[#](<a href="https://cyc2018.xyz/%E5%85%B6%E5%AE%83/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">https://cyc2018.xyz/其它/设计模式/设计模式</a> - 观察者.html#class-diagram)Class Diagram</h3><p>主题（Subject）具有注册和移除观察者、并通知所有观察者的功能，主题是通过维护一张观察者列表来实现这些操作的。</p><p>观察者（Observer）的注册功能需要调用主题的 registerObserver() 方法。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a8c8f894-a712-447c-9906-5caef6a016e3.png" alt="img"></p><h4 id="Implementation-1"><a href="#Implementation-1" class="headerlink" title="Implementation"></a>Implementation</h4><p>天气数据布告板会在天气信息发生改变时更新其内容，布告板有多个，并且在将来会继续增加。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b1df9732-86ce-4d69-9f06-fba1db7b3b5a.jpg" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> pressure;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeatherData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMeasurements</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">        <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">        <span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">        notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        observers.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = observers.indexOf(o);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            observers.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer o : observers) &#123;</span><br><span class="line">            o.update(temperature, humidity, pressure);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp,<span class="keyword">float</span> humidity,<span class="keyword">float</span> pressure)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatisticsDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="title">StatisticsDisplay</span><span class="params">(Subject weatherData)</span> </span>&#123;        weatherData.registerObserver(<span class="keyword">this</span>);    &#125;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span> </span>&#123;        System.out.println(<span class="string">&quot;StatisticsDisplay.update: &quot;</span> + temp + <span class="string">&quot; &quot;</span> + humidity + <span class="string">&quot; &quot;</span> + pressure);    &#125;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentConditionsDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="title">CurrentConditionsDisplay</span><span class="params">(Subject weatherData)</span> </span>&#123;        weatherData.registerObserver(<span class="keyword">this</span>);    &#125;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span> </span>&#123;        System.out.println(<span class="string">&quot;CurrentConditionsDisplay.update: &quot;</span> + temp + <span class="string">&quot; &quot;</span> + humidity + <span class="string">&quot; &quot;</span> + pressure);    &#125;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherStation</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        WeatherData weatherData = <span class="keyword">new</span> WeatherData();        CurrentConditionsDisplay currentConditionsDisplay = <span class="keyword">new</span> CurrentConditionsDisplay(weatherData);        StatisticsDisplay statisticsDisplay = <span class="keyword">new</span> StatisticsDisplay(weatherData);        weatherData.setMeasurements(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);        weatherData.setMeasurements(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);    &#125;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;设计模式&quot;&gt;&lt;a href=&quot;#设计模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式&quot;&gt;&lt;/a&gt;设计模式&lt;/h2&gt;&lt;h3 id=&quot;单例模式（Singletion）&quot;&gt;&lt;a href=&quot;#单例模式（Singletion）&quot; class=&quot;head</summary>
      
    
    
    
    <category term="面试基础" scheme="https://cddorz.github.io/categories/%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="设计模式" scheme="https://cddorz.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>算法总结</title>
    <link href="https://cddorz.github.io/2021/05/31/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://cddorz.github.io/2021/05/31/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2021-05-31T02:53:05.000Z</published>
    <updated>2021-06-02T03:24:19.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、快速排序算法（leetcode复盘：-8）"><a href="#一、快速排序算法（leetcode复盘：-8）" class="headerlink" title="一、快速排序算法（leetcode复盘： 8）"></a>一、快速排序算法（leetcode复盘： 8）</h2><p>==主要思想==</p><ul><li>从序列中，任选一个记录k作为<strong>轴值pivot</strong></li><li>选择策略<ul><li>第一个元素</li><li>最后一个元素</li><li>中间元素</li></ul></li><li>将数组元素，分割成<strong>左子序列L</strong>和<strong>右子序列R</strong></li><li>L 中所有元素都 &lt; k， R 中所有元素都 &gt; k</li><li>对 L 和 R递归进行快排，直到子序列中有 0 个 或者 1 个元素，退出</li></ul><p>通过画图理解算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hly</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 分治思想：快速排序算法实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-31 11:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 快速排序 </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] n = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n.length; i++) &#123;</span><br><span class="line">            System.out.print(n[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        quickSort(n,<span class="number">0</span>,<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n.length; i++) &#123;</span><br><span class="line">            System.out.print(n[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归快排</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] n,<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">            dp = partition(n,left,right);</span><br><span class="line">            quickSort(n,dp + <span class="number">1</span>,right);</span><br><span class="line">            quickSort(n,left,dp - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分区函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] n, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="comment">// pivot 存储基准值</span></span><br><span class="line">        <span class="keyword">int</span> pivot = n[left];</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; n[right] &gt;= pivot)&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">                n[left] = n[right];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; n[left] &lt;= pivot)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">                n[right] = n[left];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分区值</span></span><br><span class="line">        n[left] = pivot;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">    <span class="number">1</span> <span class="number">5</span> <span class="number">6</span> <span class="number">3</span> <span class="number">2</span> <span class="number">8</span> <span class="number">9</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">9</span> </span><br></pre></td></tr></table></figure><ul><li><p>时间复杂度：</p><ul><li><p>平均：O(Nlogn)</p></li><li><p>最差：O(N^2^)</p></li></ul></li></ul><h2 id="二、动态规划（leetcode-复盘：-9）"><a href="#二、动态规划（leetcode-复盘：-9）" class="headerlink" title="二、动态规划（leetcode 复盘： 9）"></a>二、动态规划（leetcode 复盘： 9）</h2><p>动态规划的解题核心主要分为两步：</p><ol><li><strong>第一步：状态的定义</strong></li><li><strong>第二步：状态转移方程的定义</strong></li></ol><p>在这里，我们为了避免混淆用“状态”这个词来替代“问题”这个词。“问题”表示的含义类似：题目、要求解的内容、题干中的疑问句这样的概念。状态表示我们在求解问题之中对问题的分析转化。</p><h3 id="第一步：状态的定义"><a href="#第一步：状态的定义" class="headerlink" title="第一步：状态的定义"></a>第一步：状态的定义</h3><p>有的问题过于抽象，或者过于啰嗦干扰我们解题的思路，我们要做的就是将题干中的问题进行转化（换一种说法，含义不变）。转化成一系列同类问题的某个解的情况，比如说：</p><blockquote><p>题目：求一个数列中最大连续子序列的和。</p></blockquote><p>我们要将这个原问题转化为：</p><blockquote><p>状态定义：Fk是第k项前的最大序列和，求F1～FN中最大值。</p></blockquote><p>通过换一种表述方式，我们清晰的发现了解决问题的思路，如何求出F1～FN中的最大值是解决原问题的关键部分。上述将原问题转化成另一种表述方式的过程叫做：状态的定义。这样的状态定义给出了一种类似通解的思路，把一个原来毫无头绪的问题转换成了可以求解的问题。</p><h3 id="第二步：状态转移方程的定义"><a href="#第二步：状态转移方程的定义" class="headerlink" title="第二步：状态转移方程的定义"></a>第二步：状态转移方程的定义</h3><p>在进行了状态的定义后，自然而然的想到去求解F1～FN中最大值。这也是状态定义的作用，让我们把一个总体的问题转化成一系列问题，而第二步：状态转移方程的定义则告诉我们如何去求解一个问题，对于上述已经转换成一系列问题我们要关注的点就在于：如何能够用前一项或者前几项的信息得到下一项，这种从最优子状态转换为下一个最优状态的思路就是动态规划的核心。<br>对于上面的例子题目来说，状态转移方程的定义应该是：</p><blockquote><p>Fk=max{Fk-1+Ak,Ak}<br>Fk是前k项的和，Ak是第k项的值</p></blockquote><p>仔细思考一番，我们能够得到这样的结论，对于前k个项的最大子序列和是前k-1项的最大子序列和Fk与第k项的和、或者第k项两者中较大的。如果大家还是不能理解这个原理建议用演算纸自己计算一番，这里就不过多赘述了。这种状态转移的思路就是DP的核心。</p><p>看过了如何去使用动态规划，那么随之而来的问题就在于：既然动态规划不是某个固定的算法，而是一种策略思路，那么什么时候应该去使用什么时候不能用呢？答案很简短：</p><p>对于一个可拆分问题中存在可以由前若干项计算当前项的问题可以由动态规划计算。 </p><h2 id="三、二叉树相关（leetcode-复盘：5、6、10）"><a href="#三、二叉树相关（leetcode-复盘：5、6、10）" class="headerlink" title="三、二叉树相关（leetcode 复盘：5、6、10）"></a>三、二叉树相关（leetcode 复盘：5、6、10）</h2><h3 id="前序遍历："><a href="#前序遍历：" class="headerlink" title="前序遍历："></a>前序遍历：</h3><p>若二叉树为空，则退出，否则进行下面操作</p><ul><li>访问根节点</li><li>先根遍历左子树</li><li>先根遍历右子树</li><li>退出</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BinaryTreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        System.out.println(node.getData()); <span class="comment">//先访问根节点</span></span><br><span class="line">        PreOrder(node.getLeftChirld());  <span class="comment">//先根遍历左子树</span></span><br><span class="line">        PreOrder(node.getRightChirld());  <span class="comment">//先根遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历："><a href="#中序遍历：" class="headerlink" title="中序遍历："></a>中序遍历：</h3><p>若二叉树为空，则退出，否则进行下面操作</p><ul><li>中根遍历左子树</li><li>访问根节点</li><li>中根遍历右子树</li><li>退出</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BinaryTreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        InOrder(node.getLeftChirld());  <span class="comment">//中根遍历左子树</span></span><br><span class="line">        System.out.println(node);    <span class="comment">//访问根节点</span></span><br><span class="line">        InOrder(node.getRightChirld());  <span class="comment">//中根遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历："><a href="#后序遍历：" class="headerlink" title="后序遍历："></a>后序遍历：</h3><p>若二叉树为空，则退出，否则进行下面操作</p><ul><li>后根遍历左子树</li><li>后根遍历右子树</li><li>访问根节点</li><li>退出</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BinaryTreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            PostOrder(node.getLeftChirld());  <span class="comment">//后根遍历左子树</span></span><br><span class="line">            PostOrder(node.getRightChirld());  <span class="comment">//后根遍历右子树</span></span><br><span class="line">            System.out.println(node);   <span class="comment">//访问根节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、快速排序算法（leetcode复盘：-8）&quot;&gt;&lt;a href=&quot;#一、快速排序算法（leetcode复盘：-8）&quot; class=&quot;headerlink&quot; title=&quot;一、快速排序算法（leetcode复盘： 8）&quot;&gt;&lt;/a&gt;一、快速排序算法（leetcode</summary>
      
    
    
    
    
    <category term="算法" scheme="https://cddorz.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode复盘</title>
    <link href="https://cddorz.github.io/2021/04/22/Leetcode%E5%A4%8D%E7%9B%98/"/>
    <id>https://cddorz.github.io/2021/04/22/Leetcode%E5%A4%8D%E7%9B%98/</id>
    <published>2021-04-22T01:58:33.000Z</published>
    <updated>2021-10-17T07:08:56.184Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DP动态规划"><a href="#DP动态规划" class="headerlink" title="DP动态规划"></a>DP动态规划</h1><h2 id="9-给定一个整数数组-nums-，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。"><a href="#9-给定一个整数数组-nums-，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。" class="headerlink" title="9.给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。"></a>9.给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</h2><h3 id="要点："><a href="#要点：" class="headerlink" title="要点："></a>要点：</h3><ul><li>连续子数组</li><li>最大和</li></ul><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><ul><li><p>整数数组有正有负</p></li><li><p>sum 保存动态最大和，又可能出现负数情况</p></li><li><p>动态规划，ans 保存最后结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day4;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-04 10:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">max</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 保存结果</span></span><br><span class="line">        <span class="keyword">int</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="comment">// 如果sum为负数，直接赋值num</span></span><br><span class="line">            <span class="keyword">if</span>(sum &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                sum = num;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sum += num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 动态规划</span></span><br><span class="line">            ans = Math.max(sum,ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="10、二叉树最大深度"><a href="#10、二叉树最大深度" class="headerlink" title="10、二叉树最大深度"></a>10、二叉树最大深度</h2><h3 id="思路：简单动态规划实现"><a href="#思路：简单动态规划实现" class="headerlink" title="思路：简单动态规划实现"></a>思路：简单动态规划实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day4;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个二叉树，找出其最大深度。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-04 21:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">maxDepth</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        <span class="keyword">int</span> left = maxDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = maxDepth(root.right);</span><br><span class="line">        <span class="comment">// 动态规划</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="17-最大路径"><a href="#17-最大路径" class="headerlink" title="17.最大路径"></a>17.最大路径</h2><h3 id="描述：-给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。"><a href="#描述：-给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。" class="headerlink" title="描述： 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。"></a>描述： 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</h3><h3 id="思路：动态规划算法"><a href="#思路：动态规划算法" class="headerlink" title="思路：动态规划算法"></a>思路：动态规划算法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day6;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-06 23:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">zuidaluj</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        depth(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 访问到空节点了，返回0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左儿子为根的子树的深度</span></span><br><span class="line">        <span class="keyword">int</span> L = depth(node.left);</span><br><span class="line">        <span class="comment">// 右儿子为根的子树的深度</span></span><br><span class="line">        <span class="keyword">int</span> R = depth(node.right);</span><br><span class="line">        <span class="comment">// 计算d_node即L+R+1 并更新ans</span></span><br><span class="line">        ans = Math.max(ans, L+R);</span><br><span class="line">        <span class="comment">// 返回该节点为根的子树的深度</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(L, R)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="18-爬楼梯"><a href="#18-爬楼梯" class="headerlink" title="18.爬楼梯"></a>18.爬楼梯</h2><h3 id="思路：动态规划"><a href="#思路：动态规划" class="headerlink" title="思路：动态规划"></a>思路：动态规划</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day7;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</span></span><br><span class="line"><span class="comment"> * 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</span></span><br><span class="line"><span class="comment"> * 递归实现会超时，why？递归实现时间复杂度为2^n</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-07 10:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">climb</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="19-（121）股票的最大利润"><a href="#19-（121）股票的最大利润" class="headerlink" title="19.（121）股票的最大利润"></a>19.（121）股票的最大利润</h2><h3 id="思路：动态规划，更新最小值，动态规划利润"><a href="#思路：动态规划，更新最小值，动态规划利润" class="headerlink" title="思路：动态规划，更新最小值，动态规划利润"></a>思路：动态规划，更新最小值，动态规划利润</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day7;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 股票问题（动态规划）比较简单</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-07 20:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">max</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min=prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : prices)&#123;</span><br><span class="line">            <span class="keyword">if</span>(min&gt;=i)&#123;</span><br><span class="line">                min = i;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res,i-min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="20-139-单词拆分"><a href="#20-139-单词拆分" class="headerlink" title="20.(139) 单词拆分"></a>20.(139) 单词拆分</h2><h3 id="描述：给定一个非空字符串-s-和一个包含非空单词的列表-wordDict，判定-s-是否可以被空格拆分为一个或多个在字典中出现的单词。"><a href="#描述：给定一个非空字符串-s-和一个包含非空单词的列表-wordDict，判定-s-是否可以被空格拆分为一个或多个在字典中出现的单词。" class="headerlink" title="描述：给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。"></a>描述：给定一个<strong>非空</strong>字符串 <em>s</em> 和一个包含<strong>非空</strong>单词的列表 <em>wordDict</em>，判定 <em>s</em> 是否可以被空格拆分为一个或多个在字典中出现的单词。</h3><h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><ul><li>动态规划，ｄｐ［ｉ］表示ｓ前ｉ个字符能否拆分</li><li>转移方程：dp[j] = dp[i] &amp;&amp; check(s[i+1, j])</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 动态规划算法，dp[i]表示s前i个字符能否拆分</span></span><br><span class="line"><span class="comment"> * 转移方程：dp[j] = dp[i] &amp;&amp; check(s[i+1, j]);</span></span><br><span class="line"><span class="comment"> * check(s[i+1, j])就是判断i+1到j这一段字符是否能够拆分</span></span><br><span class="line"><span class="comment"> * 其实，调整遍历顺序，这等价于s[i+1, j]是否是wordDict中的元素</span></span><br><span class="line"><span class="comment"> * 这个举个例子就很容易理解。</span></span><br><span class="line"><span class="comment"> * 假如wordDict=[&quot;apple&quot;, &quot;pen&quot;, &quot;code&quot;],s = &quot;applepencode&quot;;</span></span><br><span class="line"><span class="comment"> * dp[8] = dp[5] + check(&quot;pen&quot;)</span></span><br><span class="line"><span class="comment"> * 翻译一下：前八位能否拆分取决于前五位能否拆分，加上五到八位是否属于字典</span></span><br><span class="line"><span class="comment"> * (注意：i的顺序是从j-1 -&gt; 0哦~,因为substring（x，y）x--&gt;0开始索引 y---&gt;1开始索引)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-08 20:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">chaifen</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;String,Boolean&gt; map =  <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//检查s是否属于字典</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.getOrDefault(s,<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(String word : wordDict)&#123;</span><br><span class="line">            map.put(word,<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; s.length();j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = j-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">                <span class="comment">// dp[8] = dp[5] + check(&quot;pen&quot;)</span></span><br><span class="line">                dp[j] = dp[i] &amp;&amp; check(s.substring(i,j));</span><br><span class="line">                <span class="keyword">if</span>(dp[j])&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="23-（62）不同路径"><a href="#23-（62）不同路径" class="headerlink" title="23.（62）不同路径"></a>23.（62）不同路径</h2><h3 id="描述：一个机器人位于一个-m-x-n-网格的左上角-（起始点在下图中标记为-“Start”-）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为-“Finish”-）。问总共有多少条不同的路径？"><a href="#描述：一个机器人位于一个-m-x-n-网格的左上角-（起始点在下图中标记为-“Start”-）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为-“Finish”-）。问总共有多少条不同的路径？" class="headerlink" title="描述：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。问总共有多少条不同的路径？"></a>描述：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。问总共有多少条不同的路径？</h3><h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><ul><li>因为机器人只能向下或者向右移动，所以移动到网格的 <strong>第一排</strong> 以及 <strong>第一列</strong> 的路径都只有一条</li><li>移动到某个位置有多少条路径取决于 它的 <strong>上一格</strong> 以及 <strong>左一格</strong> 有多少条路径相加的和</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="comment">// 将第一排以及第一列的元素都变成1，因为只有一条路径到达</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>;i &lt; m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">1</span>;j &lt; n;j++)&#123;</span><br><span class="line">                <span class="comment">// 左一格 以及 上一格 的和</span></span><br><span class="line">                dp[i][j] = dp[i][j-<span class="number">1</span>] + dp[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="1-回文链表"><a href="#1-回文链表" class="headerlink" title="1.回文链表"></a>1.回文链表</h2><h4 id="题目描述：回文链表：1-gt-2-gt-2-gt-1-true"><a href="#题目描述：回文链表：1-gt-2-gt-2-gt-1-true" class="headerlink" title="题目描述：回文链表：1-&gt;2-&gt;2-&gt;1 true"></a>题目描述：回文链表：1-&gt;2-&gt;2-&gt;1 true</h4><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><ul><li><p>首先需要记录中间位置，以便翻转，由此想到快慢指针来进行标记</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">     fast = fast.next.next;</span><br><span class="line">     slow = slow.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遇到的一个小坑！后面解释</span></span><br><span class="line"> <span class="keyword">if</span>(fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">     slow = slow.next;</span><br><span class="line"> &#125;</span><br><span class="line">当fast指针遍历到末尾时，slow指针遍历到中间</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>其次是翻转链表，这里定义pre，prepre指针来直接翻转链表，破坏了链表结构，有坑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ListNode pre&#x3D;head,prepre&#x3D;null;</span><br><span class="line"> while(fast !&#x3D; null &amp;&amp; fast.next !&#x3D; null)&#123;</span><br><span class="line">           pre &#x3D; slow;</span><br><span class="line">           slow &#x3D; slow.next;</span><br><span class="line">           fast &#x3D; fast.next.next;</span><br><span class="line">           pre.next &#x3D; prepre;</span><br><span class="line">           prepre &#x3D; pre;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>最后，比较pre和slow</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while(pre!&#x3D;null&amp;&amp;slow!&#x3D;null)&#123;</span><br><span class="line">            if(slow.val!&#x3D;pre.val)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            pre&#x3D;pre.next;</span><br><span class="line">            slow&#x3D;slow.next;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 回文链表：1-&gt;2-&gt;2-&gt;1 true</span></span><br><span class="line"><span class="comment"> * 通过pre 和 prepre指针来反转链表</span></span><br><span class="line"><span class="comment"> * fast指针走完，slow到一半</span></span><br><span class="line"><span class="comment"> * 只是破坏了链表的结构</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-01 20:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">huiwenlianbiao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结构体链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode() &#123;&#125;</span><br><span class="line">        ListNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">        ListNode(<span class="keyword">int</span> val, ListNode next) &#123; <span class="keyword">this</span>.val = val; <span class="keyword">this</span>.next = next; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>&amp;&amp;head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//prepre pre 用来反转链表</span></span><br><span class="line">        ListNode slow=head,fast=head;</span><br><span class="line">        ListNode pre=head,prepre=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            pre.next = prepre;</span><br><span class="line">            prepre = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pre!=<span class="keyword">null</span>&amp;&amp;slow!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(slow.val!=pre.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre=pre.next;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>==坑！！！！==</p><p>一开始不知道为啥会有 if(fast!=null){slow = slow.next;}这一段代码，因为如果是1-&gt;2-&gt;3-&gt;2-&gt;1的回文链表，这样就会让slow只有2-&gt;1，除去了3的比较，一开始我一直以为pre和slow是同步的，这样才能翻转比较，但后来仔细看了看代码，pre其实是比slow晚一步的，因为这种pre的方式是破坏了链表结构，链表的前段部分是翻转了的，所以如果pre和slow是同步的话，3其实有两个next，就会出现错误。</p><p>所以如果是奇数链表，那么pre和slow都是从3的前一个，后一个元素开始比较，-如果是偶数链表，当然也不会出现这种情况。</p><h2 id="2-括号匹配"><a href="#2-括号匹配" class="headerlink" title="2.括号匹配"></a>2.括号匹配</h2><p>算是一个比较经典的问题了，首先需要了解几个Java的容器，Map、HashMap、Deque（栈）</p><h4 id="题目描述：给定一个只包括-39-39-，-39-39-，-39-39-，-39-39-，-39-39-，-39-39-的字符串-s-，判断字符串是否有效。"><a href="#题目描述：给定一个只包括-39-39-，-39-39-，-39-39-，-39-39-，-39-39-，-39-39-的字符串-s-，判断字符串是否有效。" class="headerlink" title="题目描述：给定一个只包括&#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串 s ，判断字符串是否有效。"></a>题目描述：给定一个只包括<code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</h4><h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><ul><li><p>首先需要思考的是怎么匹配前后括号，因为输入形式是”{[]}”、”()[]{}”这样的，匹配的时候需要，匹配好一对括号就删除，因此想到了栈结构，通过压栈和弹栈来实现</p></li><li><p>接下来，就考虑如何匹配，想到用HashMap 的k-v键值对来存储括号，因为后括号在前括号之后，所以k存储后括号，v存储前括号，如果遇到前括号，就压栈，如果遇到后括号，看看栈顶和其匹不匹配，匹配就把前括号弹栈。</p></li><li><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 括号匹配</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-01 20:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">matching</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="comment">//如果长度是奇数，一定不匹配</span></span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character, Character&gt; pairs = <span class="keyword">new</span> HashMap&lt;Character,Character&gt;() &#123;&#123;</span><br><span class="line">            put(<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            put(<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">            put(<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        Deque&lt;Character&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//遍历s</span></span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (pairs.containsKey(ch)) &#123;</span><br><span class="line">                <span class="comment">//判断括号是否匹配</span></span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty() || !stack.peek().equals(pairs.get(ch))) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-x的n次幂-递归-快速幂"><a href="#3-x的n次幂-递归-快速幂" class="headerlink" title="3.x的n次幂(递归+快速幂)"></a>3.x的n次幂(递归+快速幂)</h2><h3 id="题目描述：实现-pow-x-n-，即计算-x-的-n-次幂函数（即，x-n-）"><a href="#题目描述：实现-pow-x-n-，即计算-x-的-n-次幂函数（即，x-n-）" class="headerlink" title="题目描述：实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，x^n^）"></a>题目描述：实现 <a href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数（即，x^n^）</h3><h3 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h3><ul><li>首先想到，从左至右<em>x</em>→<em>x</em>^2^→<em>x</em>^4^→<em>x</em>^9^→<em>x</em>^19^→<em>x</em>^38^→<em>x</em>^77^，每次都将上次的结果进行平方，但有些步骤需要多*一个x，这就会比较困难，如何判断到底要不要多×一个x</li><li>但如果我们从右往左看，分治的思想就十分明显：<ul><li>当我们要计算 x^n^时，可以先递归的算出y = x^[n/2]^,其中[a]表示对a向下取整</li><li>根据递归计算的结果，如果n为偶数，那么x^n^ = y*y，如果n为奇数，那么x^n^ = y * y * x</li><li>递归的边界为 n = 0，任意数的 0次方均为 1。</li><li>由于每次递归都会使得指数减少一半，因此递归的层数为 <em>O</em>(log<em>n</em>)</li></ul></li></ul><p>完整代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速幂+递归实现x的n次幂</span></span><br><span class="line"><span class="comment"> * 从右向左分析</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-01 23:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">pow</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> N = n;</span><br><span class="line">            <span class="comment">//若n是负数，则1/</span></span><br><span class="line">            <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> N)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (N == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">double</span> y = quickMul(x, N / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span> ? y * y : y * y * x;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(logn)，即为递归的层数。</li></ul><ul><li>空间复杂度：O(logn)，即为递归的层数。这是由于递归的函数调用会使用栈空间。</li></ul><h2 id="4-牛顿迭代法实现完全平方数的判断"><a href="#4-牛顿迭代法实现完全平方数的判断" class="headerlink" title="4.牛顿迭代法实现完全平方数的判断"></a>4.牛顿迭代法实现完全平方数的判断</h2><p>![G_YXC__JI@5_P_L~22`G5_0.png](<a href="https://i.loli.net/2021/04/22/d9fgKHIMhUOjnpZ.png">https://i.loli.net/2021/04/22/d9fgKHIMhUOjnpZ.png</a>)</p><p>由于这种解法太过神仙，就不多解释了，看图就好，这只是一种无限接近的解法，会有误差，但误差在允许的范围之内。</p><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> x = num / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (x * x &gt; num) &#123;</span><br><span class="line">      x = (x + num / x) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (x * x == num);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二分法："><a href="#二分法：" class="headerlink" title="二分法："></a>二分法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> left = <span class="number">2</span>, right = num / <span class="number">2</span>, x, guessSquared;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">      x = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">      guessSquared = x * x;</span><br><span class="line">      <span class="keyword">if</span> (guessSquared == num) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (guessSquared &gt; num) &#123;</span><br><span class="line">        right = x - <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left = x + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-判断是否是对称二叉树"><a href="#5-判断是否是对称二叉树" class="headerlink" title="5.判断是否是对称二叉树"></a>5.判断是否是对称二叉树</h2><h4 id="思路：比较左孩子的与右孩子值是否相等，由此想到递归实现，比较容易理解，就不加赘述了。"><a href="#思路：比较左孩子的与右孩子值是否相等，由此想到递归实现，比较容易理解，就不加赘述了。" class="headerlink" title="思路：比较左孩子的与右孩子值是否相等，由此想到递归实现，比较容易理解，就不加赘述了。"></a>思路：比较左孩子的与右孩子值是否相等，由此想到递归实现，比较容易理解，就不加赘述了。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过递归实现判断是否是对称二叉树</span></span><br><span class="line"><span class="comment"> * 递归终止条件：两个节点都为空；其中一个节点为空；两个节点值不相等</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-02 10:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">isSymmetric</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用递归函数，比较左节点，右节点</span></span><br><span class="line">        <span class="keyword">return</span> dfs(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(TreeNode left, TreeNode right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归的终止条件是两个节点都为空</span></span><br><span class="line">        <span class="comment">//或者两个节点中有一个为空</span></span><br><span class="line">        <span class="comment">//或者两个节点的值不相等</span></span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span> &amp;&amp; right==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span> || right==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left.val!=right.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再递归的比较 左节点的左孩子 和 右节点的右孩子</span></span><br><span class="line">        <span class="comment">//以及比较  左节点的右孩子 和 右节点的左孩子</span></span><br><span class="line">        <span class="keyword">return</span> dfs(left.left,right.right) &amp;&amp; dfs(left.right,right.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode() &#123;&#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-617-合并二叉树"><a href="#6-617-合并二叉树" class="headerlink" title="6. 617 合并二叉树"></a>6. 617 合并二叉树</h2><h4 id="思路：前序递归遍历二叉树，并将值相加"><a href="#思路：前序递归遍历二叉树，并将值相加" class="headerlink" title="思路：前序递归遍历二叉树，并将值相加"></a>思路：前序递归遍历二叉树，并将值相加</h4><ul><li><p>递归终止条件,两节点有一个或两个节点为null就返回</p></li><li><p>递归函数内,将两个树的节点相加后,再递归执行两节点的左节点和右节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">dfs</span><span class="params">(TreeNode r1, TreeNode r2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (r1 == <span class="keyword">null</span> || r2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> r1 == <span class="keyword">null</span> ? r2 : r1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//树2合并到树1上</span></span><br><span class="line">        <span class="comment">//前序遍历二叉树</span></span><br><span class="line">        r1.val += r2.val;</span><br><span class="line">        r1.left = dfs(r1.left, r2.left);</span><br><span class="line">        r1.right = dfs(r1.right, r2.right);</span><br><span class="line">        <span class="keyword">return</span> r1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>完整代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归法合并二叉树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-02 15:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">merge</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="keyword">null</span> || root2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root1 == <span class="keyword">null</span> ? root2 : root1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(root1, root2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">dfs</span><span class="params">(TreeNode r1, TreeNode r2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (r1 == <span class="keyword">null</span> || r2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> r1 == <span class="keyword">null</span> ? r2 : r1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//树2合并到树1上</span></span><br><span class="line">        <span class="comment">//前序遍历二叉树</span></span><br><span class="line">        r1.val += r2.val;</span><br><span class="line">        r1.left = dfs(r1.left, r2.left);</span><br><span class="line">        r1.right = dfs(r1.right, r2.right);</span><br><span class="line">        <span class="keyword">return</span> r1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="7-反转链表"><a href="#7-反转链表" class="headerlink" title="7.反转链表"></a>7.反转链表</h2><h3 id="思路-递归遍历到最后一个节点-然后反转"><a href="#思路-递归遍历到最后一个节点-然后反转" class="headerlink" title="思路:递归遍历到最后一个节点,然后反转"></a>思路:递归遍历到最后一个节点,然后反转</h3><ul><li><p>递归终止条件: head == null  or  head.next == null</p></li><li><p>递归函数内容:将指针反转,注意节点下一位必须指向null,否则不算成功</p></li><li><p>时间复杂度:O(n),n为节点个数们,需要遍历n个节点进行反转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归实现反转链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-02 23:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">reverseList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode newhead = reverseList(head.next);</span><br><span class="line">        <span class="comment">//反转指针</span></span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="8-移动零-leectcode-283"><a href="#8-移动零-leectcode-283" class="headerlink" title="8.移动零 leectcode 283"></a>8.移动零 leectcode 283</h2><h3 id="描述：给定一个数组-nums，编写一个函数将所有-0-移动到数组的末尾，同时保持非零元素的相对顺序。"><a href="#描述：给定一个数组-nums，编写一个函数将所有-0-移动到数组的末尾，同时保持非零元素的相对顺序。" class="headerlink" title="描述：给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。"></a>描述：给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</h3><h3 id="思路：快排实现移动0，因为除了特殊情况外，快排是所有排序中性能最好的算法。将第一个元素作为基准值，从左至右遍历，如果不为0，则交换，使得所有不为0的元素在数组左侧（数组分治思想"><a href="#思路：快排实现移动0，因为除了特殊情况外，快排是所有排序中性能最好的算法。将第一个元素作为基准值，从左至右遍历，如果不为0，则交换，使得所有不为0的元素在数组左侧（数组分治思想" class="headerlink" title="思路：快排实现移动0，因为除了特殊情况外，快排是所有排序中性能最好的算法。将第一个元素作为基准值，从左至右遍历，如果不为0，则交换，使得所有不为0的元素在数组左侧（数组分治思想"></a>思路：快排实现移动0，因为除了特殊情况外，快排是所有排序中性能最好的算法。将第一个元素作为基准值，从左至右遍历，如果不为0，则交换，使得所有不为0的元素在数组左侧（数组分治思想</h3><p>快排：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day3;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快排实现数组中0都在数组的末尾</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-03 22:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">moveZero</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">                temp = nums[i];</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j] = temp;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="11、给定一个大小为-n-的数组，找到其中的多数元素。多数元素是指在数组中出现次数-大于-⌊-n-2-⌋-的元素。"><a href="#11、给定一个大小为-n-的数组，找到其中的多数元素。多数元素是指在数组中出现次数-大于-⌊-n-2-⌋-的元素。" class="headerlink" title="11、给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。"></a>11、给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。</h2><h3 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h3><ul><li>找众数，首先想到用额外的空间map来存放key–遍历的数，value–出现的次数</li><li>但空间复杂度比较高，由此想到用一个变量来存放众数出现的次数</li><li>若不是<strong>candidata</strong> 则 -1，若是则 +1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day4;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目：给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。</span></span><br><span class="line"><span class="comment"> * 摩尔投票法：</span></span><br><span class="line"><span class="comment"> * 我们遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0</span></span><br><span class="line"><span class="comment"> * 我们先将 x 的值赋予 candidate，随后我们判断 x：</span></span><br><span class="line"><span class="comment"> * 如果 x 与 candidate 相等，那么计数器 count 的值增加 1；</span></span><br><span class="line"><span class="comment"> * 如果 x 与 candidate 不等，那么计数器 count 的值减少 1。</span></span><br><span class="line"><span class="comment"> * 在遍历完成后，candidate 即为整个数组的众数。</span></span><br><span class="line"><span class="comment"> * nums:      [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]</span></span><br><span class="line"><span class="comment"> * candidate:  7  7  7  7  7  7   5  5   5  5  5  5   7  7  7  7</span></span><br><span class="line"><span class="comment"> * count:      1  2  1  2  1  0   1  0   1  2  1  0   1  2  3  4</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-04 23:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">most</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> candidate = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                candidate = num;</span><br><span class="line">            &#125;</span><br><span class="line">            count += (num == candidate) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="12、给定一个链表，判断链表中是否有环。"><a href="#12、给定一个链表，判断链表中是否有环。" class="headerlink" title="12、给定一个链表，判断链表中是否有环。"></a>12、给定一个链表，判断链表中是否有环。</h2><h3 id="思路：快慢指针，若链表有环，则快指针一定追上慢指针，且快指针只能比慢指针快偶数倍，如果是奇数倍，若环内元素为偶数，则永远不会相遇（画图可解"><a href="#思路：快慢指针，若链表有环，则快指针一定追上慢指针，且快指针只能比慢指针快偶数倍，如果是奇数倍，若环内元素为偶数，则永远不会相遇（画图可解" class="headerlink" title="思路：快慢指针，若链表有环，则快指针一定追上慢指针，且快指针只能比慢指针快偶数倍，如果是奇数倍，若环内元素为偶数，则永远不会相遇（画图可解"></a>思路：快慢指针，若链表有环，则快指针一定追上慢指针，且快指针只能比慢指针快偶数倍，如果是奇数倍，若环内元素为偶数，则永远不会相遇（画图可解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day5;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个链表，判断链表中是否有环。</span></span><br><span class="line"><span class="comment"> * 解法：快慢指针，快指针先进入环，如果快指针追上慢指针，证明有环</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-05 14:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">cycle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head.next;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-翻转二叉树"><a href="#13-翻转二叉树" class="headerlink" title="13.翻转二叉树"></a>13.翻转二叉树</h2><h3 id="思路：递归实现"><a href="#思路：递归实现" class="headerlink" title="思路：递归实现"></a>思路：递归实现</h3><ul><li>递归终止条件：root 为 null，则返回root</li><li>递归函数内交换当前节点左右子树，在递归交换子树的左右子树</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day5;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 翻转一棵二叉树。</span></span><br><span class="line"><span class="comment"> * 递归实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-05 17:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">invert</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归函数的终止条件，节点为空时返回</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//下面三句是将当前节点的左右子树交换</span></span><br><span class="line">        TreeNode tmp = root.right;</span><br><span class="line">        root.right = root.left;</span><br><span class="line">        root.left = tmp;</span><br><span class="line">        <span class="comment">//递归交换当前节点的 左子树</span></span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        <span class="comment">//递归交换当前节点的 右子树</span></span><br><span class="line">        invertTree(root.right);</span><br><span class="line">        <span class="comment">//函数返回时就表示当前这个节点，以及它的左右子树</span></span><br><span class="line">        <span class="comment">//都已经交换完了</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14、相交链表"><a href="#14、相交链表" class="headerlink" title="14、相交链表"></a>14、相交链表</h2><h3 id="思路：因为两链表相交，所以两链表有一部分重合，一部分不同，若让两指针分别走A-B，B-A的路程，则两指针，一定会在相交的起始节点相遇"><a href="#思路：因为两链表相交，所以两链表有一部分重合，一部分不同，若让两指针分别走A-B，B-A的路程，则两指针，一定会在相交的起始节点相遇" class="headerlink" title="思路：因为两链表相交，所以两链表有一部分重合，一部分不同，若让两指针分别走A+B，B+A的路程，则两指针，一定会在相交的起始节点相遇"></a>思路：因为两链表相交，所以两链表有一部分重合，一部分不同，若让两指针分别走A+B，B+A的路程，则两指针，一定会在相交的起始节点相遇</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day5;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 编写一个程序，找到两个单链表相交的起始节点。</span></span><br><span class="line"><span class="comment"> * A+B = B+A 因为相交，所以最后一段相同，所以a，b指针分别走A+B以及B+A，则一定a会=b</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-05 23:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xiangjiao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode a = headA;</span><br><span class="line">        ListNode b = headB;</span><br><span class="line">        <span class="keyword">while</span>(a != b)&#123;</span><br><span class="line">            a = (a==<span class="keyword">null</span>) ? headB : a.next;</span><br><span class="line">            b = (b==<span class="keyword">null</span>) ? headA : b.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15、（448）给你一个含-n-个整数的数组-nums-，其中-nums-i-在区间-1-n-内。请你找出所有在-1-n-范围内但没有出现在-nums-中的数字，并以数组的形式返回结果。"><a href="#15、（448）给你一个含-n-个整数的数组-nums-，其中-nums-i-在区间-1-n-内。请你找出所有在-1-n-范围内但没有出现在-nums-中的数字，并以数组的形式返回结果。" class="headerlink" title="15、（448）给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。"></a>15、（448）给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。</h2><h3 id="思路：-7"><a href="#思路：-7" class="headerlink" title="思路："></a>思路：</h3><ul><li>首先，可以考虑用哈希表记录，但空间复杂度较高</li><li>用nums本身来记录，就是每遍历一个 x 就让 nums[x-1] 增加n，这样 x 对应下标的数一定 &gt; n，最后再遍历，，判断小于 n 的数的下标加入数组即可</li><li>注意，有可能 num 已经加过 n 了，所以要对 num 取余</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day6;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</span></span><br><span class="line"><span class="comment"> * 找到所有在 [1, n] 范围之间没有出现在数组中的数字。</span></span><br><span class="line"><span class="comment"> * 解法：遍历数组，遍历一次x就使nums[x-1] + n，这样如果数组中没有的数字，那么他们-1对应的下标的数应该&lt;=n</span></span><br><span class="line"><span class="comment"> * 由此筛选出不是数组中的数字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-06 15:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">findDisappear</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="comment">//有可能这个x已经加过n了，除于还原原来的数字</span></span><br><span class="line">            <span class="keyword">int</span> x = (num - <span class="number">1</span>) % n;</span><br><span class="line">            nums[x]+=n;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt;= n)&#123;</span><br><span class="line">                list.add(i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="16、汉明距离"><a href="#16、汉明距离" class="headerlink" title="16、汉明距离"></a>16、汉明距离</h2><h3 id="思路：简单的位运算"><a href="#思路：简单的位运算" class="headerlink" title="思路：简单的位运算"></a>思路：简单的位运算</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day6;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。</span></span><br><span class="line"><span class="comment"> * 给出两个整数 x 和 y，计算它们之间的汉明距离。</span></span><br><span class="line"><span class="comment"> * x  y 异或不同位为1，统计异或结果1的数目即为答案</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-06 9:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hamming</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//异或。统计xor为1的个数即可</span></span><br><span class="line">        <span class="keyword">int</span> xor = x ^ y;</span><br><span class="line">        <span class="keyword">int</span> distance = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//右移位统计xor的1</span></span><br><span class="line">        <span class="keyword">while</span> (xor != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 因为若二进制末位为1，则 % 2 一定为1</span></span><br><span class="line">            <span class="keyword">if</span> (xor % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                distance += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 右移，判断下一位</span></span><br><span class="line">            xor = xor &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> distance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="21（79）单词搜索"><a href="#21（79）单词搜索" class="headerlink" title="21（79）单词搜索"></a>21（79）单词搜索</h2><h3 id="描述：给定一个-m-x-n-二维字符网格-board-和一个字符串单词-word-。如果-word-存在于网格中，返回-true-；否则，返回-false-。"><a href="#描述：给定一个-m-x-n-二维字符网格-board-和一个字符串单词-word-。如果-word-存在于网格中，返回-true-；否则，返回-false-。" class="headerlink" title="描述：给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。"></a>描述：给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</h3><p>思路：</p><ul><li>DFS深度优先搜索</li><li>上下左右遍历，并且标记遍历过的值</li><li>base 条件，是否越界</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[][] DIRECTIONS = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rows;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cols;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> len;</span><br><span class="line"><span class="comment">// 标记元素是否被访问过</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[][] visited;</span><br><span class="line"><span class="comment">// 单词数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] charArray;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[][] board;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board,String word)</span></span>&#123;</span><br><span class="line">        rows = board.length;</span><br><span class="line">        <span class="keyword">if</span>(rows == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cols = board[<span class="number">0</span>].length;</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">        <span class="keyword">this</span>.len = word.length();</span><br><span class="line">        <span class="keyword">this</span>.charArray = word.toCharArray();</span><br><span class="line">        <span class="keyword">this</span>.board = board;</span><br><span class="line">        <span class="comment">// 通过此循坏来找到正确的初值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; rows;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j &lt; cols;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(i,j,<span class="number">0</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> begin)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin == len - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> board[x][y] == charArray[begin];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(board[x][y]==charArray[begin])&#123;</span><br><span class="line">            <span class="comment">// 记录是否走过</span></span><br><span class="line">            visited[x][y] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 左下右上的顺序回溯正确路径</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] direction : DIRECTIONS)&#123;</span><br><span class="line">                <span class="keyword">int</span> newX = x + direction[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> newY = y + direction[<span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 新路径未越界，并且没有走过</span></span><br><span class="line">                <span class="keyword">if</span>(inArea(newX,newY)&amp;&amp;!visited[newX][newY])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dfs(newX,newY,begin+<span class="number">1</span>))&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 证明不是正确的初值，清零记录</span></span><br><span class="line">            visited[x][y] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; cols;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="22-（98）验证二叉搜索树"><a href="#22-（98）验证二叉搜索树" class="headerlink" title="22.（98）验证二叉搜索树"></a>22.（98）验证二叉搜索树</h2><h3 id="描述：给你一个二叉树的根节点-root-，判断其是否是一个有效的二叉搜索树。"><a href="#描述：给你一个二叉树的根节点-root-，判断其是否是一个有效的二叉搜索树。" class="headerlink" title="描述：给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。"></a>描述：给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</h3><p>有效 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 小于 当前节点的数。</li><li>节点的右子树只包含 大于 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><h3 id="思路：-8"><a href="#思路：-8" class="headerlink" title="思路："></a>思路：</h3><ul><li>中序遍历，对比每一次遍历的值是否 &lt;= pre</li><li>用一个 pre 来记录上个遍历的树节点的值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> pre = Long.MIN_VALUE;</span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归遍历左子树</span></span><br><span class="line">        <span class="keyword">if</span>(!isValidBST(root.left))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 访问当前节点：如果当前节点小于等于中序遍历的前一个节点，说明不满足 BST，返回 false；否则继续遍历。</span></span><br><span class="line">        <span class="keyword">if</span>(root.val &lt;= pre)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root.val;</span><br><span class="line">        <span class="comment">// 递归遍历右子树</span></span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="24-621-任务调度器"><a href="#24-621-任务调度器" class="headerlink" title="24.(621) 任务调度器"></a>24.(621) 任务调度器</h2><h3 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;DP动态规划&quot;&gt;&lt;a href=&quot;#DP动态规划&quot; class=&quot;headerlink&quot; title=&quot;DP动态规划&quot;&gt;&lt;/a&gt;DP动态规划&lt;/h1&gt;&lt;h2 id=&quot;9-给定一个整数数组-nums-，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其</summary>
      
    
    
    
    <category term="算法" scheme="https://cddorz.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="leetcode" scheme="https://cddorz.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>练手记录</title>
    <link href="https://cddorz.github.io/2021/03/10/%E7%BB%83%E6%89%8B%E8%AE%B0%E5%BD%95/"/>
    <id>https://cddorz.github.io/2021/03/10/%E7%BB%83%E6%89%8B%E8%AE%B0%E5%BD%95/</id>
    <published>2021-03-10T07:06:11.000Z</published>
    <updated>2021-03-20T11:28:43.190Z</updated>
    
    <content type="html"><![CDATA[<h4 id="写在前言：主要记录练手小项目，当作一个mad文档，也同时记录一些遇到的问题和总结经验。"><a href="#写在前言：主要记录练手小项目，当作一个mad文档，也同时记录一些遇到的问题和总结经验。" class="headerlink" title="写在前言：主要记录练手小项目，当作一个mad文档，也同时记录一些遇到的问题和总结经验。"></a>写在前言：主要记录练手小项目，当作一个mad文档，也同时记录一些遇到的问题和总结经验。</h4><hr><h4 id="1-项目准备"><a href="#1-项目准备" class="headerlink" title="1.项目准备"></a>1.项目准备</h4><p>​    需求分析    模块    功能</p><p>​    库表设计    数据库</p><p>​    详细设计    流程图伪代码的方式</p><p>​    编码环节：</p><p>​        a.环境准备</p><p>​        b.正式进入编码环节</p><p>​    测试     部署上线</p><h4 id="2-技术选型"><a href="#2-技术选型" class="headerlink" title="2.技术选型"></a>2.技术选型</h4><p>​    前端：vue + axios</p><p>​    后端：spring boot   +   mybatis   +  mysql   + tomcat   +Redis</p><h4 id="3-需求分析"><a href="#3-需求分析" class="headerlink" title="3.需求分析"></a>3.需求分析</h4><h5 id="用户模块"><a href="#用户模块" class="headerlink" title="用户模块"></a>用户模块</h5><p>​            a.用户登录</p><p>​            b.用户注册</p><p>​            c.验证码实现</p><p>​            d.欢迎xx用户展示</p><p>​            e.安全退出</p><p>​            f.员工列表展示</p><h5 id="员工模块"><a href="#员工模块" class="headerlink" title="员工模块"></a>员工模块</h5><p>​            g.员工添加</p><p>​            h.员工删除</p><p>​            i.员工修改</p><p>​            j.员工列表加入Redis缓存实现</p><h4 id="4-库表设计"><a href="#4-库表设计" class="headerlink" title="4.库表设计"></a>4.库表设计</h4><p>​            1.分析系统中有哪些表     2.分析表与表之间关系</p><p>​            用户表</p><p>​                        id     username    realname    password    sex    stauts    registerTime（注册时间）</p><p>​            员工表</p><p>​                        id     name    path（头像）    salary    age</p><h4 id="5-编码环节"><a href="#5-编码环节" class="headerlink" title="5.编码环节"></a>5.编码环节</h4><p>​        a.环境搭建：<br>​                springboot + myabtis + mysql      引入员工管理系统页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">项目名： ems_vue</span><br><span class="line">项目中包：</span><br><span class="line">src&#x2F;main&#x2F;java</span><br><span class="line">com.hly.xxx</span><br><span class="line">    .util</span><br><span class="line">    .dao</span><br><span class="line">    .service</span><br><span class="line">    .......</span><br><span class="line">src&#x2F;main&#x2F;resource</span><br><span class="line">application.propertiesspringboot配置文件</span><br><span class="line">application-dev.properties  测试配置</span><br><span class="line">application-prod.properties生产配置</span><br><span class="line">com&#x2F;hly&#x2F;mapper&#x2F;用来存放mybatis的mapper配置文件</span><br><span class="line">com&#x2F;hly&#x2F;sql用来存放项目中数据可文件</span><br><span class="line">static用来存放静态资源</span><br><span class="line"></span><br><span class="line">项目编码：UTF-8</span><br></pre></td></tr></table></figure><h4 id="6-总结："><a href="#6-总结：" class="headerlink" title="6.总结："></a>6.总结：</h4><h5 id="1-收获："><a href="#1-收获：" class="headerlink" title="1.收获："></a>1.收获：</h5><blockquote><p>耗时三天做完了这个小项目，对mvc的结构有了更深层次的理解，对mybatis的集成有了更好的掌握。</p><p>controller: 调取service层方法；返回前端jason数据；与前端交互最深的api</p><p>dao层：与mapper层相连，主要用于操作数据库数据</p><p>entity:实体类</p><p>service:service接口</p><p>serviceImpl: 实现service接口方法的实现类，调用dao层方法，主要用于实现相应的修改数据库的功能</p><p>utils：工具类层：主要是封装好的工具类便于其他接口调用，如 redis工具类</p><p>mapper：集成mybatis用sql语句操作数据库</p><p>会解决git错误，对git指令有了更好的运用</p><p>熟悉Linux操作，并独立解决了某些配置问题</p><p>注：以上为自己理解所写出的东西，有一定的不专业性，这次的小练手让我对错误并不那么惧怕了。</p></blockquote><h5 id="2-不足："><a href="#2-不足：" class="headerlink" title="2.不足："></a>2.不足：</h5><blockquote><p>对创建数据库还不够熟悉，不能根据功能来建造具体的数据库。</p><p>对集成redis还不够熟悉，只懂得redis基础和如何配置</p><p>对于如果没有前端代码，如何测试后端接口还不够熟悉（apipost and postman需要学习如何使用）</p><p>对于如何发短信验证码还不知道</p><p>对于如何保存图片信息还不够熟悉</p></blockquote><h5 id="3-未来展望："><a href="#3-未来展望：" class="headerlink" title="3.未来展望："></a>3.未来展望：</h5><blockquote><p>希望每做完一个项目之后都有自己的思考，因为现在学得不够多的原因，无法拓展，优化功能，但这是一个很重要的点。希望以后能够多思考。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;写在前言：主要记录练手小项目，当作一个mad文档，也同时记录一些遇到的问题和总结经验。&quot;&gt;&lt;a href=&quot;#写在前言：主要记录练手小项目，当作一个mad文档，也同时记录一些遇到的问题和总结经验。&quot; class=&quot;headerlink&quot; title=&quot;写在前言：主</summary>
      
    
    
    
    <category term="日常" scheme="https://cddorz.github.io/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="小项目" scheme="https://cddorz.github.io/tags/%E5%B0%8F%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>token、session、cookie那些事</title>
    <link href="https://cddorz.github.io/2020/12/01/token%E3%80%81session%E3%80%81cookie/"/>
    <id>https://cddorz.github.io/2020/12/01/token%E3%80%81session%E3%80%81cookie/</id>
    <published>2020-12-01T02:55:08.000Z</published>
    <updated>2020-12-01T03:10:25.889Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、美好的旧时光"><a href="#1、美好的旧时光" class="headerlink" title="1、美好的旧时光"></a>1、美好的旧时光</h4><p>我经常怀念三十年前那美好的旧时光， 工作很轻松， 生活很悠闲。</p><p>上班的时候偶尔有些HTTP的请求发到我这里， 我简单的看一下， 取出相对应的html文档，图片，发回去就可以了， 然后就可以继续喝茶聊天。</p><p>我的创造者们对我很严格， 他们制定的一个简单HTTP协议， 就是请求加响应，  尤其是我不用记住是谁刚刚发了HTTP请求，  每个请求对我来说都是全新的！</p><p>邮件服务器很羡慕我， 他说：老弟，你的生活太惬意了，  哪像我， 每次有人从客户端访问邮箱， 我都得专门给他建立一个会话， 来处理他发的消息， 你倒好， 完全不用管理会话。</p><p>这是由应用的特性决定的， 如果邮件服务器不管理会话， 那多个人之间的邮件消息就会完全混到一起了， 乱作一团了。</p><p>而30年前的Web 基本上就是文档的浏览而已， 既然是浏览，我作为一个服务器， 为什么要记住谁在一段时间里都浏览了什么文档呢？</p><h4 id="2、Session"><a href="#2、Session" class="headerlink" title="2、Session"></a>2、Session</h4><p>但是好日子没持续多久， 很快大家就不满足于静态的Html 文档了， 交互式的Web应用开始兴起， 尤其是论坛， 在线购物等网站。</p><p>我马上就遇到了和邮件服务器一样的问题， 那就是必须管理会话，必须记住哪些人登录系统，  哪些人往自己的购物车中放了商品，  也就是说我必须把每个人区分开。</p><p>这对我来说是个不小的挑战， 由于HTTP协议的无状态特性， 我必须加点小手段，才能完成会话管理。</p><p>我想出的办法就是给大家发一个会话标识(session id), 说白了就是一个随机的字符串，每个人收到的都不一样，  每次大家向我发起HTTP请求的时候，把这个字符串给一并捎过来， 这样我就能区分开谁是谁了。</p><h4 id="3、沉重的负担"><a href="#3、沉重的负担" class="headerlink" title="3、沉重的负担"></a>3、沉重的负担</h4><p>大家都很高兴， 可是我就不爽了。</p><p>每个人只需要保存自己的session id，而我需要保存所有人的session id ！  如果访问我的人多了， 就得由成千上万，甚至几十万个。</p><p>这对我来说是一个巨大的开销 ， 严重的限制了我的扩展能力， 比如说我用两个机器组成了一个集群， 小F通过机器A登录了系统，  那session id会保存在机器A上，  假设小F的下一次请求被转发到机器B怎么办？  机器B可没有小F的 session id啊。</p><p>有时候我会采用一点小伎俩： session sticky ， 就是让小F的请求一直粘连在机器A上， 但是这也不管用， 要是机器A挂掉了， 还得转到机器B去。</p><p>那我只好做session 的复制了， 把session id  在两个机器之间搬来搬去， 快累死了。</p><p><img src= "/img/loading.gif" data-lazy-src="http://mmbiz.qpic.cn/mmbiz_png/KyXfCrME6ULYaJ4jzPaPeibAKbBdpJ73vNJe66yhKRkVOxqS9gxftlwCuh8yicUcPPFaMMLv0oia9Xzf5IutmIPwQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>后来有个叫Memcached的给我支了招： 把session id 集中存储到一个地方， 所有的机器都来访问这个地方的数据， 这样一来，就不用复制了， 但是增加了单点失败的可能性， 要是那个负责session 的机器挂了，  所有人都得重新登录一遍， 估计得被人骂死。</p><p><img src= "/img/loading.gif" data-lazy-src="http://mmbiz.qpic.cn/mmbiz_png/KyXfCrME6ULYaJ4jzPaPeibAKbBdpJ73vwDyicwnvVayaKBpxXY4W5mUgQDwHD7Iwu3yY2OhV4qXG49oMbIgQP0A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>我也尝试把这个单点的机器也搞出集群，增加可靠性， 但不管如何， 这小小的session 对我来说是一个沉重的负担。</p><h4 id="4、时间换空间"><a href="#4、时间换空间" class="headerlink" title="4、时间换空间"></a>4、时间换空间</h4><p>这几天的晚上我一直在思考， 我为什么要保存这可恶的session呢， 只让每个客户端去保存该多好？</p><p>可是如果我不保存这些session id ,  我怎么验证客户端发给我的session id 的确是我生成的呢？  如果我不去验证，我都不知道他们是不是合法登录的用户， 那些不怀好意的家伙们就可以伪造session id , 为所欲为了。</p><p>嗯，对了，关键点就是验证 ！</p><p>比如说， 小F已经登录了系统， 我给他发一个令牌(token)， 里边包含了小F的 user id， 下一次小F 再次通过Http 请求访问我的时候， 把这个token 通过Http header 带过来不就可以了。</p><p>不过这和session id没有本质区别啊， 任何人都可以可以伪造，  所以我得想点儿办法， 让别人伪造不了。</p><p>那就对数据做一个签名吧， 比如说我用HMAC-SHA256 算法，加上一个只有我才知道的密钥，  对数据做一个签名， 把这个签名和数据一起作为token ，  由于密钥别人不知道， 就无法伪造token了。</p><p><img src= "/img/loading.gif" data-lazy-src="http://mmbiz.qpic.cn/mmbiz_png/KyXfCrME6ULYaJ4jzPaPeibAKbBdpJ73vGvJXhJuyPdxDdLibYVQpLATicy3FfQyGIvPe8y2iaGicbmWqVgEXWdOGqA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>这个token 我不保存，  当小F把这个token 给我发过来的时候，我再用同样的HMAC-SHA256 算法和同样的密钥，对数据再计算一次签名， 和token 中的签名做个比较， 如果相同， 我就知道小F已经登录过了，并且可以直接取到小F的user id ,  如果不相同， 数据部分肯定被人篡改过， 我就告诉发送者： 对不起，没有认证。</p><p><img src= "/img/loading.gif" data-lazy-src="http://mmbiz.qpic.cn/mmbiz_png/KyXfCrME6ULYaJ4jzPaPeibAKbBdpJ73vicfOmZHQhQ7e6Wjk7licKBMh38rPZfnEQxAibWXjY84P0icEVoFU51ibwiaQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>Token 中的数据是明文保存的（虽然我会用Base64做下编码， 但那不是加密）， 还是可以被别人看到的， 所以我不能在其中保存像密码这样的敏感信息。</p><p>当然， 如果一个人的token 被别人偷走了， 那我也没办法， 我也会认为小偷就是合法用户， 这其实和一个人的session id 被别人偷走是一样的。</p><p>这样一来， 我就不保存session id 了， 我只是生成token , 然后验证token ，  我用我的CPU计算时间获取了我的session 存储空间 ！</p><p>解除了session id这个负担，  可以说是无事一身轻， 我的机器集群现在可以轻松地做水平扩展， 用户访问量增大， 直接加机器就行。  这种无状态的感觉实在是太好了！</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>​         cookie 是一个非常具体的东西，指的就是浏览器里面能永久存储的一种数据，仅仅是浏览器实现的一种数据存储功能。 cookie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该 cookie发送给服务器。由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁 盘空间，所以每个域的cookie数量是有限的。</p><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>​    session 从字面上讲，就是会话。这个就类似于你和一个人交谈，你怎么知道当前和你交谈的是张三而不是李四呢？对方肯定有某种 特征（长相等）表明他就是张三。 session 也是类似的道理，服务器要知道当前发请求给自己的是谁。为了做这种区分，服务器就要给每个客户端分配不同的“身份标 识”，然后客户端每次向服务器发请求的时候，都带上这个“身份标识”，服务器就知道这个请求来自于谁了。至于客户端怎么保存这个 “身份标识”，可以有很多种方式，对于浏览器客户端，大家都默认采用 cookie 的方式。 服务器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。这种用户信息存储方式相对cookie来说 更安全，可是session有一个缺陷：如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失</p><h4 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h4><p>   基于Token的验证原理</p><p>基于Token的身份验证是无状态的，我们不将用户信息存在服务器或Session中。</p><p>这种概念解决了在服务端存储信息时的许多问题</p><p>　　NoSession意味着你的程序可以根据需要去增减机器，而不用去担心用户是否登录。</p><p>基于Token的身份验证的过程如下:</p><p>1.用户通过用户名和密码发送请求。</p><p>2.程序验证。</p><p>3.程序返回一个签名的token 给客户端。</p><p>4.客户端储存token,并且每次用于每次发送请求。</p><p>5.服务端验证token并返回数据。</p><p> 每一次请求都需要token。token应该在HTTP的头部发送从而保证了Http请求无状态。我们同样通过设置服务器属性Access-Control</p><p>Allow-Origin:* ，让服务器能接受到来自所有域的请求。需要主要的是，在ACAO头部标明(designating)*时，不得带有像HTTP认</p><p>证，客户端SSL证书和cookies的证书。</p><p> 实现思路:</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/12/01/ozayftpLJ4gNXin.png" alt="P_A_2_0K8_UC9_I3_IQYYI1.png"></p><p>1.用户登录校验，校验成功后就返回Token给客户端。</p><p>2.客户端收到数据后保存在客户端</p><p>3.客户端每次访问API是携带Token到服务器端。</p><p>4.服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码</p><p>当我们在程序中认证了信息并取得token之后，我们便能通过这个Token做许多的事情。</p><p>我们甚至能基于创建一个基于权限的token传给第三方应用程序，这些第三方程序能够获取到我们的数据（当然只有在我们允许的特</p><p>定的token）</p><p>Tokens的优势</p><p>无状态、可扩展</p><p>在客户端存储的Tokens是无状态的，并且能够被扩展。基于这种无状态和不存储Session信息，负载负载均衡器能够将用户信息从一</p><p>个服务传到其他服务器上。</p><p>如果我们将已验证的用户的信息保存在Session中，则每次请求都需要用户向已验证的服务器发送验证信息(称为Session亲和性)。用</p><p>户量大时，可能会造成</p><p> 一些拥堵。</p><p>但是不要着急。使用tokens之后这些问题都迎刃而解，因为tokens自己hold住了用户的验证信息。</p><p>安全性</p><p>请求中发送token而不再是发送cookie能够防止CSRF(跨站请求伪造)。即使在客户端使用cookie存储token，cookie也仅仅是一个存储</p><p>机制而不是用于认证。不将信息存储在Session中，让我们少了对session操作。 </p><p>token是有时效的，一段时间之后用户需要重新验证。我们也不一定需要等到token自动失效，token有撤回的操作，通过token</p><p>revocataion可以使一个特定的token或是一组有相同认证的token无效。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1、美好的旧时光&quot;&gt;&lt;a href=&quot;#1、美好的旧时光&quot; class=&quot;headerlink&quot; title=&quot;1、美好的旧时光&quot;&gt;&lt;/a&gt;1、美好的旧时光&lt;/h4&gt;&lt;p&gt;我经常怀念三十年前那美好的旧时光， 工作很轻松， 生活很悠闲。&lt;/p&gt;
&lt;p&gt;上班的时候偶尔</summary>
      
    
    
    
    <category term="JavaWeb" scheme="https://cddorz.github.io/categories/JavaWeb/"/>
    
    
    <category term="token" scheme="https://cddorz.github.io/tags/token/"/>
    
  </entry>
  
  <entry>
    <title>SCP</title>
    <link href="https://cddorz.github.io/2020/11/21/SCP/"/>
    <id>https://cddorz.github.io/2020/11/21/SCP/</id>
    <published>2020-11-21T03:50:33.000Z</published>
    <updated>2020-11-21T04:25:40.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回味无穷的SCP基金会系列"><a href="#回味无穷的SCP基金会系列" class="headerlink" title="回味无穷的SCP基金会系列"></a>回味无穷的SCP基金会系列</h1><p>记录一些很有趣的scp基金会文章。</p><p><a href="http://scp-wiki-cn.wikidot.com/">scp基金会中国分部官网</a></p><hr><p><strong>scp基金会：</strong></p><p><strong>基金会宣言:</strong></p><p><strong>人类到如今已经繁衍了近百万年，只有最近的4000年是有意义的。</strong></p><p><strong>所以，我们在将近25000年中在干嘛？我们躲在山洞中，围坐在小小的篝火边，畏惧那些我们不懂得的事物——那些关于太阳如何升起的解释，那些人头鸟身的怪物，那些有生命的石头。所以我们称他们为“神”和“恶魔”，并向他们祈求宽恕和祈祷拯救。</strong></p><p><strong>之后，他们的数量在减少，我们的数量在增加。当我们恐惧的事物越来越少，我们开始更理智的看待这个世界。然而，不能解释的事物并没有消失，好像宇宙故意要表现出荒谬与不可思议一样。</strong></p><p><strong>人类不能再生活在恐惧中。 没有东西能保护我们，我们必须保护我们自己。</strong></p><p><strong>当其他人在阳光下生活时，我们必须在阴影中和它们战斗，并防止它们暴露在大众眼中，这样其他人才能生活在一个理智的，普通的世界中。</strong></p><p><strong>我们控制，我们收容，我们保护。</strong></p><p><strong>— The Administrator</strong></p><p><strong><u>那么scp基金会真的存在吗？？</u></strong></p><hr><p><strong>项目编号：</strong>SCP-1733</p><p><strong>项目等级：</strong>Safe</p><p><strong>特殊收容措施：</strong>收录有SCP-1733的硬盘录像机被收容于Site-██的一间安全的视频档案室内。SCP-1733的录像回放被严格限定于仅供研究之用。研究人员需联系Geller博士以取得研究SCP-1733的权限。</p><p><strong>描述：</strong>SCP-1733是一份2010年10月26日在马萨诸塞州波士顿花园球馆，由波士顿凯尔特人队迎战迈亚密热火队的NBA2010-2012赛季开幕战的数字录像。特工们在监控社交网站的过程中注意到，一条由波士顿本地人████ █████撰写的FACEBOOK内容提到，在10月27号的比赛第三节过程中，在他录制的视频里涉及到凯尔特人队员雷·阿伦与热火队员克里斯·波什的一次技术性犯规根本就不曾发生过。当他发现这件事后，████ █████上传了相关的片段来反击那些嘲笑谩骂他的评论。潜伏在FACEBOOK监控团队中的基金会特工旋即删除了相关内容并获得了████ █████和所有参与评论用户的IP地址，对他们实施了定位和A級记忆消除。收录有SCP-1733的磁盘录像机被回收作研究用途。</p><p>自这份录像的异常性质被发现后，基金会的研究人员对其进行了大量的研究。尽管在最初的阶段，SCP-1733所包含的影像与本来放送的影响之间只有非常细微甚至可以忽略的不同，例如双方的每节总分或是犯规情况，但项目的内容确实是与它上次播放时有所区别。根据观察，录像中所拍摄到的个体保留有关于上一次播放的内容的记忆碎片，并且有部分个体已经觉察到了这些记忆碎片的存在。据推测，重复回放将会以记忆碎片的形式向这些实体传递目前尚无法估量其数量的信息，而这些信息越发使人群和球员们感到困惑和混乱，这个效应是积累性的，而且对球场内所有实体都有效。由于继承了前一次播放内容的记忆碎片，现场球评人麦克和汤米称他们对眼前看到的比赛似曾相识，由此可以看出这一效应正在发展中。然而，值得注意的是，没有任何一个实体直接与观察者说过话，他们或许就是这份数字录像中的居民。</p><p>被拍摄到的个体他们的行为与现实生活中别无二致，包括他们的球技、行为和举止。球迷们在各方面的举止也与一般人类没有区别，同时基金会对这些个体在现实世界中的调查并没有结果。从他们的行为和意图看来，被拍摄到的实体似乎都是真实存在的人，只是由于某种未知的原因，他们生活在这个数字介质当中。根据花园球馆的记录，2010年10月26日到场观看比赛的人数为██████。</p><p>在最初，SCP-1733的本质被认为是一个能对这场比赛的无限推演的集合，因为每次回放球员们都能根据记忆碎片的内容能预测对方球队的战术并作出相应的调整。在第34播放中，运动员和教练已经对对方球队的一举一动了如指掌，以至于在第一节进行到3分34秒前，双方比分都保持在0比0。由于记忆碎片所显现出的强度较弱，在早期的重复播放试验中，球员们、球迷和场地工作人员都将其理解为一种模糊的直觉，他们对比赛表现得越来越不紧张。</p><p>然而，当进行到第45次重复播放时，对他们处境的理解达到某个临界点后，球员们开始罢赛，并和球场中的其他人一起开始策划一个从球场中逃脱的计划。基于基金会研究员的结论，这些SCP-1733中的居民是被禁锢在这盘录像中，而且他们没有任何办法可以逃脱。所有通向球场外的门在据观测高达█████N的推力面前纹丝不动。球场内的人通过更衣室、球员设施或是豪华包厢离开的尝试也同样失败了。尝试在比赛开始前等待观众入场的时间离开的尝试也没有成功：进入到观众通道的个体根本就无法从那仅仅是绕了球场一圈的通道里逃出去。逃生的尝试显得越发让人绝望，制造土制炸彈、总动员的大破坏等尝试均以失败告终，人们开始分裂成三个相互对立的派系，而在第███次回放中，开始出现带有仪式性质的谋杀，球员们被迫剖腹自杀尝试去取悦那个禁锢他们的未知的存在（详见时间轴文件001）。然而，当再一次开始重新播放，所有个体都会恢复到比赛前无恙的状态。</p><p>研究人员在该DVR中储存的新片段并没有产生类似SCP-1733的效应，由此可以推断该DVR并不是SCP-1733异常属性的来源。基于观察到的SCP-1733的居民们那痛苦的状况，后续测试已被无限期暂停。</p><table><thead><tr><th>播放次数</th><th>显著变化</th></tr></thead><tbody><tr><td>002</td><td>记录到第一个与电视放送内容的不同。花园球馆的观众们对正在入场的热火队予以嘘声。迈亚密热火队前锋勒布朗·詹姆斯看着观众们皱了皱眉，轻轻的摇了摇头。</td></tr><tr><td>015</td><td>连续八次进攻后比分依旧是0比0。从比分板上的高清屏幕所显示的球迷表情可以看得出他们很郁闷。凯尔特人大前锋格伦·戴维斯在第四节完成了对勒布朗·詹姆斯的一次盖帽，并保住了球队的领先，这是他在之前的回放中都没能做到的。评述员对格伦·戴维斯在比赛中前后场皆优对比赛的贡献的评述取代了原来对三巨头在进攻时的快速运球的评述。一个关于前一次播放的新意识开始形成。</td></tr><tr><td>026</td><td>迈亚密热火队的首次胜利，比分最终锁定在112比85。人群变得相当激动，开始粗话连篇并向凯尔特人队投掷杂物。评述员汤姆·海因索恩说他理解球迷们沮丧的心情，并批评凯尔特人队的教练团队在破解了迈亚密热火队的进攻路数后显得过于自大。同时他也指出，这场比赛是迈亚密三巨头的初阵，很难想象他们的为何能在一场比赛里就将这样一个并不熟悉的进攻组合玩得得心应手。</td></tr><tr><td>027</td><td>评述员麦克和汤米在热火队入场的时候感觉到这一场景似乎似曾相识。在这样一场对于凯尔特人队来说相当重要的比赛中，观众们显得很沉寂。凯尔特人队获得了胜利，汤姆·海因索恩评论“凯尔特人队要想赢回他们球迷的心还有很长的路要走”。当被记者问到时，他说这支队伍需要一雪前耻，而至于其他东西，现阶段还很难说。</td></tr><tr><td>044</td><td>球员们表现出迷失和困惑。比赛并没有进行。录像大部分的时间里队医们都在为那些坚称自己头天晚上做梦打过很多次开幕赛的队员们做精神鉴定。当球队工作人员将这个消息告诉麦克和汤米时，他们也表示自己有类似的感觉。观众们似乎也有同样的感觉。当记者们开始就这些梦的本质进行采访时，录像结束了。</td></tr><tr><td>045</td><td>球员们罢赛。球员们、摄影师、工作人员还有观众们聚集到球场上开始分析当前的情况。所有人都坚信他们是在重复地经历同一场比赛。球场的门在尝试后被证实无法开启。当人们开始准备各种土制武器去撬门的时候录像结束了。这是最后一次观察到镜头是被摄制组操作着的，之后所有的回放都是以一个固定的演播摄像机为视点。</td></tr><tr><td>051</td><td>逃出这栋建筑物的尝试全部以失败告终。所有通向球场外以及相邻区域的门都封死了。在看台318区发生了暴力事件，一群喝醉了的男大学生和另外两个较老的男人发生了冲突，其中一人被打成了脑震荡瘫倒在地，另一个则不省人事。由于演播摄像机无法清楚收到来自球场对面的声音，推测这起事件是发生在并没有打算协助逃生的男性之间。</td></tr><tr><td>052</td><td>之前被殴打致脑震荡的男子在重新开始回放之后恢复到无恙的状态。两名在之前的回放中被殴打的男子伏击了殴打他们的人，并在录像进行到34分12秒的时候用棍棒打死了其中一个人。</td></tr><tr><td>055</td><td>认知效应已经发展到这群人能记得一周内发生过的事，以及他们在这个建筑外的朋友和家人。试图联系外界以获得帮助的尝试失败了。</td></tr><tr><td>065</td><td>人们无法逃离这个地方。人群开始分裂成数个派系：球员们、教练员以及可能已将自己锁在镜头之外的球员设施里的球队工作人员。体弱者和家长们带着他们的孩子聚集到了看台的东北角选择等待回放再次重新开始，他们用凯尔特人队的队旗围起了看台的320区，将其标示为自己的领土。██个个体，以下简称为“Faithkeepers”，他们认为花园球馆是对于泛滥的物欲主义的一次惩罚。在连续四次回放中，他们到处收集手机、车钥匙、手袋、钱包等他们认为可以当做“祭品”的东西，并在球场中心焚烧。这一批人的成员主要来自波士顿教友会以及[数据删除]。然而，依然有为数不少，接近████个成年人依然在积极地策划着逃生的方案。</td></tr><tr><td>073</td><td>在前一次回放中，三个人被固定在出口大门上引爆的土制炸彈所伤，而门没有显现出任何可见的伤痕。在这一事件后，“Faithkeepers”的数量明显增多</td></tr><tr><td>095</td><td>暴力和性的享乐主义很大程度地让传教者们（指Faithkeepers）的努力化成了无用功。在320成员的督促下，在八号包厢里开狂欢派对的人才挂起了几块布来稍作遮掩。</td></tr><tr><td>112</td><td>情况越来越糟，在第112次回放开始的十分钟里，已有██人从看台上跳下自杀。</td></tr><tr><td>███</td><td>Faithkeepers突袭了球员更衣室，并把保罗·皮尔斯和勒布朗·詹姆斯揪了出来。两位球员在仪式上被作为祭品献祭了，他们的尸体随后被展示在该区域的大屏幕上<a href="javascript:;">1</a>。两位球员的死似乎并未对该录像带造成影响。</td></tr><tr><td>███</td><td>传教者们开始要求献祭儿童。大人们在Faithkeepers与320组之间筑起人墙。</td></tr><tr><td>███</td><td>首次记录到球场灯光偏深红色。[数据删除]。</td></tr></tbody></table><p>scp-1733补充：</p><h1 id="花园球馆今天没有比赛"><a href="#花园球馆今天没有比赛" class="headerlink" title="花园球馆今天没有比赛"></a>花园球馆今天没有比赛</h1><p>最新的研究项目完成了。签订保密协议后，Caya博士被准许放假。她今天要和丈夫、女儿到花园球场看开季赛。他们落座以后，静待比赛开始。这时她包里的康德计数器响了起来。她口袋里的手机几乎同时响了。<br>现实扭曲者袭击，不要泄露机密。我们会来救你。<br>她想起接受过的训练。可是她知道没有用。</p><p><a href="https://www.bilibili.com/read/cv2534467?from=search">又一次回放。</a><br>为数不多的大人们艰难地守卫着320区。享乐主义者们又一次冲破防线，进来掠走了好几个小女孩，还有一个男孩。Caya看见丈夫抡起手提箱，砸翻了一个暴徒，又立即被如雨的棍棒打倒在地。有女人声嘶力竭地哭喊着。<br>Caya发现女儿不见了。<br>她脑海里充斥着在之前的轮回中，女儿无数次被暴徒以不同方式蹂躏的场景。大部分她没看见，那时候她要么头破血流，倒在地上，已处于“死亡”当中，只听得到声音，要么正被迫在别的地方接受着暴徒的侵犯，丝毫无法反抗。还有些时候她看到了，于是她记住了。那是第几次回放？享乐主义者和教徒破天荒地联手，杀光了320区的所有男人。然后……那一次的轮回好像格外久。</p><p>录像带重置了。<br>所有人都再次坐在看台上，球员依旧还未入场。场面在一瞬间内骚动起来——她下意识地转过身躯，想搂住坐在左边的女儿——这时她头部受到了重击，她趴倒在前排座位上。果然。她知道她右后座的那个年轻人经常在轮回刚开始时猛击她的头部，然后夺走她的女儿和枪。尽管这事现在已经不常发生了——至少有六十次轮回里他没有这么做了。</p><p>Caya勉强支撑起身体，回过身去。<br>她看见，丈夫丢下了一直作为武器的手提箱，正在撕扯女儿的衣服。“就这一次……反正也会回放的，不是吗？”那个是她丈夫的人说。女儿又哭又叫。Caya寄希望于后排的那年轻人，希望他能打倒她丈夫，可那年轻人早已不见踪影。<br>Caya身躯一软，眼前发黑。她支撑着身体，终于栽倒在过道上，险些滚了下去。她扒住一个座椅。有人拿走了她的手枪，顺便摸了一下她的屁股——这把枪的位置早就在一遍遍回放里被所有人知道了。她浑身无力，垂下头，望着花园球馆。</p><p>球场那边，勒布朗·詹姆斯目光空洞。他手持铁片，再一次剖开了自己的腹部。动作熟练。鲜红的内脏流了出来。他旁边跪着保罗·皮尔斯。</p><p>另一边的观众区，有十几个人正翻过玻璃护栏，纵身跃下看台。后跳的人坠落在尸体或活人身上，因而没有马上死去。还能活动的人便挣扎着寻找最近的铁器，只求一死，然后在什么都感知不到的黑暗中等待下一次轮回。</p><p>球场中央，享乐主义者们再次迅速聚集起来了。他们就在球场正中，脱下来的衣物铺满了地板。呻吟声和狂叫声，间或有哭喊声。</p><p>是的。<br>花园球馆里，肉体碰撞声此起彼伏。有的造成死亡，有的带来快感。</p><p>地狱盛景。活现人间。<br>那现实扭曲者真是个天才。Caya想。</p><p>在Area-CN-07工作的时候，她听同事说过几百种现实扭曲者审问犯人的方法。而只是封住球馆，将一万个人关在一起，其他什么也不做，这种方法她闻所未闻。<br>但毫无疑问。这是最惨绝的方法。</p><p>她艰难地转过头，所见之物险些击碎她的心脏。她发现女儿已经不再反抗。她也在呻吟着，脸上扬起迷乱的笑颜，娇小的身躯配合着节奏律动着。<br>像无数次曾发生过的那样，女儿闭着眼。在无数次轮回中，女儿已像个成人了。对她来说，人类女性能经历的所有悲惨，已没有什么是她十四岁的内心所不熟悉的了。她早已不是她的女儿了。</p><p>Caya闭上眼睛。她想张嘴把所有她知道的都说出来。她知道一旦她这么做，这一切马上会结束。她至少会死。</p><p>说吧。<br>丈夫模糊地呼唤着某个人的名字。<br>说吧。<br>女儿的叫声听起来像远方的山音。<br>说吧。<br>因为花园球场早已没有人在祈祷。<br>说吧，<br>CAYA。</p><p>CAYA。</p><p>说啊，<br>CAYA。</p><p>Caya笑了。<br>血液从唇角流进嘴中。尝起来竟然清甜。<br>她知道她不能。因为他们已不配死。</p><p>正当她想把头狠狠撞在台阶上，然后进入死亡的时候，Caya看见一个在无数次轮回中，她竟完全不记得的面孔。<br>那人面色阴沉，坐在她的位置上，然后掏出一包骆驼牌香烟，取出一支，那烟立即燃烧。他抽了一口，抬眼扫视花园球场。然后他定定地看着她。神情中似乎有一丝怜悯。<br>还是不说吗？</p><p>Caya凄惨地一笑。<br>玩够了吗？还是他们终于来了？</p><p>那男人站起来。吐出烟。</p><p>一声巨响。曾被引爆过无数次的土制炸药再次爆炸了，飞起鲜艳的烟云。<br>Caya望向入口。<br>花园球馆的大门，轰然洞开。</p><p>一切都消失了。<br>所有人都坐在座位上，比赛还没有开始。<br>烟云还未完全散去，Caya看见身着黑色制服，全副武装的基金会人员，带着现实稳定设备，成严正队列冲了进来。所有观众都骚动起来，互相询问发生了什么。Caya感到女儿的小手拉住了她的衣角。</p><blockquote><p>波士顿晚报 2010年10月26日<br>今日，花园球馆遭遇袭击，土制炸药在大门处被引爆，球馆设施损毁，所幸无人受伤。原定今日举行的波士顿凯尔特人队迎战迈亚密热火队的开幕战将延期举行。</p></blockquote><p>Caya抬头，摆着披萨的木制餐桌旁坐着丈夫和女儿，丈夫讲了一个笑话，女儿捂嘴轻轻笑着。<br>Caya没笑。她放下报纸，站起身，端着咖啡回到了卧室。</p><p>他们根本没去过花园球馆。<br>她试着说服自己。<br>不。<br>她记得。<br>她记得他们家从没订过什么《波士顿晚报》。</p><p>她记得他们去过，他们所有人。<br>她记得他们是怎么从面对绝望走向制造绝望的。<br>她放下咖啡，打开抽屉。里面躺着一把格洛克。</p><p>她记得每一张脸的每一个不同表情。<br>她记得他们的语调，记得他们的姿态。<br>她草草写下遗书。然后签名。</p><p>她记得他们的所有癖好。有些可能永远不会再被发现。<br>她记得一切。一切已经发生，也不会再发生的东西。<br>她含住枪，枪管冰凉。</p><p>她记得他们是人。是她能遇见的，所有年龄、职业、背景，所有一样的人。<br>她记得她也是人。</p><p>砰。</p><p>Caya死死盯着桌上凭空多出来的基金会之星勋章。<br>就在刚刚，枪口里蹦出了一颗深红色的彩虹糖，然后枪管从中间弯曲，像塑料一样折成两段。复进簧弹在她脸上。</p><p>她好像闻到一股烟味。</p><p>耳边有人说，<br>“别急，</p><p>还没完呢。”</p><h3 id="评价："><a href="#评价：" class="headerlink" title="评价："></a><strong><em>评价</em></strong>：</h3><p>​    这一篇scp系列文章真的很令人回味，特别是当你认为已经逃出去可以松一口气之后，正在为Caya的自杀感到痛苦以及对人性的厌恶的时候，一声“别急，还没完呢”，又让我不禁发出一声“卧槽”，反转的结局让我回味无穷，同时也为Caya的命运感到担忧。</p><p>   但回到这篇scp想表达的本质上来：如果真的发生了一万人被困在一个封闭空间，且会无限循环，永远逃不出去，那么道德、人性会变成什么样呢？=-=，光想想就令人胆寒，这其实就是人本性的恶是无法被磨灭的，虽然现在社会的文明，那是因为有法律和道德的约束，真到没有约束的时候，能像Caya一样还有善的人又能有多少呢？扪心自问，我要是在那种情况下，也会堕落。**<u>人的恶，无法逆转，无法改变！</u>**</p><p>​    如果那一万人中有你，可以想想你会做什么……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;回味无穷的SCP基金会系列&quot;&gt;&lt;a href=&quot;#回味无穷的SCP基金会系列&quot; class=&quot;headerlink&quot; title=&quot;回味无穷的SCP基金会系列&quot;&gt;&lt;/a&gt;回味无穷的SCP基金会系列&lt;/h1&gt;&lt;p&gt;记录一些很有趣的scp基金会文章。&lt;/p&gt;
&lt;p&gt;&lt;</summary>
      
    
    
    
    <category term="scp" scheme="https://cddorz.github.io/categories/scp/"/>
    
    
    <category term="狂想" scheme="https://cddorz.github.io/tags/%E7%8B%82%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>订单自动过期实现方案</title>
    <link href="https://cddorz.github.io/2020/11/20/%E8%AE%A2%E5%8D%95%E8%87%AA%E5%8A%A8%E8%BF%87%E6%9C%9F%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"/>
    <id>https://cddorz.github.io/2020/11/20/%E8%AE%A2%E5%8D%95%E8%87%AA%E5%8A%A8%E8%BF%87%E6%9C%9F%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/</id>
    <published>2020-11-20T08:59:53.000Z</published>
    <updated>2020-11-20T11:46:16.126Z</updated>
    
    <content type="html"><![CDATA[<h2 id="订单自动过期时实现方案"><a href="#订单自动过期时实现方案" class="headerlink" title="订单自动过期时实现方案"></a>订单自动过期时实现方案</h2><h4 id="具体是因为要做的项目需要做一个过滤过期任务的方案：一开始考虑做定时任务，但发现定时任务并不能完成要求，因为定时任务只能是静态某一时间进行遍历数据库进行修改操作，一般用于清楚数据库缓存等，所以考虑做延时队列。"><a href="#具体是因为要做的项目需要做一个过滤过期任务的方案：一开始考虑做定时任务，但发现定时任务并不能完成要求，因为定时任务只能是静态某一时间进行遍历数据库进行修改操作，一般用于清楚数据库缓存等，所以考虑做延时队列。" class="headerlink" title="具体是因为要做的项目需要做一个过滤过期任务的方案：一开始考虑做定时任务，但发现定时任务并不能完成要求，因为定时任务只能是静态某一时间进行遍历数据库进行修改操作，一般用于清楚数据库缓存等，所以考虑做延时队列。"></a>具体是因为要做的项目需要做一个过滤过期任务的方案：一开始考虑做定时任务，但发现定时任务并不能完成要求，因为定时任务只能是静态某一时间进行遍历数据库进行修改操作，一般用于清楚数据库缓存等，所以考虑做<em>延时队列</em>。</h4><h4 id="1-延时队列"><a href="#1-延时队列" class="headerlink" title="1. 延时队列"></a>1. 延时队列</h4><p>基于JDK的实现方法，将未支付的订单放到一个有序的队列中，程序会自动依次取出过期的订单。<br>如果当前没有过期的订单，就会阻塞，直至有过期的订单。由于每次只处理过期的订单，并且处理的时间也很精准，不存在定时调度方案的那两个弊端。<br>实现：<br>1.首先创建一个订单类<code>OrderDelayDto</code>需要实现<code>Delayed</code>接口。然后重写<code>getDelay()</code>方法和<code>compareTo()</code>方法，只加了订单编号和过期时间两个属性。<br>这两个方法很重要，<br><code>getDelay()</code>方法实现过期的策略，比如，订单的过期时间等于当前时间就是过期，返回负数就代表需要处理。否则不处理。<br><code>compareTo()</code>方法实现订单在队列中的排序规则，这样即使后面加入的订单，也能加入到排序中，我这里写的规则是按照过期时间排序，最先过期的排到最前面，这一点很重要，因为排在最前面的如果没有被处理，就会进入阻塞状态，后面的不会被处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qingyuan.pigeon;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.jetbrains.annotations.NotNull;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Delayed;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-11-20 16:14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderDelayDto</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String taskId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过期时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Date taskEndTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断过期条件：过期时间大于等于当前时间就算过期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * getDelay: 返回与此对象关联的剩余延迟，以给定的时间单位表示。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(<span class="meta">@NotNull</span> TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unit.convert(<span class="keyword">this</span>.taskEndTime.getTime() - System.currentTimeMillis(), TimeUnit.NANOSECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单加入队列的排序规则：最先过期的排在前面</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * compareTo: 将此对象与order的指定对象进行比较。当此对象小于、等于或大于指定对象时，返回负整数、零或正整数。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(<span class="meta">@NotNull</span> Delayed o)</span> </span>&#123;</span><br><span class="line">        OrderDelayDto orderDelayDto  = (OrderDelayDto) o;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Date.getTime(long):</span></span><br><span class="line"><span class="comment">         * 返回此&#123;<span class="doctag">@code</span> Date&#125;对象表示的自1970年1月1日00:00:00 GMT*以来的毫秒数。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">long</span> time =orderDelayDto.getTaskEndTime().getTime();</span><br><span class="line">        <span class="keyword">long</span> time1 = <span class="keyword">this</span>.taskEndTime.getTime();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果 time == time1 返回0</span></span><br><span class="line"><span class="comment">         * 如果 time &lt; time1 返回1</span></span><br><span class="line"><span class="comment">         * 如果 time &gt; time1 返回-1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span>  time == time1 ? <span class="number">0</span> : time &lt; time1 ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>convert : 将给定单位中的给定持续时间转换为该单位。</li><li>System.currentTimeMillis() : 返回当前时间（毫秒）。</li><li>NANOSECONDS ：表示千分之一微秒的时间单位。</li></ul><p>写个test 方法测试一下，创建两个订单o1和o2，放入到延时队列中，然后while()方法不断的去取。<br>在此方法内通过队列的<code>take()</code>方法获得已过期的订单，然后做出相应的处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">teat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DelayQueue&lt;OrderDelayDto&gt; queue = <span class="keyword">new</span> DelayQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第一个订单，过期时间设置为一分钟后</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        OrderDelayDto o1 = <span class="keyword">new</span> OrderDelayDto();</span><br><span class="line">        o1.setTaskId(<span class="string">&quot;1001&quot;</span>);</span><br><span class="line">        Calendar calendar = Calendar.getInstance();</span><br><span class="line">        calendar.add(Calendar.MINUTE,<span class="number">1</span>);</span><br><span class="line">        o1.setTaskEndTime(calendar.getTime());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第二个订单，过期时间设置为现在</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        OrderDelayDto o2 = <span class="keyword">new</span> OrderDelayDto();</span><br><span class="line">        o2.setTaskId(<span class="string">&quot;1002&quot;</span>);</span><br><span class="line">        o2.setTaskEndTime(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 往队列中放入数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        queue.offer(o1);</span><br><span class="line">        queue.offer(o2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 延时队列</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                OrderDelayDto take = queue.take();</span><br><span class="line">                System.out.println(<span class="string">&quot;订单编号：&quot;</span> + take.getTaskId() + <span class="string">&quot;过期时间:&quot;</span> + take.getTaskEndTime());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试结果</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/11/20/jdyx6ktwzTvEcf8.png" alt="QQ图片20201120172903.png"></p><p><strong>即便往队列中放入数据时，先放入o1，先取出的依旧是o2，以此验证队列的排序规则是谁最先过期，无关放入队列的顺序！</strong></p><p>2.然而通常情况下，我们会使用多线程去取延时队列中的数据，这样即使线程启动之后也能动态的向队列中添加订单。<br>创建一个线程类<code>OrderCheckScheduler</code>实现<code>Runnable</code>接口，<br>添加一个延时队列属性，重写<code>run()</code>方法，在此方法内通过队列的<code>take()</code>方法获得已过期的订单，然后做出相应的处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.DelayQueue;</span><br><span class="line">&#x2F;**</span><br><span class="line">* @author mashu</span><br><span class="line">* Date 2020&#x2F;5&#x2F;17 14:27</span><br><span class="line">*&#x2F;</span><br><span class="line">public class OrderCheckScheduler implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 延时队列</span><br><span class="line">  private DelayQueue&lt;OrderDelayDto&gt; queue;</span><br><span class="line"></span><br><span class="line">  public OrderCheckScheduler(DelayQueue&lt;OrderDelayDto&gt; queue) &#123;</span><br><span class="line">      this.queue &#x3D; queue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">      while (true) &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">              OrderDelayDto take &#x3D; queue.take();</span><br><span class="line">              System.out.println(&quot;订单编号：&quot; + take.getOrderCode() + &quot; 过期时间：&quot; + take.getExpirationTime());</span><br><span class="line">          &#125; catch (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">1234567891011121314151617181920212223242526</span><br></pre></td></tr></table></figure><p>好了，写个方法测试一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建延时队列</span><br><span class="line">    DelayQueue&lt;OrderDelayDto&gt; queue &#x3D; new DelayQueue&lt;&gt;();</span><br><span class="line">    OrderDelayDto o1 &#x3D; new OrderDelayDto();</span><br><span class="line">    &#x2F;&#x2F;第一个订单，过期时间设置为一分钟后</span><br><span class="line">    o1.setOrderCode(&quot;1001&quot;);</span><br><span class="line">    Calendar calendar &#x3D; Calendar.getInstance();</span><br><span class="line">    calendar.add(Calendar.MINUTE, 1);</span><br><span class="line">    o1.setExpirationTime(calendar.getTime());</span><br><span class="line">    OrderDelayDto o2 &#x3D; new OrderDelayDto();</span><br><span class="line">    &#x2F;&#x2F;第二个订单，过期时间设置为现在</span><br><span class="line">    o2.setOrderCode(&quot;1002&quot;);</span><br><span class="line">    o2.setExpirationTime(new Date());</span><br><span class="line">    &#x2F;&#x2F;运行线程</span><br><span class="line">    ExecutorService exec &#x3D; Executors.newFixedThreadPool(1);</span><br><span class="line">    exec.execute(new OrderCheckScheduler(queue));</span><br><span class="line">    &#x2F;&#x2F;往队列中放入数据</span><br><span class="line">    queue.offer(o1);</span><br><span class="line">    queue.offer(o2);</span><br><span class="line">    exec.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;订单自动过期时实现方案&quot;&gt;&lt;a href=&quot;#订单自动过期时实现方案&quot; class=&quot;headerlink&quot; title=&quot;订单自动过期时实现方案&quot;&gt;&lt;/a&gt;订单自动过期时实现方案&lt;/h2&gt;&lt;h4 id=&quot;具体是因为要做的项目需要做一个过滤过期任务的方案：一开始考</summary>
      
    
    
    
    <category term="项目具体问题" scheme="https://cddorz.github.io/categories/%E9%A1%B9%E7%9B%AE%E5%85%B7%E4%BD%93%E9%97%AE%E9%A2%98/"/>
    
    
    <category term="延时队列" scheme="https://cddorz.github.io/tags/%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>骚话合集</title>
    <link href="https://cddorz.github.io/2020/11/19/%E9%AA%9A%E8%AF%9D%E5%90%88%E9%9B%86/"/>
    <id>https://cddorz.github.io/2020/11/19/%E9%AA%9A%E8%AF%9D%E5%90%88%E9%9B%86/</id>
    <published>2020-11-19T12:58:58.000Z</published>
    <updated>2021-01-12T05:08:14.837Z</updated>
    
    <content type="html"><![CDATA[<h3 id="骚话合集（-）"><a href="#骚话合集（-）" class="headerlink" title="骚话合集（=-=）"></a>骚话合集（=-=）</h3><p>作者：言予<br>链接：<a href="https://www.zhihu.com/question/347077309/answer/1414532301">https://www.zhihu.com/question/347077309/answer/1414532301</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>1.人是不能太闲的，闲久了，努力一下就以为是拼命。</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/50/v2-5316b8eb3c993d95435e19e7ab3b2b7f_hd.jpg?source=1940ef5c" alt="img"></p><p>2.我或许败北，或许迷失自己，或许哪里也抵达不了，或许我已失去一切，任凭怎么挣扎也只能徒呼奈何，或许我只是徒然掬一把废墟灰烬，唯我一人蒙在鼓里，或许这里没有任何人把赌注下在我身上。无所谓。有一点是明确的：至少我有值得等待有值得寻求的东西。                                                         ——村上春树 《奇鸟行状录》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/50/v2-6dbfecf502abedec642fdd7a8f55844f_hd.jpg?source=1940ef5c" alt="img"></p><p>3.沉不下心看书，浮跋和焦虑，都是因为年纪渐长，不信正道而太重功利导致的。 真正坚持到最后的人靠的不是激情，而是恰到好处的喜欢和投入。</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic4.zhimg.com/50/v2-8c9022dddadb9afe59ada697424368f9_hd.jpg?source=1940ef5c" alt="img"></p><p>4.对未来的真正慷慨，是把一切都献给现在。                                                                 ——阿尔贝・加缪 《反抗者》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic2.zhimg.com/50/v2-b0f52fb3c451d6c087adee09a25f39de_hd.jpg?source=1940ef5c" alt="img"></p><p>5.我们一路奋战，不是为了改变世界，而是为了不让世界改变我们。                             ——《熔炉》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic4.zhimg.com/50/v2-fa0c650b3ab8df6e9b66020fdb7d0b7c_hd.jpg?source=1940ef5c" alt="img"></p><p>6.闭上眼睛，好好回想之前的努力，自信会喷涌而出。                                                    ——东野圭吾 《放学后》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic4.zhimg.com/50/v2-d9d147e508df2fcfba8e1df4ee61c854_hd.jpg?source=1940ef5c" alt="img"></p><p>7.人的一生，未必都波澜壮阔、荡气回肠，左右我们如何活着的往往是那些每天都在上演、都在谢幕的生命场景。在阳光下细碎如微尘般翻飞跳跃的，恰似我们的一生，只是，有的人拼尽全身力气把微尘舞出了光芒。                                                                 ——《网易云热评》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/50/v2-753111cbfa792fcc85273d5783e03881_hd.jpg?source=1940ef5c" alt="img"></p><p>8.每个人都会有缺陷，就像被上帝咬过的苹果，有的人缺陷比较大，正是因为上帝特别喜欢他的芬芳。                                            —— 托尔斯泰 《战争与和平》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/50/v2-96dcfe896609b091f0f0c940558d2e19_hd.jpg?source=1940ef5c" alt="img"></p><p>9.所谓努力，就是主动而有目的的活动。 ——村上春树</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-2f0e4f0431449c948fda21d490e51800_720w.jpg?source=1940ef5c" alt="img"></p><p>10.如果你还在乎别人说你什么，那你一定是也在潜意识里认同别人说你的东西。只有你真正强大了，才可以不惧怕任何言论。 ——张皓宸 《你是最好的自己》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-7d0e134e06d976eb7a43ff09e9cac31f_720w.jpg?source=1940ef5c" alt="img"></p><p>11.人生在世，委屈、烦难、辛酸，都是难免，重要的是你得翻过去，因为推开暗壁，对面总还有蓝天。                                         ——伊北</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-e0881cea56fbe5219d137e16b572a08b_720w.jpg?source=1940ef5c" alt="img"></p><p>12.生活在阴沟里，依然有仰望星空的权利。                                                                 ——王尔德</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-ae6664f065aba3903a677178be2efb10_720w.jpg?source=1940ef5c" alt="img"></p><p>13.失败的人只有一种，就是在抵达成功之前放弃的人。                                                 ——盖聂 《秦时明月》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-b6f787655b1ca58f9924d7c608cff0a1_720w.jpg?source=1940ef5c" alt="img"></p><p>14.懒惰是很奇怪的东西，它使你以为那是安逸，是休息，是福气；但实际上它所给你的是无聊，是倦怠，是消沉；它剥夺你对前途的希望，割断你和别人之间的友情，使你心胸日渐狭窄，对人生也越来越怀疑 。  ——罗兰 《忙碌与进取》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-d7a8c9c82ce768295b274c305df6adf2_720w.jpg?source=1940ef5c" alt="img"></p><p>15.鹏北海，凤朝阳。又携书剑路茫茫。  —— 辛弃疾</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic3.zhimg.com/80/v2-f6ebc221bd12003692799fb5accd3396_720w.jpg?source=1940ef5c" alt="img"></p><p>16.生活总是让我们遍体鳞伤，可是后来，那些受伤的地方一定会变成我们最强壮的地方。                                                                 ——海明威 《永别了武器》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-2556be31f1c2d598da4f4d6cf02d897d_720w.jpg?source=1940ef5c" alt="img"></p><p>17.要有最朴素的生活，与最遥远的梦想，即使明日天寒地冻，路远马亡。                ——七堇年 《被窝是青春的坟墓》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-6e87a629e01599f0d040f876178b30cf_720w.jpg?source=1940ef5c" alt="img"></p><p>18.纵使黑夜吞噬了一切，太阳还可以重新回来。                                                             ——汪国真</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-ac0dd6046f3c5dd07ad22080f4ad13f8_720w.jpg?source=1940ef5c" alt="img"></p><p>19.世界上什么事都可能发生，就是不会发生不劳而获的事情。                                    ——洛克菲勒 《洛克菲勒给儿子的38封信》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-09ce71a99769d992eb447180bce1a212_720w.jpg?source=1940ef5c" alt="img"></p><p>20.有些事情不是看到希望才去坚持，而是坚持了才会看到希望。                                 ——蜘蛛 《十宗罪》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-fe1508fa6730a13a7387333a2733348e_720w.jpg?source=1940ef5c" alt="img"></p><p>21.看什么励志的书籍？你本来就要活的很励志！</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-5316994cc1beda5eaf5b402b82b7e0fb_720w.jpg?source=1940ef5c" alt="img"></p><p>22.努力会说谎，但努力不会白费。          ——羽生结弦</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-aba3768fd9d2ba2b3a0d778322c0f01f_720w.jpg?source=1940ef5c" alt="img"></p><p>23.越是低谷的时候，越能看出一个人的本质。最差的结果无非是失败，有人等着失败，有人骂着失败，有人尽了力仍然失败。在这样的环境里，心态就是每个人自身的光，你颓唐就是颓唐，你顽强就是顽强。——刘同</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-74936c7dce5718371e79cc08d6d8c4d8_720w.jpg?source=1940ef5c" alt="img"></p><p>24.生活原本沉闷，但跑起来就有风。</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-6b96c9225e64feef2831ddd767f1b148_720w.jpg?source=1940ef5c" alt="img"></p><p>25.不要总以为鹤立鸡群，有本事就离开那群鸡。</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-e09f5a88d9a27df4cbd0aa106cd75b95_720w.jpg?source=1940ef5c" alt="img"></p><p>26.及时当勉励，岁月不待人。                   ——陶渊明 《杂诗》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-d992c1c652c347f0bc94bb26a3eb16a8_720w.jpg?source=1940ef5c" alt="img"></p><p>27.不要停止奔跑，不要回顾来路，来路无可眷恋，值得期待的只有前方。                 ——《马男波杰克》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-a43dcce4162111d62ea42f0b6b202b9c_720w.jpg?source=1940ef5c" alt="img"></p><p>28.人生有时难免会陷入困境，但人的高贵在于，困境中依然保持操守，决不能放纵自我，任错误的欲望泛滥。                            ——鲁迅 《朝花夕拾》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-3cb325ff608201199974e2293eaab709_720w.jpg?source=1940ef5c" alt="img"></p><p>29.有些路很远，走下去会很累，可是，不走，又会后悔。                                            ——安娜・昆德兰 《不曾走过，怎会懂得》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-5a43775763fe83a69b1bdd9b5200bb8c_720w.jpg?source=1940ef5c" alt="img"></p><p>30.你只有不停地奔跑，才能留在原地。   ——刘易斯・卡罗尔 《爱丽丝漫游仙境》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-369e9e3892c0566122983c80e62143ad_720w.jpg?source=1940ef5c" alt="img"></p><p>31.没有谁的生活会一直完美，但无论什么时候都要眼看前方，满怀希望就会所向披靡。                                                                 —— 巫哲 《撒野》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-c8c8bbec89f76936d2bbc29282d9b132_720w.jpg?source=1940ef5c" alt="img"></p><p>32.优于别人，并不高贵，真正的高贵应该是优于过去的自己。                                    ——海明威</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-32f905d1b65f5c1ad915b8a71e8f0053_720w.jpg?source=1940ef5c" alt="img"></p><p>33.怕什么真理无穷，进一寸有一寸的欢喜。                                                                ——胡适</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-69f08346a90dae2076ec3728334451fe_720w.jpg?source=1940ef5c" alt="img"></p><p>34.愿你所得过少时，不会终日愤愤；愿你所得过多时，不必终日惶恐。                    ——东野圭吾 《解忧杂货店》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-c8808b3a917eb913aaefb5849aa77e92_720w.jpg?source=1940ef5c" alt="img"></p><p>35.很多事情就像是旅行一样，当你决定要出发的时候，最困难的那部分其实就已经完成了。                                                             ——卢思浩 《你要去相信，没有到不了的明天》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-f2461a01b84dcafec22647da7c178db0_720w.jpg?source=1940ef5c" alt="img"></p><p>36.也许你感觉自己的努力总是徒劳无功，但不必怀疑，你每天都离顶点更进一步。今天的你离顶点还遥遥无期。但你通过今天的努力，积蓄了明天勇攀高峰的力量。        ——尼采</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-d5025cd62977bba64002e7d7cbc3c019_720w.jpg?source=1940ef5c" alt="img"></p><p>37.只有计划却没有行动的人，不过是一个伪理想主义者，只能眼睁睁地看着人家风光。                                                                 ——辰格 《戒了吧！拖延症》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-97effa387d705480b99d4c05e86f82d7_720w.jpg?source=1940ef5c" alt="img"></p><p>38.凡是不能杀死你的，最终都会让你更强。                                                                 ——尼采</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-390618b0eec72495309a96b84782e52c_720w.jpg?source=1940ef5c" alt="img"></p><p>39.Be yourself; everyone else is already taken.  做你自己，因为别人都有人做了。 ——王尔德</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-647afdecc251a50c3ee0ad6db40861c9_720w.jpg?source=1940ef5c" alt="img"></p><p>40.生活是苦难的，我又划着我的断桨出发了。                                                                ——博尔赫斯</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-ac9759420ceec15a05fdc43c37ed4de4_720w.jpg?source=1940ef5c" alt="img"></p><p>41.很多人的失落，是违背了自己少年时的立志。自认为成熟、自认为练达、自认为精明，从前多幼稚，总算看透了、想穿了。于是，我们就此变成自己年少时最憎恶的那种人。                                                                  ——木心</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-ca6b86fe6486926b714d253872d55c4c_720w.jpg?source=1940ef5c" alt="img"></p><p>42.人生的路程就像爬山一样，看起来走了许多冤枉的路，但最终都会到达山顶。    ——林海音 《城南旧事》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-9ba9b20792c0b794d1e51b780bd1661e_720w.jpg?source=1940ef5c" alt="img"></p><p>43.做有用的事，说勇敢的话，想美好的事，睡安稳的觉。把时间用在进步上，而不是抱怨上。</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-e81e423369ed0f748c8d4b1a608aa5a5_720w.jpg?source=1940ef5c" alt="img"></p><p>44.人要锻炼自己的人格、风骨，不要随风雨破落，失去自己的样子。                         ——林清玄</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-388a216abc2650abf268c9d4a7b24abf_720w.jpg?source=1940ef5c" alt="img"></p><p>45.若要梦想实现，先从梦中醒来。</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-5643814cc9f4983bf871a5d2a33e2a96_720w.jpg?source=1940ef5c" alt="img"></p><p>46.生活从不会因为你是女生就给你开绿灯，你真心想要的，没有一样是轻而易举就可以得到的。你所有的努力，只为在那个对的人出现时，可以理直气壮的说一句：我知道你很好，但是我也不差。                         ——《青春励志》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-4a4212d2a63e36d209352496adf757c6_720w.jpg?source=1940ef5c" alt="img"></p><p>47.谁终将声震人间，必长久深自缄默；谁终将点燃闪电，必长久如云漂泊。             ——尼采</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-706cd577a4e6b915c50c325df9e2bd39_720w.jpg?source=1940ef5c" alt="img"></p><p>48.常常是最后一把钥匙打开了门。            ——钱学森</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-a5e5898650082832f180251230283a89_720w.jpg?source=1940ef5c" alt="img"></p><p>49.无论这个世界对你怎样，都请你一如既往的努力、勇敢、充满希望。                     ——毕淑敏 《愿你与这世界温暖相拥》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-599dbd5fab5347a47156f12a6fddce88_720w.jpg?source=1940ef5c" alt="img"></p><p>50.人生路上若是有绊脚石，那你一定是平行，向上爬，绊脚石都会成为垫脚石。    ——坏瓜 《坏瓜不坏》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-91320e42d8f0580b21962e547f7bec0b_720w.jpg?source=1940ef5c" alt="img"></p><p>51.人们总说时间可以改变很多事，但事实上必须由你自己做出那些改变。                ——安迪·沃霍尔</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-93cd8d576d063e6cf388cbf27037cc56_720w.jpg?source=1940ef5c" alt="img"></p><p>52.不管是谁，不作任何思考、随波逐流地过日子，都会变得很寂寞。                         ——松浦弥太郎</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-17cb90d7f6a7d08d278a88be566e546f_720w.jpg?source=1940ef5c" alt="img"></p><p>53.如果你第一步不迈出，就永远不知道你的梦想是多么容易实现。                             ——李尚龙 《你只是看起来很努力》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-80ba7167c0248fdc5811ee0872769809_720w.jpg?source=1940ef5c" alt="img"></p><p>54.可以不再骄傲，可以失去耐心，也可以丧失理智，但是无论如何，都不要丢掉希望。                                                                ——《英语，励志，佳句》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-56e1605f0a6b69547a0e9436411b08c5_720w.jpg?source=1940ef5c" alt="img"></p><p>55.我需要机会脱离我出生的环境，我认识的人全都充满了怨气，他们活着只是为了生存，但是我相信有比那更好的地方，那里更发达，我要活在那种地方，就是这样。就在那一刻，我明白了，我得作出选择。我可以为自己寻找各种借口对生活低头，也可以迫使自己创造更好的生活。                            ——《风雨哈佛路》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-725840d1bb0f849bcdf2c93d10c3690f_720w.jpg?source=1940ef5c" alt="img"></p><p>56.任何值得做的事，做的糟糕也值得做。</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic3.zhimg.com/80/v2-f0dc0dde7cf57840b69b6e76bece03ed_720w.jpg?source=1940ef5c" alt="img"></p><p>57.一个人只要知道自己去哪里，全世界都会给他让步。                                                 ——爱默生</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-38f70d24348d0dd67772e30653b8ef9f_720w.jpg?source=1940ef5c" alt="img"></p><p>58.若命运不公，就和他斗到底。               ——《哪吒之魔童降世》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-798669b7b21339320615820f97472626_720w.jpg?source=1940ef5c" alt="img"></p><p>59.你们认为没有路，是因为没有学会不择手段。                                                            ——托马斯・维德 《三体》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-01029aaffc3fc39398831945e26625ed_720w.jpg?source=1940ef5c" alt="img"></p><p>60.万物皆有裂痕，那是光进来的地方。   ——莱昂纳德・科恩</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-d8712bcd8371ec2c0f3e460f7a19bea5_720w.jpg?source=1940ef5c" alt="img"></p><p>61.无论怎么样，一个人借故堕落总是不值得原谅的，越是没有人爱，越要爱自己。 ——亦舒</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-4bfe7571a17598e07490f7d1ef9373df_720w.jpg?source=1940ef5c" alt="img"></p><p>62.人一切的痛苦，本质上都是对自己无能的愤怒。而自律，恰恰是解决人生痛苦的根本途径。——王小波</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-6b1474672c45b84f455042a7d3655911_720w.jpg?source=1940ef5c" alt="img"></p><p>63.毋庸置疑，好的事情总会到来。而当它来晚时，也不失为一种惊喜。                      —— 《托斯卡纳艳阳下》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-30abe8100c73996c5cfb5f5d1b7133b8_720w.jpg?source=1940ef5c" alt="img"></p><p>64.我越来越相信，创造美好的代价是：努力、失望以及毅力。首先是疼痛，然后才是欢乐。                                                                ——梵高</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-68ba64961d024971e95cea470cf94210_720w.jpg?source=1940ef5c" alt="img"></p><p>65.世事你不经它，你就摸不准它。世事就俩字：福祸。俩字半边一样，半边不一样，就是说，俩字相互牵连着。就好比箩面的箩筐，咣当摇过去是福，咣当摇过来就是祸。所以说你么得明白，凡遇到好事的时光甭张狂，张狂过头了后边就有祸事。                 ——陈忠实《白鹿原》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic3.zhimg.com/80/v2-eb0449a413b86be931397bf2b0fac2b0_720w.jpg?source=1940ef5c" alt="img"></p><p>66.总之岁月漫长，然而值得等待。           —— 村上春树 《如果我们的语言是威士忌》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-647afdecc251a50c3ee0ad6db40861c9_720w.jpg?source=1940ef5c" alt="img"></p><h2 id="写在最后，没有事是不可能实现的，难的是踏出那一步，以及之后的坚持，与诸君共勉，愿大家都有好的前程，乾坤未定，你我皆是黑马。"><a href="#写在最后，没有事是不可能实现的，难的是踏出那一步，以及之后的坚持，与诸君共勉，愿大家都有好的前程，乾坤未定，你我皆是黑马。" class="headerlink" title="写在最后，没有事是不可能实现的，难的是踏出那一步，以及之后的坚持，与诸君共勉，愿大家都有好的前程，乾坤未定，你我皆是黑马。"></a><strong>写在最后，没有事是不可能实现的，难的是踏出那一步，以及之后的坚持，与诸君共勉，愿大家都有好的前程，乾坤未定，你我皆是黑马。</strong></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;骚话合集（-）&quot;&gt;&lt;a href=&quot;#骚话合集（-）&quot; class=&quot;headerlink&quot; title=&quot;骚话合集（=-=）&quot;&gt;&lt;/a&gt;骚话合集（=-=）&lt;/h3&gt;&lt;p&gt;作者：言予&lt;br&gt;链接：&lt;a href=&quot;https://www.zhihu.com/que</summary>
      
    
    
    
    <category term="日常" scheme="https://cddorz.github.io/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="励志" scheme="https://cddorz.github.io/tags/%E5%8A%B1%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="https://cddorz.github.io/2020/11/16/Redis/"/>
    <id>https://cddorz.github.io/2020/11/16/Redis/</id>
    <published>2020-11-16T06:23:13.000Z</published>
    <updated>2020-11-17T08:31:07.719Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Nosql概述"><a href="#一、Nosql概述" class="headerlink" title="一、Nosql概述"></a>一、Nosql概述</h1><h2 id="1、单机Mysql时代"><a href="#1、单机Mysql时代" class="headerlink" title="1、单机Mysql时代"></a>1、单机Mysql时代</h2><p>90年代,一个网站的访问量一般不会太大，单个数据库完全够用。随着用户增多，网站出现以下问题：</p><ol><li>数据量增加到一定程度，单机数据库就放不下了</li><li>数据的索引（B+ Tree）,一个机器内存也存放不下</li><li>访问量变大后（读写混合），一台服务器承受不住。</li></ol><p><a href="https://img-blog.csdnimg.cn/2020082010365930.png#pic_center"><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020082010365930.png#pic_center" alt="img"></a></p><h2 id="2、Memcached-缓存-Mysql-垂直拆分（读写分离）"><a href="#2、Memcached-缓存-Mysql-垂直拆分（读写分离）" class="headerlink" title="2、Memcached(缓存) + Mysql + 垂直拆分（读写分离）"></a>2、Memcached(缓存) + Mysql + 垂直拆分（读写分离）</h2><p>网站80%的情况都是在读，每次都要去查询数据库的话就十分的麻烦！所以说我们希望减轻数据库的压力，我们可以使用缓存来保证效率！</p><p><a href="https://img-blog.csdnimg.cn/20200820103713734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center"><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200820103713734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="img"></a></p><p>优化过程经历了以下几个过程：</p><ol><li>优化数据库的数据结构和索引(难度大)</li><li>文件缓存，通过IO流获取比每次都访问数据库效率略高，但是流量爆炸式增长时候，IO流也承受不了</li><li>MemCache,当时最热门的技术，通过在数据库和数据库访问层之间加上一层缓存，第一次访问时查询数据库，将结果保存到缓存，后续的查询先检查缓存，若有直接拿去使用，效率显著提升。</li></ol><h2 id="3、分库分表-水平拆分-Mysql集群"><a href="#3、分库分表-水平拆分-Mysql集群" class="headerlink" title="3、分库分表 + 水平拆分 + Mysql集群"></a>3、分库分表 + 水平拆分 + Mysql集群</h2><p><a href="https://img-blog.csdnimg.cn/20200820103739584.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center"><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200820103739584.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="img"></a></p><h2 id="4、如今最近的年代"><a href="#4、如今最近的年代" class="headerlink" title="4、如今最近的年代"></a>4、如今最近的年代</h2><p>如今信息量井喷式增长，各种各样的数据出现（用户定位数据，图片数据等），大数据的背景下关系型数据库（RDBMS）无法满足大量数据要求。Nosql数据库就能轻松解决这些问题。目前一个基本的互联网项目：</p><p><a href="https://img-blog.csdnimg.cn/20200820103804572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center"><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200820103804572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="img"></a></p><h2 id="5、为什么要用NoSQL-？"><a href="#5、为什么要用NoSQL-？" class="headerlink" title="5、为什么要用NoSQL ？"></a>5、为什么要用NoSQL ？</h2><p>用户的个人信息，社交网络，地理位置。用户自己产生的数据，用户日志等等爆发式增长！这时候我们就需要使用NoSQL数据库的，Nosql可以很好的处理以上的情况！</p><h3 id="什么是Nosql"><a href="#什么是Nosql" class="headerlink" title="什么是Nosql"></a>什么是Nosql</h3><p>NoSQL = Not Only SQL（不仅仅是SQL）</p><p>Not Only Structured Query Language</p><p>关系型数据库：列+行，同一个表下数据的结构是一样的。</p><p>非关系型数据库：数据存储没有固定的格式，并且可以进行横向扩展。</p><p>NoSQL泛指非关系型数据库，随着web2.0互联网的诞生，传统的关系型数据库很难对付web2.0时代！尤其是超大规模的高并发的社区，暴露出来很多难以克服的问题，NoSQL在当今大数据环境下发展的十分迅速，Redis是发展最快的。</p><h3 id="Nosql特点"><a href="#Nosql特点" class="headerlink" title="Nosql特点"></a>Nosql特点</h3><p>1.方便扩展（数据之间没有关系，很好扩展！）</p><p>2.大数据量高性能（Redis一秒可以写8万次，读11万次，NoSQL的缓存记录级，是一种细粒度的缓存，性能会比较高！）</p><p>3.数据类型是多样型的！（不需要事先设计数据库，随取随用）</p><p>4.传统的 RDBMS 和 NoSQL</p><blockquote><p>传统的 RDBMS(关系型数据库)</p><blockquote><p>结构化组织<br>SQL<br>数据和关系都存在单独的表中 row col<br>操作，数据定义语言<br>严格的一致性<br>基础的事务<br>…</p></blockquote><p>Nosql</p><blockquote><p>不仅仅是数据<br>没有固定的查询语言<br>键值对存储，列存储，文档存储，图形数据库（社交关系）<br>最终一致性<br>CAP定理和BASE<br>高性能，高可用，高扩展<br>…</p></blockquote></blockquote><p>5.大数据时代的3V ：主要是描述问题的</p><p>海量Velume</p><p>多样Variety</p><p>实时Velocity</p><p>6.大数据时代的3高 ： 主要是对程序的要求</p><p>高并发</p><p>高可扩</p><p>高性能</p><p>真正在公司中的实践：NoSQL + RDBMS 一起使用才是最强的。</p><h1 id="二、Redis入门"><a href="#二、Redis入门" class="headerlink" title="二、Redis入门"></a>二、Redis入门</h1><h2 id="Redis是什么？"><a href="#Redis是什么？" class="headerlink" title="Redis是什么？"></a>Redis是什么？</h2><p>Redis（Remote Dictionary Server )，即远程字典服务。</p><p>是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><p>与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p><h2 id="Redis能干什么？"><a href="#Redis能干什么？" class="headerlink" title="Redis能干什么？"></a>Redis能干什么？</h2><ol><li>内存存储、持久化，内存是断电即失的，所以需要持久化（RDB、AOF）</li><li>高效率、用于高速缓冲</li><li>发布订阅系统</li><li>地图信息分析</li><li>计时器、计数器(eg：浏览量)</li><li>。。。</li></ol><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol><li>多样的数据类型</li><li>持久化</li><li>集群</li><li>事务</li><li>…</li></ol><h2 id="环境搭建（略）"><a href="#环境搭建（略）" class="headerlink" title="环境搭建（略）"></a>环境搭建（略）</h2><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p><strong>redis-benchmark：</strong>Redis官方提供的性能测试工具，参数选项如下：</p><p><a href="https://img-blog.csdnimg.cn/20200513214125892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70"><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513214125892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="img"></a></p><p>简单测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 测试：100个并发连接 100000请求</span><br><span class="line">redis-benchmark -h localhost -p 6379 -c 100 -n 100000</span><br></pre></td></tr></table></figure><p>结果：</p><p><a href="https://img-blog.csdnimg.cn/20200820104343472.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center"><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200820104343472.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="img"></a></p><h5 id="连接redis："><a href="#连接redis：" class="headerlink" title="连接redis："></a>连接redis：</h5><p><img src= "/img/loading.gif" data-lazy-src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20201117102815212.png" alt="image-20201117102815212"></p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>redis默认有16个数据库</p><p><a href="https://img-blog.csdnimg.cn/20200820104357466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center"><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200820104357466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="img"></a></p><p>默认使用的第0个;</p><p>16个数据库为：DB 0~DB 15 默认使用DB 0 ，可以使用<code>select n</code>切换到DB n，<code>dbsize</code>可以查看当前数据库的大小，与key数量相关。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get databases # 命令行查看数据库数量databases</span><br><span class="line">1) &quot;databases&quot;</span><br><span class="line">2) &quot;16&quot;</span><br><span class="line">127.0.0.1:6379&gt; select 8 # 切换数据库 DB 8</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[8]&gt; dbsize # 查看数据库大小</span><br><span class="line">(integer) 0</span><br><span class="line">不同数据库之间 数据是不能互通的，并且dbsize 是根据库中key的个数。</span><br><span class="line">127.0.0.1:6379&gt; set name sakura</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; SELECT 8</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[8]&gt; get name # db8中并不能获取db0中的键值对。</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379[8]&gt; DBSIZE</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379[8]&gt; SELECT 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line"></span><br><span class="line">&quot;counter:rand_int&quot;</span><br><span class="line">&quot;mylist&quot;</span><br><span class="line">&quot;name&quot;</span><br><span class="line">&quot;key:rand_int&quot;</span><br><span class="line">&quot;myset:rand_int&quot;</span><br><span class="line">127.0.0.1:6379&gt; DBSIZE # size和key个数相关</span><br><span class="line">(integer) 5</span><br></pre></td></tr></table></figure><p><code>keys *</code> ：查看当前数据库中所有的key。</p><p><code>flushdb</code>：清空当前数据库中的键值对。</p><p><code>flushall</code>：清空所有数据库的键值对。</p><blockquote><p>Redis是单线程的，Redis是基于内存操作的。</p></blockquote><p>所以Redis的性能瓶颈不是CPU,而是机器内存和网络带宽。</p><p>那么为什么Redis的速度如此快呢，性能这么高呢？QPS达到10W+</p><blockquote><p>Redis为什么单线程还这么快？</p></blockquote><ul><li>误区1：高性能的服务器一定是多线程的？</li><li>误区2：多线程（CPU上下文会切换！）一定比单线程效率高！</li></ul><p>核心：Redis是将所有的数据放在内存中的，所以说使用单线程去操作效率就是最高的，多线程（CPU上下文会切换：耗时的操作！），对于内存系统来说，如果没有上下文切换效率就是最高的，多次读写都是在一个CPU上的，在内存存储数据情况下，单线程就是最佳的方案。</p><h1 id="三、五大数据类型"><a href="#三、五大数据类型" class="headerlink" title="三、五大数据类型"></a>三、五大数据类型</h1><p> Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。它支持字符串、哈希表、列表、集合、有序集合，位图，hyperloglogs等数据类型。内置复制、Lua脚本、LRU收回、事务以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区。</p><h2 id="Redis-key"><a href="#Redis-key" class="headerlink" title="Redis-key"></a>Redis-key</h2><p>在redis中无论什么数据类型，在数据库中都是以key-value形式保存，通过进行对Redis-key的操作，来完成对数据库中数据的操作。</p><p>下面学习的命令：</p><ul><li><code>exists key</code>：判断键是否存在</li><li><code>del key</code>：删除键值对</li><li><code>move key db</code>：将键值对移动到指定数据库</li><li><code>expire key second</code>：设置键值对的过期时间</li><li><code>type key</code>：查看value的数据类型</li></ul><p>　　　</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys * # 查看当前数据库所有key</span><br><span class="line">(empty list or set)</span><br><span class="line">127.0.0.1:6379&gt; set name qinjiang # set key</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set age 20</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;age&quot;</span><br><span class="line">2) &quot;name&quot;</span><br><span class="line">127.0.0.1:6379&gt; move age 1 # 将键值对移动到指定数据库</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; EXISTS age # 判断键是否存在</span><br><span class="line">(integer) 0 # 不存在</span><br><span class="line">127.0.0.1:6379&gt; EXISTS name</span><br><span class="line">(integer) 1 # 存在</span><br><span class="line">127.0.0.1:6379&gt; SELECT 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[1]&gt; keys *</span><br><span class="line">1) &quot;age&quot;</span><br><span class="line">127.0.0.1:6379[1]&gt; del age # 删除键值对</span><br><span class="line">(integer) 1 # 删除个数</span><br><span class="line">127.0.0.1:6379&gt; set age 20</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; EXPIRE age 15 # 设置键值对的过期时间</span><br><span class="line">(integer) 1 # 设置成功 开始计数</span><br><span class="line">127.0.0.1:6379&gt; ttl age # 查看key的过期剩余时间</span><br><span class="line">(integer) 13</span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(integer) 11</span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(integer) 9</span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(integer) -2 # -2 表示key过期，-1表示key未设置过期时间</span><br><span class="line">127.0.0.1:6379&gt; get age # 过期的key 会被自动delete</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line"></span><br><span class="line">&quot;name&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; type name # 查看value的数据类型</span><br><span class="line">string</span><br></pre></td></tr></table></figure><p>关于TTL命令</p><p>Redis的key，通过TTL命令返回key的过期时间，一般来说有3种：</p><ol><li>当前key没有设置过期时间，所以会返回-1.</li><li>当前key有设置过期时间，而且key已经过期，所以会返回-2.</li><li>当前key有设置过期时间，且key还没有过期，故会返回key的正常剩余时间.</li></ol><p>关于重命名<code>RENAME</code>和<code>RENAMENX</code></p><ol><li><code>RENAME key newkey</code>修改 key 的名称</li><li><code>RENAMENX key newkey</code>仅当 newkey 不存在时，将 key 改名为 newkey 。</li></ol><h2 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String(字符串)"></a>String(字符串)</h2><p>普通的set、get直接略过。</p><p>常用命令及其示例：</p><p><code>APPEND key value</code>: 向指定的key的value后追加字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set msg hello </span><br><span class="line">OK </span><br><span class="line">127.0.0.1:6379&gt; append msg &quot; world&quot; </span><br><span class="line">(integer) 11 </span><br><span class="line">127.0.0.1:6379&gt; get msg </span><br><span class="line">“hello world”</span><br></pre></td></tr></table></figure><p><code>DECR/INCR key</code>: 将指定key的value数值进行+1/-1(仅对于数字)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set age 20 </span><br><span class="line">OK </span><br><span class="line">127.0.0.1:6379&gt; incr age </span><br><span class="line">(integer) 21 </span><br><span class="line">127.0.0.1:6379&gt; decr age </span><br><span class="line">(integer) 20</span><br></pre></td></tr></table></figure><p><code>INCRBY/DECRBY key n</code>: 按指定的步长对数值进行加减</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; INCRBY age 5</span><br><span class="line">(integer) 25 </span><br><span class="line">127.0.0.1:6379&gt; DECRBY age 10 </span><br><span class="line">(integer) 15</span><br></pre></td></tr></table></figure><p><code>INCRBYFLOAT key n</code>: 为数值加上浮点型数值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; INCRBYFLOAT age 5.2 </span><br><span class="line">“20.2”</span><br></pre></td></tr></table></figure><p><code>STRLEN key</code>: 获取key保存值的字符串长度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get msg </span><br><span class="line">“hello world” </span><br><span class="line">127.0.0.1:6379&gt; STRLEN msg </span><br><span class="line">(integer) 11</span><br></pre></td></tr></table></figure><p><code>GETRANGE key start end</code>: 按起止位置获取字符串（闭区间，起止位置都取）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get msg </span><br><span class="line">“hello world” </span><br><span class="line">127.0.0.1:6379&gt; GETRANGE msg 3 9 </span><br><span class="line">“lo worl”</span><br></pre></td></tr></table></figure><p><code>SETRANGE key offset value</code>:用指定的value 替换key中 offset开始的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set msg hello</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; setrange msg 2 hello</span><br><span class="line">(integer) 7</span><br><span class="line">127.0.0.1:6379&gt; get msg</span><br><span class="line">&quot;hehello&quot;</span><br><span class="line">127.0.0.1:6379&gt; set msg2 world</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; setrange msg2 2 ww</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; get msg2</span><br><span class="line">&quot;wowwd&quot;</span><br></pre></td></tr></table></figure><p><code>GETSET key value</code>: 将给定 key 的值设为 value ，并返回 key 的旧值(old value)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GETSET msg test </span><br><span class="line">“hello world”</span><br></pre></td></tr></table></figure><p><code>SETNX key value</code>: 仅当key不存在时进行set</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SETNX msg test </span><br><span class="line">(integer) 0 </span><br><span class="line">127.0.0.1:6379&gt; SETNX name sakura </span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p><code>SETEX key seconds value</code>: set 键值对并设置过期时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setex name 10 root </span><br><span class="line">OK </span><br><span class="line">127.0.0.1:6379&gt; get name </span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p><code>MSET key1 value1 [key2 value2..]</code>: 批量set键值对</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MSET k1 v1 k2 v2 k3 v3 </span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p><code>MSETNX key1 value1 [key2 value2..]</code>: 批量设置键值对，仅当参数中所有的key都不存在时执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MSETNX k1 v1 k4 v4 </span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><p><code>MGET key1 [key2..]</code>: 批量获取多个key保存的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MGET k1 k2 k3 </span><br><span class="line">1) “v1” </span><br><span class="line">2) “v2” </span><br><span class="line">3) “v3”</span><br></pre></td></tr></table></figure><p><code>PSETEX key milliseconds value</code>: 和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间</p><p>String类似的使用场景：value除了是字符串还可以是数字，用途举例：</p><ul><li>计数器</li><li>统计多单位的数量：uid:123666：follow 0</li><li>粉丝数</li><li>对象存储缓存</li></ul><h2 id="List-列表"><a href="#List-列表" class="headerlink" title="List(列表)"></a>List(列表)</h2><p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）</p><p>一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。</p><p>首先我们列表，可以经过规则定义将其变为队列、栈、双端队列等。</p><p><a href="https://img-blog.csdnimg.cn/20200820104440398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center"><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200820104440398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="img"></a></p><p>正如图Redis中List是可以进行双端操作的，所以命令也就分为了LXXX和RLLL两类，有时候L也表示List例如LLEN</p><ul><li><code>LPUSH/RPUSH key value1[value2..]</code>从左边/右边向列表中PUSH值(一个或者多个)。</li><li><code>LRANGE key start end</code> 获取list 起止元素==（索引从左往右 递增）==</li><li><code>LPUSHX/RPUSHX key value</code> 向已存在的列名中push值（一个或者多个）</li><li><code>LINSERT key BEFORE|AFTER pivot value</code> 在指定列表元素的前/后 插入value</li><li><code>LLEN key</code> 查看列表长度</li><li><code>LINDEX key index</code> 通过索引获取列表元素</li><li><code>LSET key index value</code> 通过索引为元素设值</li><li><code>LPOP/RPOP key</code> 从最左边/最右边移除值 并返回</li><li><code>RPOPLPUSH source destination</code> 将列表的尾部(右)最后一个值弹出，并返回，然后加到另一个列表的头部</li><li><code>LTRIM key start end</code> 通过下标截取指定范围内的列表</li><li><code>LREM key count value</code> List中是允许value重复的 count &gt; 0：从头部开始搜索 然后删除指定的value 至多删除count个 count &lt; 0：从尾部开始搜索… count = 0：删除列表中所有的指定value。</li><li><code>BLPOP/BRPOP key1[key2] timout</code> 移出并获取列表的第一个/最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</li><li><code>BRPOPLPUSH source destination timeout</code> 和RPOPLPUSH功能相同，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</li></ul><p>代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">---------------------------LPUSH---RPUSH---LRANGE--------------------------------</span><br><span class="line">127.0.0.1:6379&gt; LPUSH mylist k1 # LPUSH mylist&#x3D;&gt;&#123;1&#125;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; LPUSH mylist k2 # LPUSH mylist&#x3D;&gt;&#123;2,1&#125;</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; RPUSH mylist k3 # RPUSH mylist&#x3D;&gt;&#123;2,1,3&#125;</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; get mylist # 普通的get是无法获取list值的</span><br><span class="line">(error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 4 # LRANGE 获取起止位置范围内的元素</span><br><span class="line"></span><br><span class="line">&quot;k2&quot;</span><br><span class="line">&quot;k1&quot;</span><br><span class="line">&quot;k3&quot;</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 2</span><br><span class="line">&quot;k2&quot;</span><br><span class="line">&quot;k1&quot;</span><br><span class="line">&quot;k3&quot;</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 1</span><br><span class="line">&quot;k2&quot;</span><br><span class="line">&quot;k1&quot;</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1 # 获取全部元素</span><br><span class="line">&quot;k2&quot;</span><br><span class="line">&quot;k1&quot;</span><br><span class="line">&quot;k3&quot;</span><br><span class="line"></span><br><span class="line">---------------------------LPUSHX---RPUSHX-----------------------------------</span><br><span class="line">127.0.0.1:6379&gt; LPUSHX list v1 # list不存在 LPUSHX失败</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; LPUSHX list v1 v2</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; LPUSHX mylist k4 k5 # 向mylist中 左边 PUSH k4 k5</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line"></span><br><span class="line">&quot;k5&quot;</span><br><span class="line">&quot;k4&quot;</span><br><span class="line">&quot;k2&quot;</span><br><span class="line">&quot;k1&quot;</span><br><span class="line">&quot;k3&quot;</span><br><span class="line"></span><br><span class="line">---------------------------LINSERT--LLEN--LINDEX--LSET----------------------------</span><br><span class="line">127.0.0.1:6379&gt; LINSERT mylist after k2 ins_key1 # 在k2元素后 插入ins_key1</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line"></span><br><span class="line">&quot;k5&quot;</span><br><span class="line">&quot;k4&quot;</span><br><span class="line">&quot;k2&quot;</span><br><span class="line">&quot;ins_key1&quot;</span><br><span class="line">&quot;k1&quot;</span><br><span class="line">&quot;k3&quot;</span><br><span class="line">127.0.0.1:6379&gt; LLEN mylist # 查看mylist的长度</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; LINDEX mylist 3 # 获取下标为3的元素</span><br><span class="line">&quot;ins_key1&quot;</span><br><span class="line">127.0.0.1:6379&gt; LINDEX mylist 0</span><br><span class="line">&quot;k5&quot;</span><br><span class="line">127.0.0.1:6379&gt; LSET mylist 3 k6 # 将下标3的元素 set值为k6</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">&quot;k5&quot;</span><br><span class="line">&quot;k4&quot;</span><br><span class="line">&quot;k2&quot;</span><br><span class="line">&quot;k6&quot;</span><br><span class="line">&quot;k1&quot;</span><br><span class="line">&quot;k3&quot;</span><br><span class="line"></span><br><span class="line">---------------------------LPOP--RPOP--------------------------</span><br><span class="line">127.0.0.1:6379&gt; LPOP mylist # 左侧(头部)弹出</span><br><span class="line">&quot;k5&quot;</span><br><span class="line">127.0.0.1:6379&gt; RPOP mylist # 右侧(尾部)弹出</span><br><span class="line">&quot;k3&quot;</span><br><span class="line">---------------------------RPOPLPUSH--------------------------</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line"></span><br><span class="line">&quot;k4&quot;</span><br><span class="line">&quot;k2&quot;</span><br><span class="line">&quot;k6&quot;</span><br><span class="line">&quot;k1&quot;</span><br><span class="line">127.0.0.1:6379&gt; RPOPLPUSH mylist newlist # 将mylist的最后一个值(k1)弹出，加入到newlist的头部</span><br><span class="line">&quot;k1&quot;</span><br><span class="line">127.0.0.1:6379&gt; LRANGE newlist 0 -1</span><br><span class="line">&quot;k1&quot;</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">&quot;k4&quot;</span><br><span class="line">&quot;k2&quot;</span><br><span class="line">&quot;k6&quot;</span><br><span class="line"></span><br><span class="line">---------------------------LTRIM--------------------------</span><br><span class="line">127.0.0.1:6379&gt; LTRIM mylist 0 1 # 截取mylist中的 0~1部分</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line"></span><br><span class="line">&quot;k4&quot;</span><br><span class="line">&quot;k2&quot;</span><br><span class="line"></span><br><span class="line">初始 mylist: k2,k2,k2,k2,k2,k2,k4,k2,k2,k2,k2</span><br><span class="line">---------------------------LREM--------------------------</span><br><span class="line">127.0.0.1:6379&gt; LREM mylist 3 k2 # 从头部开始搜索 至多删除3个 k2</span><br><span class="line">(integer) 3</span><br><span class="line">删除后：mylist: k2,k2,k2,k4,k2,k2,k2,k2</span><br><span class="line">127.0.0.1:6379&gt; LREM mylist -2 k2 #从尾部开始搜索 至多删除2个 k2</span><br><span class="line">(integer) 2</span><br><span class="line">删除后：mylist: k2,k2,k2,k4,k2,k2</span><br><span class="line">---------------------------BLPOP--BRPOP--------------------------</span><br><span class="line">mylist: k2,k2,k2,k4,k2,k2</span><br><span class="line">newlist: k1</span><br><span class="line">127.0.0.1:6379&gt; BLPOP newlist mylist 30 # 从newlist中弹出第一个值，mylist作为候选</span><br><span class="line"></span><br><span class="line">&quot;newlist&quot; # 弹出</span><br><span class="line">&quot;k1&quot;</span><br><span class="line">127.0.0.1:6379&gt; BLPOP newlist mylist 30</span><br><span class="line">&quot;mylist&quot; # 由于newlist空了 从mylist中弹出</span><br><span class="line">&quot;k2&quot;</span><br><span class="line">127.0.0.1:6379&gt; BLPOP newlist 30</span><br><span class="line">(30.10s) # 超时了</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; BLPOP newlist 30 # 我们连接另一个客户端向newlist中push了test, 阻塞被解决。</span><br><span class="line"></span><br><span class="line">&quot;newlist&quot;</span><br><span class="line">&quot;test&quot;</span><br><span class="line">(12.54s)</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>list实际上是一个链表，before Node after , left, right 都可以插入值</li><li>如果key不存在，则创建新的链表</li><li>如果key存在，新增内容</li><li>如果移除了所有值，空链表，也代表不存在</li><li>在两边插入或者改动值，效率最高！修改中间元素，效率相对较低</li></ul><p>应用：</p><p>消息排队！消息队列（Lpush Rpop）,栈（Lpush Lpop）</p><h2 id="Set-集合）"><a href="#Set-集合）" class="headerlink" title="Set(集合）"></a>Set(集合）</h2><p>Redis的Set是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p><p>Redis中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p><p>集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p><ul><li><code>SADD key member1[member2..]</code> 向集合中无序增加一个/多个成员</li><li><code>SCARD key</code> 获取集合的成员数</li><li><code>SMEMBERS key</code> 返回集合中所有的成员</li><li><code>SISMEMBER key member</code> 查询member元素是否是集合的成员,结果是无序的</li><li><code>SRANDMEMBER key [count]</code> 随机返回集合中count个成员，count缺省值为1</li><li><code>SPOP key [count]</code> 随机移除并返回集合中count个成员，count缺省值为1</li><li><code>SMOVE source destination member</code> 将source集合的成员member移动到destination集合</li><li><code>SREM key member1[member2..]</code> 移除集合中一个/多个成员</li><li><code>SDIFF key1[key2..]</code> 返回所有集合的差集 key1- key2 - …</li><li><code>SDIFFSTORE destination key1[key2..]</code> 在SDIFF的基础上，将结果保存到集合中==(覆盖)==。不能保存到其他类型key噢！</li><li><code>SINTER key1 [key2..]</code> 返回所有集合的交集</li><li><code>SINTERSTORE destination key1[key2..]</code> 在SINTER的基础上，存储结果到集合中。覆盖</li><li><code>SUNION key1 [key2..]</code> 返回所有集合的并集</li><li><code>SUNIONSTORE destination key1 [key2..]</code> 在SUNION的基础上，存储结果到及和张。覆盖</li><li><code>SSCAN KEY [MATCH pattern] [COUNT count]</code> 在大量数据环境下，使用此命令遍历集合中元素，每次遍历部分</li></ul><p>代码示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">---------------SADD--SCARD--SMEMBERS--SISMEMBER--------------------</span><br><span class="line">127.0.0.1:6379&gt; SADD myset m1 m2 m3 m4 # 向myset中增加成员 m1~m4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; SCARD myset # 获取集合的成员数目</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; smembers myset # 获取集合中所有成员</span><br><span class="line"></span><br><span class="line">&quot;m4&quot;</span><br><span class="line">&quot;m3&quot;</span><br><span class="line">&quot;m2&quot;</span><br><span class="line">&quot;m1&quot;</span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset m5 # 查询m5是否是myset的成员</span><br><span class="line">(integer) 0 # 不是，返回0</span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset m2</span><br><span class="line">(integer) 1 # 是，返回1</span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset m3</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">---------------------SRANDMEMBER--SPOP----------------------------------</span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset 3 # 随机返回3个成员</span><br><span class="line"></span><br><span class="line">&quot;m2&quot;</span><br><span class="line">&quot;m3&quot;</span><br><span class="line">&quot;m4&quot;</span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset # 随机返回1个成员</span><br><span class="line">&quot;m3&quot;</span><br><span class="line">127.0.0.1:6379&gt; SPOP myset 2 # 随机移除并返回2个成员</span><br><span class="line">&quot;m1&quot;</span><br><span class="line">&quot;m4&quot;</span><br><span class="line"></span><br><span class="line">将set还原到&#123;m1,m2,m3,m4&#125;</span><br><span class="line">---------------------SMOVE--SREM----------------------------------------</span><br><span class="line">127.0.0.1:6379&gt; SMOVE myset newset m3 # 将myset中m3成员移动到newset集合</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line"></span><br><span class="line">&quot;m4&quot;</span><br><span class="line">&quot;m2&quot;</span><br><span class="line">&quot;m1&quot;</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS newset</span><br><span class="line">&quot;m3&quot;</span><br><span class="line">127.0.0.1:6379&gt; SREM newset m3 # 从newset中移除m3元素</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS newset</span><br><span class="line">(empty list or set)</span><br><span class="line"></span><br><span class="line">下面开始是多集合操作,多集合操作中若只有一个参数默认和自身进行运算</span><br><span class="line">setx&#x3D;&gt;&#123;m1,m2,m4,m6&#125;, sety&#x3D;&gt;&#123;m2,m5,m6&#125;, setz&#x3D;&gt;&#123;m1,m3,m6&#125;</span><br><span class="line">-----------------------------SDIFF------------------------------------</span><br><span class="line">127.0.0.1:6379&gt; SDIFF setx sety setz # 等价于setx-sety-setz</span><br><span class="line"></span><br><span class="line">&quot;m4&quot;</span><br><span class="line">127.0.0.1:6379&gt; SDIFF setx sety # setx - sety</span><br><span class="line">&quot;m4&quot;</span><br><span class="line">&quot;m1&quot;</span><br><span class="line">127.0.0.1:6379&gt; SDIFF sety setx # sety - setx</span><br><span class="line">&quot;m5&quot;</span><br><span class="line"></span><br><span class="line">-------------------------SINTER---------------------------------------</span><br><span class="line">共同关注（交集）</span><br><span class="line">127.0.0.1:6379&gt; SINTER setx sety setz # 求 setx、sety、setx的交集</span><br><span class="line"></span><br><span class="line">&quot;m6&quot;</span><br><span class="line">127.0.0.1:6379&gt; SINTER setx sety # 求setx sety的交集</span><br><span class="line">&quot;m2&quot;</span><br><span class="line">&quot;m6&quot;</span><br><span class="line"></span><br><span class="line">-------------------------SUNION---------------------------------------</span><br><span class="line">127.0.0.1:6379&gt; SUNION setx sety setz # setx sety setz的并集</span><br><span class="line"></span><br><span class="line">&quot;m4&quot;</span><br><span class="line">&quot;m6&quot;</span><br><span class="line">&quot;m3&quot;</span><br><span class="line">&quot;m2&quot;</span><br><span class="line">&quot;m1&quot;</span><br><span class="line">&quot;m5&quot;</span><br><span class="line">127.0.0.1:6379&gt; SUNION setx sety # setx sety 并集</span><br><span class="line">&quot;m4&quot;</span><br><span class="line">&quot;m6&quot;</span><br><span class="line">&quot;m2&quot;</span><br><span class="line">&quot;m1&quot;</span><br><span class="line">&quot;m5&quot;</span><br></pre></td></tr></table></figure><h2 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h2><p>Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p><p>Set就是一种简化的Hash,只变动key,而value使用默认值填充。可以将一个Hash表作为一个对象进行存储，表中存放对象的信息。</p><ul><li><code>HSET key field value</code> 将哈希表 key 中的字段 field 的值设为 value 。重复设置同一个field会覆盖,返回0</li><li><code>HMSET key field1 value1 [field2 value2..]</code> 同时将多个 field-value (域-值)对设置到哈希表 key 中。</li><li><code>HSETNX key field value</code> 只有在字段 field 不存在时，设置哈希表字段的值。</li><li><code>HEXISTS key field</code> 查看哈希表 key 中，指定的字段是否存在。</li><li><code>HGET key field value</code> 获取存储在哈希表中指定字段的值</li><li><code>HMGET key field1 [field2..]</code> 获取所有给定字段的值</li><li><code>HGETALL key</code> 获取在哈希表key 的所有字段和值</li><li><code>HKEYS key</code> 获取哈希表key中所有的字段</li><li><code>HLEN key</code> 获取哈希表中字段的数量</li><li><code>HVALS key</code> 获取哈希表中所有值</li><li><code>HDEL key field1 [field2..]</code> 删除哈希表key中一个/多个field字段</li><li><code>HINCRBY key field n</code> 为哈希表 key 中的指定字段的整数值加上增量n，并返回增量后结果 一样只适用于整数型字段</li><li><code>HINCRBYFLOAT key field n</code> 为哈希表 key 中的指定字段的浮点数值加上增量 n。</li><li><code>HSCAN key cursor [MATCH pattern] [COUNT count]</code> 迭代哈希表中的键值对。</li></ul><p>代码示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">------------------------HSET--HMSET--HSETNX----------------</span><br><span class="line">127.0.0.1:6379&gt; HSET studentx name sakura # 将studentx哈希表作为一个对象，设置name为sakura</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; HSET studentx name gyc # 重复设置field进行覆盖，并返回0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; HSET studentx age 20 # 设置studentx的age为20</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; HMSET studentx sex 1 tel 15623667886 # 设置sex为1，tel为15623667886</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; HSETNX studentx name gyc # HSETNX 设置已存在的field</span><br><span class="line">(integer) 0 # 失败</span><br><span class="line">127.0.0.1:6379&gt; HSETNX studentx email 12345@qq.com</span><br><span class="line">(integer) 1 # 成功</span><br><span class="line">----------------------HEXISTS--------------------------------</span><br><span class="line">127.0.0.1:6379&gt; HEXISTS studentx name # name字段在studentx中是否存在</span><br><span class="line">(integer) 1 # 存在</span><br><span class="line">127.0.0.1:6379&gt; HEXISTS studentx addr</span><br><span class="line">(integer) 0 # 不存在</span><br><span class="line">-------------------HGET--HMGET--HGETALL-----------</span><br><span class="line">127.0.0.1:6379&gt; HGET studentx name # 获取studentx中name字段的value</span><br><span class="line">&quot;gyc&quot;</span><br><span class="line">127.0.0.1:6379&gt; HMGET studentx name age tel # 获取studentx中name、age、tel字段的value</span><br><span class="line"></span><br><span class="line">&quot;gyc&quot;</span><br><span class="line">&quot;20&quot;</span><br><span class="line">&quot;15623667886&quot;</span><br><span class="line">127.0.0.1:6379&gt; HGETALL studentx # 获取studentx中所有的field及其value</span><br><span class="line">&quot;name&quot;</span><br><span class="line">&quot;gyc&quot;</span><br><span class="line">&quot;age&quot;</span><br><span class="line">&quot;20&quot;</span><br><span class="line">&quot;sex&quot;</span><br><span class="line">&quot;1&quot;</span><br><span class="line">&quot;tel&quot;</span><br><span class="line">&quot;15623667886&quot;</span><br><span class="line">&quot;email&quot;</span><br><span class="line">&quot;12345@qq.com&quot;</span><br><span class="line"></span><br><span class="line">--------------------HKEYS--HLEN--HVALS--------------</span><br><span class="line">127.0.0.1:6379&gt; HKEYS studentx # 查看studentx中所有的field</span><br><span class="line"></span><br><span class="line">&quot;name&quot;</span><br><span class="line">&quot;age&quot;</span><br><span class="line">&quot;sex&quot;</span><br><span class="line">&quot;tel&quot;</span><br><span class="line">&quot;email&quot;</span><br><span class="line">127.0.0.1:6379&gt; HLEN studentx # 查看studentx中的字段数量</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; HVALS studentx # 查看studentx中所有的value</span><br><span class="line">&quot;gyc&quot;</span><br><span class="line">&quot;20&quot;</span><br><span class="line">&quot;1&quot;</span><br><span class="line">&quot;15623667886&quot;</span><br><span class="line">&quot;12345@qq.com&quot;</span><br><span class="line"></span><br><span class="line">-------------------------HDEL--------------------------</span><br><span class="line">127.0.0.1:6379&gt; HDEL studentx sex tel # 删除studentx 中的sex、tel字段</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; HKEYS studentx</span><br><span class="line"></span><br><span class="line">&quot;name&quot;</span><br><span class="line">&quot;age&quot;</span><br><span class="line">&quot;email&quot;</span><br><span class="line"></span><br><span class="line">-------------HINCRBY--HINCRBYFLOAT------------------------</span><br><span class="line">127.0.0.1:6379&gt; HINCRBY studentx age 1 # studentx的age字段数值+1</span><br><span class="line">(integer) 21</span><br><span class="line">127.0.0.1:6379&gt; HINCRBY studentx name 1 # 非整数字型字段不可用</span><br><span class="line">(error) ERR hash value is not an integer</span><br><span class="line">127.0.0.1:6379&gt; HINCRBYFLOAT studentx weight 0.6 # weight字段增加0.6</span><br><span class="line">&quot;90.8&quot;</span><br></pre></td></tr></table></figure><p> Hash变更的数据user name age，尤其是用户信息之类的，经常变动的信息！Hash更适合于对象的存储，Sring更加适合字符串存储！</p><h2 id="Zset（有序集合）"><a href="#Zset（有序集合）" class="headerlink" title="Zset（有序集合）"></a>Zset（有序集合）</h2><p>不同的是每个元素都会关联一个double类型的分数（score）。redis正是通过分数来为集合中的成员进行从小到大的排序。</p><p>score相同：按字典顺序排序</p><p>有序集合的成员是唯一的,但分数(score)却可以重复。</p><ul><li><code>ZADD key score member1 [score2 member2]</code> 向有序集合添加一个或多个成员，或者更新已存在成员的分数</li><li><code>ZCARD key</code> 获取有序集合的成员数</li><li><code>ZCOUNT key min max</code> 计算在有序集合中指定区间score的成员数</li><li><code>ZINCRBY key n member</code> 有序集合中对指定成员的分数加上增量 n</li><li><code>ZSCORE key member</code> 返回有序集中，成员的分数值</li><li><code>ZRANK key member</code> 返回有序集合中指定成员的索引</li><li><code>ZRANGE key start end</code> 通过索引区间返回有序集合成指定区间内的成员</li><li><code>ZRANGEBYLEX key min max</code> 通过字典区间返回有序集合的成员</li><li><code>ZRANGEBYSCORE key min max</code> 通过分数返回有序集合指定区间内的成员==-inf 和 +inf分别表示最小最大值，只支持开区间()==</li><li><code>ZLEXCOUNT key min max</code> 在有序集合中计算指定字典区间内成员数量</li><li><code>ZREM key member1 [member2..]</code> 移除有序集合中一个/多个成员</li><li><code>ZREMRANGEBYLEX key min max</code> 移除有序集合中给定的字典区间的所有成员</li><li><code>ZREMRANGEBYRANK key start stop</code> 移除有序集合中给定的排名区间的所有成员</li><li><code>ZREMRANGEBYSCORE key min max</code> 移除有序集合中给定的分数区间的所有成员</li><li><code>ZREVRANGE key start end</code> 返回有序集中指定区间内的成员，通过索引，分数从高到底</li><li><code>ZREVRANGEBYSCORRE key max min</code> 返回有序集中指定分数区间内的成员，分数从高到低排序</li><li><code>ZREVRANGEBYLEX key max min</code> 返回有序集中指定字典区间内的成员，按字典顺序倒序</li><li><code>ZREVRANK key member</code> 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</li><li><code>ZINTERSTORE destination numkeys key1 [key2 ..]</code> 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中，numkeys：表示参与运算的集合数，将score相加作为结果的score</li><li><code>ZUNIONSTORE destination numkeys key1 [key2..]</code> 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中</li><li><code>ZSCAN key cursor [MATCH pattern\] [COUNT count]</code> 迭代有序集合中的元素（包括元素成员和元素分值）</li></ul><p>代码示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">-------------------ZADD--ZCARD--ZCOUNT--------------</span><br><span class="line">127.0.0.1:6379&gt; ZADD myzset 1 m1 2 m2 3 m3 # 向有序集合myzset中添加成员m1 score&#x3D;1 以及成员m2 score&#x3D;2..</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; ZCARD myzset # 获取有序集合的成员数</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; ZCOUNT myzset 0 1 # 获取score在 [0,1]区间的成员数量</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ZCOUNT myzset 0 2</span><br><span class="line">(integer) 2</span><br><span class="line">----------------ZINCRBY--ZSCORE--------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZINCRBY myzset 5 m2 # 将成员m2的score +5</span><br><span class="line">&quot;7&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZSCORE myzset m1 # 获取成员m1的score</span><br><span class="line">&quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZSCORE myzset m2</span><br><span class="line">&quot;7&quot;</span><br><span class="line">--------------ZRANK--ZRANGE-----------------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZRANK myzset m1 # 获取成员m1的索引，索引按照score排序，score相同索引值按字典顺序顺序增加</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; ZRANK myzset m2</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE myzset 0 1 # 获取索引在 0~1的成员</span><br><span class="line"></span><br><span class="line">&quot;m1&quot;</span><br><span class="line">&quot;m3&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE myzset 0 -1 # 获取全部成员</span><br><span class="line">&quot;m1&quot;</span><br><span class="line">&quot;m3&quot;</span><br><span class="line">&quot;m2&quot;</span><br><span class="line"></span><br><span class="line">testset&#x3D;&gt;&#123;abc,add,amaze,apple,back,java,redis&#125; score均为0</span><br><span class="line">------------------ZRANGEBYLEX---------------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYLEX testset - + # 返回所有成员</span><br><span class="line"></span><br><span class="line">&quot;abc&quot;</span><br><span class="line">&quot;add&quot;</span><br><span class="line">&quot;amaze&quot;</span><br><span class="line">&quot;apple&quot;</span><br><span class="line">&quot;back&quot;</span><br><span class="line">&quot;java&quot;</span><br><span class="line">&quot;redis&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYLEX testset - + LIMIT 0 3 # 分页 按索引显示查询结果的 0,1,2条记录</span><br><span class="line">&quot;abc&quot;</span><br><span class="line">&quot;add&quot;</span><br><span class="line">&quot;amaze&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYLEX testset - + LIMIT 3 3 # 显示 3,4,5条记录</span><br><span class="line">&quot;apple&quot;</span><br><span class="line">&quot;back&quot;</span><br><span class="line">&quot;java&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYLEX testset (- [apple # 显示 (-,apple] 区间内的成员</span><br><span class="line">&quot;abc&quot;</span><br><span class="line">&quot;add&quot;</span><br><span class="line">&quot;amaze&quot;</span><br><span class="line">&quot;apple&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYLEX testset [apple [java # 显示 [apple,java]字典区间的成员</span><br><span class="line">&quot;apple&quot;</span><br><span class="line">&quot;back&quot;</span><br><span class="line">&quot;java&quot;</span><br><span class="line"></span><br><span class="line">-----------------------ZRANGEBYSCORE---------------------</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE myzset 1 10 # 返回score在 [1,10]之间的的成员</span><br><span class="line"></span><br><span class="line">&quot;m1&quot;</span><br><span class="line">&quot;m3&quot;</span><br><span class="line">&quot;m2&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE myzset 1 5</span><br><span class="line">&quot;m1&quot;</span><br><span class="line">&quot;m3&quot;</span><br><span class="line"></span><br><span class="line">--------------------ZLEXCOUNT-----------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZLEXCOUNT testset - +</span><br><span class="line">(integer) 7</span><br><span class="line">127.0.0.1:6379&gt; ZLEXCOUNT testset [apple [java</span><br><span class="line">(integer) 3</span><br><span class="line">------------------ZREM--ZREMRANGEBYLEX--ZREMRANGBYRANK--ZREMRANGEBYSCORE--------------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZREM testset abc # 移除成员abc</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ZREMRANGEBYLEX testset [apple [java # 移除字典区间[apple,java]中的所有成员</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; ZREMRANGEBYRANK testset 0 1 # 移除排名0~1的所有成员</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; ZREMRANGEBYSCORE myzset 0 3 # 移除score在 [0,3]的成员</span><br><span class="line">(integer) 2</span><br><span class="line">testset&#x3D;&gt; &#123;abc,add,apple,amaze,back,java,redis&#125; score均为0</span><br><span class="line">myzset&#x3D;&gt; &#123;(m1,1),(m2,2),(m3,3),(m4,4),(m7,7),(m9,9)&#125;</span><br><span class="line">----------------ZREVRANGE--ZREVRANGEBYSCORE--ZREVRANGEBYLEX-----------</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGE myzset 0 3 # 按score递减排序，然后按索引，返回结果的 0~3</span><br><span class="line"></span><br><span class="line">&quot;m9&quot;</span><br><span class="line">&quot;m7&quot;</span><br><span class="line">&quot;m4&quot;</span><br><span class="line">&quot;m3&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGE myzset 2 4 # 返回排序结果的 索引的2~4</span><br><span class="line">&quot;m4&quot;</span><br><span class="line">&quot;m3&quot;</span><br><span class="line">&quot;m2&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGEBYSCORE myzset 6 2 # 按score递减顺序 返回集合中分数在[2,6]之间的成员</span><br><span class="line">&quot;m4&quot;</span><br><span class="line">&quot;m3&quot;</span><br><span class="line">&quot;m2&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGEBYLEX testset [java (add # 按字典倒序 返回集合中(add,java]字典区间的成员</span><br><span class="line">&quot;java&quot;</span><br><span class="line">&quot;back&quot;</span><br><span class="line">&quot;apple&quot;</span><br><span class="line">&quot;amaze&quot;</span><br><span class="line"></span><br><span class="line">-------------------------ZREVRANK------------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANK myzset m7 # 按score递减顺序，返回成员m7索引</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANK myzset m2</span><br><span class="line">(integer) 4</span><br><span class="line">mathscore&#x3D;&gt;&#123;(xm,90),(xh,95),(xg,87)&#125; 小明、小红、小刚的数学成绩</span><br><span class="line">enscore&#x3D;&gt;&#123;(xm,70),(xh,93),(xg,90)&#125; 小明、小红、小刚的英语成绩</span><br><span class="line">-------------------ZINTERSTORE--ZUNIONSTORE-----------------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZINTERSTORE sumscore 2 mathscore enscore # 将mathscore enscore进行合并 结果存放到sumscore</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE sumscore 0 -1 withscores # 合并后的score是之前集合中所有score的和</span><br><span class="line"></span><br><span class="line">&quot;xm&quot;</span><br><span class="line">&quot;160&quot;</span><br><span class="line">&quot;xg&quot;</span><br><span class="line">&quot;177&quot;</span><br><span class="line">&quot;xh&quot;</span><br><span class="line">&quot;188&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ZUNIONSTORE lowestscore 2 mathscore enscore AGGREGATE MIN # 取两个集合的成员score最小值作为结果的</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE lowestscore 0 -1 withscores</span><br><span class="line"></span><br><span class="line">&quot;xm&quot;</span><br><span class="line">&quot;70&quot;</span><br><span class="line">&quot;xg&quot;</span><br><span class="line">&quot;87&quot;</span><br><span class="line">&quot;xh&quot;</span><br><span class="line">&quot;93&quot;</span><br></pre></td></tr></table></figure><p>应用案例：</p><ol><li>set排序 存储班级成绩表 工资表排序！</li><li>普通消息，1.重要消息 2.带权重进行判断</li><li>排行榜应用实现，取Top N测试</li></ol><p>转载自：<a href="https://www.cnblogs.com/kylinxxx/p/13770063.html">https://www.cnblogs.com/kylinxxx/p/13770063.html</a></p><h2 id="四、三种特殊数据类型"><a href="#四、三种特殊数据类型" class="headerlink" title="四、三种特殊数据类型"></a>四、三种特殊数据类型</h2><h3 id="Geospatial-地理位置"><a href="#Geospatial-地理位置" class="headerlink" title="Geospatial(地理位置)"></a>Geospatial(地理位置)</h3><blockquote><p>使用经纬度定位地理坐标并用一个<strong>有序集合zset保存</strong>，所以zset命令也可以使用</p></blockquote><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>geoadd key longitud(经度) latitude(纬度) member [..]</code></td><td>将具体经纬度的坐标存入一个有序集合</td></tr><tr><td><code>geopos key member [member..]</code></td><td>获取集合中的一个/多个成员坐标</td></tr><tr><td><code>geodist key member1 member2 [unit]</code></td><td>返回两个给定位置之间的距离。默认以米作为单位。</td></tr><tr><td>`georadius key longitude latitude radius m</td><td>km</td></tr><tr><td><code>GEORADIUSBYMEMBER key member radius...</code></td><td>功能与GEORADIUS相同，只是中心位置不是具体的经纬度，而是使用结合中已有的成员作为中心点。</td></tr><tr><td><code>geohash key member1 [member2..]</code></td><td>返回一个或多个位置元素的Geohash表示。使用Geohash位置52点整数编码。</td></tr></tbody></table><p><strong>有效经纬度</strong></p><blockquote><ul><li>有效的经度从-180度到180度。</li><li>有效的纬度从-85.05112878度到85.05112878度。</li></ul></blockquote><p>指定单位的参数 <strong>unit</strong> 必须是以下单位的其中一个：</p><ul><li><strong>m</strong> 表示单位为米。</li><li><strong>km</strong> 表示单位为千米。</li><li><strong>mi</strong> 表示单位为英里。</li><li><strong>ft</strong> 表示单位为英尺。</li></ul><p><strong>关于GEORADIUS的参数</strong></p><blockquote><p>通过<code>georadius</code>就可以完成 <strong>附近的人</strong>功能</p><p>withcoord:带上坐标</p><p>withdist:带上距离，单位与半径单位相同</p><p>COUNT n : 只显示前n个(按距离递增排序)</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">----------------georadius---------------------</span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS china:city 120 30 500 km withcoord withdist <span class="comment"># 查询经纬度(120,30)坐标500km半径内的成员</span></span><br><span class="line">1) 1) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line">   2) <span class="string">&quot;29.4151&quot;</span></span><br><span class="line">   3) 1) <span class="string">&quot;120.20000249147415&quot;</span></span><br><span class="line">      2) <span class="string">&quot;30.199999888333501&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;shanghai&quot;</span></span><br><span class="line">   2) <span class="string">&quot;205.3611&quot;</span></span><br><span class="line">   3) 1) <span class="string">&quot;121.40000134706497&quot;</span></span><br><span class="line">      2) <span class="string">&quot;31.400000253193539&quot;</span></span><br><span class="line">     </span><br><span class="line">------------geohash---------------------------</span><br><span class="line">127.0.0.1:6379&gt; geohash china:city yichang shanghai <span class="comment"># 获取成员经纬坐标的geohash表示</span></span><br><span class="line">1) <span class="string">&quot;wmrjwbr5250&quot;</span></span><br><span class="line">2) <span class="string">&quot;wtw6ds0y300&quot;</span></span><br><span class="line">123456789101112131415</span><br></pre></td></tr></table></figure><h3 id="Hyperloglog-基数统计"><a href="#Hyperloglog-基数统计" class="headerlink" title="Hyperloglog(基数统计)"></a>Hyperloglog(基数统计)</h3><blockquote><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p><p>花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。</p><p>因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p><p>其底层使用string数据类型</p></blockquote><p><strong>什么是基数？</strong></p><blockquote><p>数据集中不重复的元素的个数。</p></blockquote><p><strong>应用场景：</strong></p><p>网页的访问量（UV）：一个用户多次访问，也只能算作一个人。</p><blockquote><p>传统实现，存储用户的id,然后每次进行比较。当用户变多之后这种方式及其浪费空间，而我们的目的只是<strong>计数</strong>，Hyperloglog就能帮助我们利用最小的空间完成。</p></blockquote><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>PFADD key element1 [elememt2..]</code></td><td>添加指定元素到 HyperLogLog 中</td></tr><tr><td><code>PFCOUNT key [key]</code></td><td>返回给定 HyperLogLog 的基数估算值。</td></tr><tr><td><code>PFMERGE destkey sourcekey [sourcekey..]</code></td><td>将多个 HyperLogLog 合并为一个 HyperLogLog</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">----------PFADD--PFCOUNT---------------------</span><br><span class="line">127.0.0.1:6379&gt; PFADD myelemx a b c d e f g h i j k <span class="comment"># 添加元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> myelemx <span class="comment"># hyperloglog底层使用String</span></span><br><span class="line">string</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT myelemx <span class="comment"># 估算myelemx的基数</span></span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br><span class="line">127.0.0.1:6379&gt; PFADD myelemy i j k z m c b v p q s</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT myelemy</span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br><span class="line"></span><br><span class="line">----------------PFMERGE-----------------------</span><br><span class="line">127.0.0.1:6379&gt; PFMERGE myelemz myelemx myelemy <span class="comment"># 合并myelemx和myelemy 成为myelemz</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT myelemz <span class="comment"># 估算基数</span></span><br><span class="line">(<span class="built_in">integer</span>) 17</span><br><span class="line">1234567891011121314151617</span><br></pre></td></tr></table></figure><p>如果允许容错，那么一定可以使用Hyperloglog !</p><p>如果不允许容错，就使用set或者自己的数据类型即可 ！</p><h3 id="BitMaps-位图"><a href="#BitMaps-位图" class="headerlink" title="BitMaps(位图)"></a>BitMaps(位图)</h3><blockquote><p>使用位存储，信息状态只有 0 和 1</p><p>Bitmap是一串连续的2进制数字（0或1），每一位所在的位置为偏移(offset)，在bitmap上可执行AND,OR,XOR,NOT以及其它位操作。</p></blockquote><p><strong>应用场景</strong></p><p>签到统计、状态统计</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>setbit key offset value</code></td><td>为指定key的offset位设置值</td></tr><tr><td><code>getbit key offset</code></td><td>获取offset位的值</td></tr><tr><td><code>bitcount key [start end]</code></td><td>统计字符串被设置为1的bit数，也可以指定统计范围按字节</td></tr><tr><td><code>bitop operration destkey key[key..]</code></td><td>对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。</td></tr><tr><td><code>BITPOS key bit [start] [end]</code></td><td>返回字符串里面第一个被设置为1或者0的bit位。start和end只能按字节,不能按位</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">------------setbit--getbit--------------</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 0 1 <span class="comment"># 设置sign的第0位为 1 </span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 2 1 <span class="comment"># 设置sign的第2位为 1  不设置默认 是0</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 3 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 5 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> sign</span><br><span class="line">string</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; getbit sign 2 <span class="comment"># 获取第2位的数值</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit sign 3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit sign 4 <span class="comment"># 未设置默认是0</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">-----------bitcount----------------------------</span><br><span class="line">127.0.0.1:6379&gt; BITCOUNT sign <span class="comment"># 统计sign中为1的位数</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">12345678910111213141516171819202122</span><br></pre></td></tr></table></figure><p><strong>bitmaps的底层</strong></p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-9PlszjhS-1597890996519)(D:\我\MyBlog\狂神说 Redis.assets\image-20200803234336175.png)]</p><p>这样设置以后你能get到的值是：<strong>\xA2\x80</strong>，所以bitmaps是一串从左到右的二进制串</p><h2 id="五、事务"><a href="#五、事务" class="headerlink" title="五、事务"></a>五、事务</h2><p>Redis的单条命令是保证原子性的，但是redis事务不能保证原子性</p><blockquote><p>Redis事务本质：一组命令的集合。</p><p>—————– 队列 set set set 执行 ——————-</p><p>事务中每条命令都会被序列化，执行过程中按顺序执行，不允许其他命令进行干扰。</p><ul><li>一次性</li><li>顺序性</li><li>排他性</li></ul><hr><ol><li>Redis事务没有隔离级别的概念</li><li>Redis单条命令是保证原子性的，但是事务不保证原子性！</li></ol></blockquote><h3 id="Redis事务操作过程"><a href="#Redis事务操作过程" class="headerlink" title="Redis事务操作过程"></a>Redis事务操作过程</h3><ul><li>开启事务（<code>multi</code>）</li><li>命令入队</li><li>执行事务（<code>exec</code>）</li></ul><p>所以事务中的命令在加入时都没有被执行，直到提交时才会开始执行(Exec)一次性完成。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi <span class="comment"># 开启事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1 <span class="comment"># 命令入队</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2 <span class="comment"># ..</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span> <span class="comment"># 事务执行</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) <span class="string">&quot;v1&quot;</span></span><br><span class="line">4) OK</span><br><span class="line">5) 1) <span class="string">&quot;k3&quot;</span></span><br><span class="line">   2) <span class="string">&quot;k2&quot;</span></span><br><span class="line">   3) <span class="string">&quot;k1&quot;</span></span><br><span class="line">1234567891011121314151617181920</span><br></pre></td></tr></table></figure><p><strong>取消事务(<code>discurd</code>)</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; DISCARD <span class="comment"># 放弃事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; EXEC </span><br><span class="line">(error) ERR EXEC without MULTI <span class="comment"># 当前未开启事务</span></span><br><span class="line">127.0.0.1:6379&gt; get k1 <span class="comment"># 被放弃事务中命令并未执行</span></span><br><span class="line">(nil)</span><br><span class="line">123456789101112</span><br></pre></td></tr></table></figure><h3 id="事务错误"><a href="#事务错误" class="headerlink" title="事务错误"></a>事务错误</h3><blockquote><p>代码语法错误（编译时异常）所有的命令都不执行</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; error k1 <span class="comment"># 这是一条语法错误命令</span></span><br><span class="line">(error) ERR unknown <span class="built_in">command</span> `error`, with args beginning with: `k1`, <span class="comment"># 会报错但是不影响后续命令入队 </span></span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; EXEC</span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors. <span class="comment"># 执行报错</span></span><br><span class="line">127.0.0.1:6379&gt; get k1 </span><br><span class="line">(nil) <span class="comment"># 其他命令并没有被执行</span></span><br><span class="line">1234567891011121314</span><br></pre></td></tr></table></figure><blockquote><p>代码逻辑错误 (运行时异常) **其他命令可以正常执行 ** &gt;&gt;&gt; 所以不保证事务原子性</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCR k1 <span class="comment"># 这条命令逻辑错误（对字符串进行增量）</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) (error) ERR value is not an <span class="built_in">integer</span> or out of range <span class="comment"># 运行时报错</span></span><br><span class="line">4) <span class="string">&quot;v2&quot;</span> <span class="comment"># 其他命令正常执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 虽然中间有一条命令报错了，但是后面的指令依旧正常执行成功了。</span></span><br><span class="line"><span class="comment"># 所以说Redis单条指令保证原子性，但是Redis事务不能保证原子性。</span></span><br><span class="line">123456789101112131415161718</span><br></pre></td></tr></table></figure><h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p><strong>悲观锁：</strong></p><ul><li>很悲观，认为什么时候都会出现问题，无论做什么都会加锁</li></ul><p><strong>乐观锁：</strong></p><ul><li>很乐观，认为什么时候都不会出现问题，所以不会上锁！更新数据的时候去判断一下，在此期间是否有人修改过这个数据</li><li>获取version</li><li>更新的时候比较version</li></ul><p>使用<code>watch key</code>监控指定数据，相当于乐观锁加锁。</p><blockquote><p>正常执行</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> money 100 <span class="comment"># 设置余额:100</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> use 0 <span class="comment"># 支出使用:0</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money <span class="comment"># 监视money (上锁)</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; DECRBY money 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCRBY use 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span> <span class="comment"># 监视值没有被中途修改，事务正常执行</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 80</span><br><span class="line">2) (<span class="built_in">integer</span>) 20</span><br><span class="line">123456789101112131415</span><br></pre></td></tr></table></figure><blockquote><p>测试多线程修改值，使用watch可以当做redis的乐观锁操作（相当于getversion）</p></blockquote><p>我们启动另外一个客户端模拟插队线程。</p><p>线程1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; watch money <span class="comment"># money上锁</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; DECRBY money 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCRBY use 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="comment"># 此时事务并没有执行</span></span><br><span class="line">123456789</span><br></pre></td></tr></table></figure><p>模拟线程插队，线程2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; INCRBY money 500 <span class="comment"># 修改了线程一中监视的money</span></span><br><span class="line">(<span class="built_in">integer</span>) 600</span><br><span class="line">12</span><br></pre></td></tr></table></figure><p>回到线程1，执行事务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; EXEC <span class="comment"># 执行之前，另一个线程修改了我们的值，这个时候就会导致事务执行失败</span></span><br><span class="line">(nil) <span class="comment"># 没有结果，说明事务执行失败</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; get money <span class="comment"># 线程2 修改生效</span></span><br><span class="line"><span class="string">&quot;600&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get use <span class="comment"># 线程1事务执行失败，数值没有被修改</span></span><br><span class="line"><span class="string">&quot;0&quot;</span></span><br><span class="line">1234567</span><br></pre></td></tr></table></figure><blockquote><p>解锁获取最新值，然后再加锁进行事务。</p><p><code>unwatch</code>进行解锁。</p></blockquote><p>注意：每次提交执行exec后都会自动释放锁，不管是否成功</p><h2 id="六、Jedis"><a href="#六、Jedis" class="headerlink" title="六、Jedis"></a>六、Jedis</h2><p>使用Java来操作Redis，Jedis是Redis官方推荐使用的Java连接redis的客户端。</p><ol><li><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入jredis的包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--fastjson--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.70<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">123456789101112</span><br></pre></td></tr></table></figure></li><li><p>编码测试</p><ul><li><p>连接数据库</p><ol><li><p>修改redis的配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/<span class="built_in">local</span>/bin/myconfig/redis.conf</span><br><span class="line">1</span><br></pre></td></tr></table></figure><ol><li><p>将只绑定本地注释</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-4IRUFJ95-1597890996520)(狂神说 Redis.assets/image-20200813161921480.png)]</p></li><li><p>保护模式改为 no</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-oKjIVapw-1597890996521)(狂神说 Redis.assets/image-20200813161939847.png)]</p></li><li><p>允许后台运行</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-c2IMvpZL-1597890996522)(狂神说 Redis.assets/image-20200813161954567.png)]</p></li></ol></li></ol></li></ul></li><li><p>开放端口6379</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=6379/tcp --permanet</span><br><span class="line"></span><br><span class="line">12</span><br></pre></td></tr></table></figure><p>重启防火墙服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart firewalld.service</span><br><span class="line"></span><br><span class="line">12</span><br></pre></td></tr></table></figure><ol><li><p>阿里云服务器控制台配置安全组</p></li><li><p>重启redis-server</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@AlibabaECS bin]<span class="comment"># redis-server myconfig/redis.conf </span></span><br><span class="line"></span><br><span class="line">12</span><br></pre></td></tr></table></figure></li></ol></li></ol><ul><li><p>操作命令</p><p><strong>TestPing.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.xx.xxx&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        String response = jedis.ping();</span><br><span class="line">        System.out.println(response); <span class="comment">// PONG</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure></li><li><p>断开连接</p></li></ul><ol><li><p><strong>事务</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTX</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;39.99.xxx.xx&quot;</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">        JSONObject jsonObject = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        jsonObject.put(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">        jsonObject.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;kuangshen&quot;</span>);</span><br><span class="line">        <span class="comment">// 开启事务</span></span><br><span class="line">        Transaction multi = jedis.multi();</span><br><span class="line">        String result = jsonObject.toJSONString();</span><br><span class="line">        <span class="comment">// jedis.watch(result)</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            multi.set(<span class="string">&quot;user1&quot;</span>, result);</span><br><span class="line">            multi.set(<span class="string">&quot;user2&quot;</span>, result);</span><br><span class="line">            <span class="comment">// 执行事务</span></span><br><span class="line">            multi.exec();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="comment">// 放弃事务</span></span><br><span class="line">            multi.discard();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭连接</span></span><br><span class="line">            System.out.println(jedis.get(<span class="string">&quot;user1&quot;</span>));</span><br><span class="line">            System.out.println(jedis.get(<span class="string">&quot;user2&quot;</span>));</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="七、SpringBoot整合"><a href="#七、SpringBoot整合" class="headerlink" title="七、SpringBoot整合"></a>七、SpringBoot整合</h2><ol><li>导入依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">1234</span><br></pre></td></tr></table></figure><p>springboot 2.x后 ，原来使用的 Jedis 被 lettuce 替换。</p><blockquote><p>jedis：采用的直连，多个线程操作的话，是不安全的。如果要避免不安全，使用jedis pool连接池！更像BIO模式</p><p>lettuce：采用netty，实例可以在多个线程中共享，不存在线程不安全的情况！可以减少线程数据了，更像NIO模式</p></blockquote><p>我们在学习SpringBoot自动配置的原理时，整合一个组件并进行配置一定会有一个自动配置类xxxAutoConfiguration,并且在spring.factories中也一定能找到这个类的完全限定名。Redis也不例外。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513214531573.png" alt="在这里插入图片描述"></p><p>那么就一定还存在一个RedisProperties类</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513214554661.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>之前我们说SpringBoot2.x后默认使用Lettuce来替换Jedis，现在我们就能来验证了。</p><p>先看Jedis:</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513214607475.png" alt="在这里插入图片描述"></p><p>@ConditionalOnClass注解中有两个类是默认不存在的，所以Jedis是无法生效的</p><p>然后再看Lettuce：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513214618179.png" alt="在这里插入图片描述"></p><p>完美生效。</p><p>现在我们回到RedisAutoConfiguratio</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020051321462777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="img"></p><p>只有两个简单的Bean</p><ul><li><strong>RedisTemplate</strong></li><li><strong>StringRedisTemplate</strong></li></ul><p>当看到xxTemplate时可以对比RestTemplat、SqlSessionTemplate,通过使用这些Template来间接操作组件。那么这俩也不会例外。分别用于操作Redis和Redis中的String数据类型。</p><p>在RedisTemplate上也有一个条件注解，说明我们是可以对其进行定制化的</p><p>说完这些，我们需要知道如何编写配置文件然后连接Redis，就需要阅读RedisProperties</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513214638238.png" alt="在这里插入图片描述"></p><p>这是一些基本的配置属性。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513214649380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>还有一些连接池相关的配置。注意使用时一定使用Lettuce的连接池。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513214700372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol><li><p>编写配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置redis</span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">39.99.xxx.xx</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="attr">123</span></span><br><span class="line"><span class="attr">1234</span></span><br></pre></td></tr></table></figure></li><li><p>使用RedisTemplate</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Redis02SpringbootApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// redisTemplate 操作不同的数据类型，api和我们的指令是一样的</span></span><br><span class="line">        <span class="comment">// opsForValue 操作字符串 类似String</span></span><br><span class="line">        <span class="comment">// opsForList 操作List 类似List</span></span><br><span class="line">        <span class="comment">// opsForHah</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 除了基本的操作，我们常用的方法都可以直接通过redisTemplate操作，比如事务和基本的CRUD</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取连接对象</span></span><br><span class="line">        <span class="comment">//RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();</span></span><br><span class="line">        <span class="comment">//connection.flushDb();</span></span><br><span class="line">        <span class="comment">//connection.flushAll();</span></span><br><span class="line"></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;mykey&quot;</span>,<span class="string">&quot;kuangshen&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;mykey&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425</span></span><br></pre></td></tr></table></figure></li><li><p>测试结果</p><p><strong>此时我们回到Redis查看数据时候，惊奇发现全是乱码，可是程序中可以正常输出：</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513214734520.png" alt="在这里插入图片描述"></p><p> 这时候就关系到存储对象的序列化问题，在网络中传输的对象也是一样需要序列化，否者就全是乱码。</p><p>我们转到看那个默认的RedisTemplate内部什么样子：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513214746506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>在最开始就能看到几个关于序列化的参数。</p><p>默认的序列化器是采用JDK序列化器</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513214757247.png" alt="在这里插入图片描述"></p><p>而默认的RedisTemplate中的所有序列化器都是使用这个序列化器：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513214809494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>后续我们定制RedisTemplate就可以对其进行修改。</p><p><code>RedisSerializer</code>提供了多种序列化方案：</p><ul><li><p>直接调用RedisSerializer的静态方法来返回序列化器，然后set</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513214818682.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>自己new 相应的实现类，然后set</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513214827233.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul></li><li><p><strong>定制RedisTemplate的模板：</strong></p><p>我们创建一个Bean加入容器，就会触发RedisTemplate上的条件注解使默认的RedisTemplate失效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">        <span class="comment">// 将template 泛型设置为 &lt;String, Object&gt;</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate();</span><br><span class="line">        <span class="comment">// 连接工厂，不必修改</span></span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 序列化设置</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// key、hash的key 采用 String序列化方式</span></span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// value、hash的value 采用 Jackson 序列化方式</span></span><br><span class="line">        template.setValueSerializer(RedisSerializer.json());</span><br><span class="line">        template.setHashValueSerializer(RedisSerializer.json());</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223</span></span><br></pre></td></tr></table></figure><p>这样一来，只要实体类进行了序列化，我们存什么都不会有乱码的担忧了。</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-oc8kJP08-1597890996523)(狂神说 Redis.assets/image-20200817175638086.png)]</p></li></ol><h2 id="八、自定义Redis工具类"><a href="#八、自定义Redis工具类" class="headerlink" title="八、自定义Redis工具类"></a>八、自定义Redis工具类</h2><p>使用RedisTemplate需要频繁调用<code>.opForxxx</code>然后才能进行对应的操作，这样使用起来代码效率低下，工作中一般不会这样使用，而是将这些常用的公共API抽取出来封装成为一个工具类，然后直接使用工具类来间接操作Redis,不但效率高并且易用。</p><p>工具类参考博客：</p><p><a href="https://www.cnblogs.com/zeng1994/p/03303c805731afc9aa9c60dbbd32a323.html">https://www.cnblogs.com/zeng1994/p/03303c805731afc9aa9c60dbbd32a323.html</a></p><p><a href="https://www.cnblogs.com/zhzhlong/p/11434284.html">https://www.cnblogs.com/zhzhlong/p/11434284.html</a></p><h2 id="九、Redis-conf"><a href="#九、Redis-conf" class="headerlink" title="九、Redis.conf"></a>九、Redis.conf</h2><blockquote><p>容量单位不区分大小写，G和GB有区别</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020051321485460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="img"></p><blockquote><p>可以使用 include 组合多个配置问题</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513214902552.png" alt="在这里插入图片描述"></p><blockquote><p>网络配置</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513214912813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>日志输出级别</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513214923678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="img"></p><blockquote><p>日志输出文件</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513214933713.png" alt="在这里插入图片描述"></p><blockquote><p>持久化规则</p></blockquote><p>由于Redis是基于内存的数据库，需要将数据由内存持久化到文件中</p><p>持久化方式：</p><ul><li>RDB</li><li>AOF</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513214944964.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>RDB文件相关</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513214955679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513215006207.png" alt="在这里插入图片描述"></p><blockquote><p>主从复制</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513215016371.png" alt="在这里插入图片描述"></p><blockquote><p>Security模块中进行密码设置</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513215026143.png" alt="在这里插入图片描述"></p><blockquote><p>客户端连接相关</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">maxclients 10000  最大客户端数量</span><br><span class="line">maxmemory &lt;bytes&gt; 最大内存限制</span><br><span class="line">maxmemory-policy noeviction <span class="comment"># 内存达到限制值的处理策略</span></span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>redis 中的<strong>默认</strong>的过期策略是 <strong>volatile-lru</strong> 。</p><p><strong>设置方式</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">config <span class="built_in">set</span> maxmemory-policy volatile-lru </span><br><span class="line">1</span><br></pre></td></tr></table></figure><h4 id="maxmemory-policy-六种方式"><a href="#maxmemory-policy-六种方式" class="headerlink" title="maxmemory-policy 六种方式"></a><strong>maxmemory-policy 六种方式</strong></h4><p><strong>1、volatile-lru：</strong>只对设置了过期时间的key进行LRU（默认值）</p><p><strong>2、allkeys-lru ：</strong> 删除lru算法的key</p><p><strong>3、volatile-random：</strong>随机删除即将过期key</p><p><strong>4、allkeys-random：</strong>随机删除</p><p><strong>5、volatile-ttl ：</strong> 删除即将过期的</p><p><strong>6、noeviction ：</strong> 永不过期，返回错误</p><blockquote><p>AOF相关部分</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513215037918.png" alt="在这里插入图片描述"></p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513215047999.png" alt="在这里插入图片描述"></p><h2 id="十、持久化—RDB"><a href="#十、持久化—RDB" class="headerlink" title="十、持久化—RDB"></a>十、持久化—RDB</h2><p>RDB：Redis Databases</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-C0mm1D4A-1597890996524)(狂神说 Redis.assets/image-20200818122236614.png)]</p><h3 id="什么是RDB"><a href="#什么是RDB" class="headerlink" title="什么是RDB"></a>什么是RDB</h3><hr><p>在指定时间间隔后，将内存中的数据集快照写入数据库 ；在恢复时候，直接读取快照文件，进行数据的恢复 ；</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513215126515.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>默认情况下， Redis 将数据库快照保存在名字为 dump.rdb的二进制文件中。文件名可以在配置文件中进行自定义。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><hr><p>在进行 <strong><code>RDB</code></strong> 的时候，**<code>redis</code>** 的主线程是不会做 <strong><code>io</code></strong> 操作的，主线程会 <strong><code>fork</code></strong> 一个子线程来完成该操作；</p><ol><li>Redis 调用forks。同时拥有父进程和子进程。</li><li>子进程将数据集写入到一个临时 RDB 文件中。</li><li>当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。</li></ol><p>这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益(因为是使用子进程进行写操作，而父进程依然可以接收来自客户端的请求。)</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513215141519.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h3><hr><ol><li>save的规则满足的情况下，会自动触发rdb原则</li><li>执行flushall命令，也会触发我们的rdb原则</li><li>退出redis，也会自动产生rdb文件</li></ol><h4 id="save"><a href="#save" class="headerlink" title="save"></a>save</h4><p>使用 <code>save</code> 命令，会立刻对当前内存中的数据进行持久化 ,但是会阻塞，也就是不接受其他操作了；</p><blockquote><p>由于 <code>save</code> 命令是同步命令，会占用Redis的主进程。若Redis数据非常多时，<code>save</code>命令执行速度会非常慢，阻塞所有客户端的请求。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513215150892.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="flushall命令"><a href="#flushall命令" class="headerlink" title="flushall命令"></a>flushall命令</h4><p><code>flushall</code> 命令也会触发持久化 ；</p><h4 id="触发持久化规则"><a href="#触发持久化规则" class="headerlink" title="触发持久化规则"></a>触发持久化规则</h4><p>满足配置条件中的触发条件 ；</p><blockquote><p>可以通过配置文件对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动进行数据集保存操作。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513215205970.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513215220858.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="bgsave"><a href="#bgsave" class="headerlink" title="bgsave"></a>bgsave</h4><p><code>bgsave</code> 是异步进行，进行持久化的时候，<code>redis</code> 还可以将继续响应客户端请求 ；</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020051321523151.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>bgsave和save对比</strong></p><table><thead><tr><th>命令</th><th>save</th><th>bgsave</th></tr></thead><tbody><tr><td>IO类型</td><td>同步</td><td>异步</td></tr><tr><td>阻塞？</td><td>是</td><td>是（阻塞发生在fock()，通常非常快）</td></tr><tr><td>复杂度</td><td>O(n)</td><td>O(n)</td></tr><tr><td>优点</td><td>不会消耗额外的内存</td><td>不阻塞客户端命令</td></tr><tr><td>缺点</td><td>阻塞客户端命令</td><td>需要fock子进程，消耗内存</td></tr></tbody></table><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点：</strong></p><ol><li>适合大规模的数据恢复</li><li>对数据的完整性要求不高</li></ol><p><strong>缺点：</strong></p><ol><li>需要一定的时间间隔进行操作，如果redis意外宕机了，这个最后一次修改的数据就没有了。</li><li>fork进程的时候，会占用一定的内容空间。</li></ol><h2 id="十一、持久化AOF"><a href="#十一、持久化AOF" class="headerlink" title="十一、持久化AOF"></a>十一、持久化AOF</h2><p><strong>Append Only File</strong></p><p>将我们所有的命令都记录下来，history，恢复的时候就把这个文件全部再执行一遍</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Z8wr9lBW-1597890996525)(狂神说 Redis.assets/image-20200818123711375.png)]</p><blockquote><p>以日志的形式来记录每个写的操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p></blockquote><h3 id="什么是AOF"><a href="#什么是AOF" class="headerlink" title="什么是AOF"></a>什么是AOF</h3><p> 快照功能（RDB）并不是非常耐久（durable）： 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、以及未保存到快照中的那些数据。 从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化。</p><p>如果要使用AOF，需要修改配置文件：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513215247113.png" alt="在这里插入图片描述"></p><p><code>appendonly no yes</code>则表示启用AOF</p><p>默认是不开启的，我们需要手动配置，然后重启redis，就可以生效了！</p><p>如果这个aof文件有错位，这时候redis是启动不起来的，我需要修改这个aof文件</p><p>redis给我们提供了一个工具<code>redis-check-aof --fix</code></p><blockquote><p>优点和缺点</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes  <span class="comment"># 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分的情况下，rdb完全够用</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># appendfsync always # 每次修改都会sync 消耗性能</span></span><br><span class="line">appendfsync everysec <span class="comment"># 每秒执行一次 sync 可能会丢失这一秒的数据</span></span><br><span class="line"><span class="comment"># appendfsync no # 不执行 sync ,这时候操作系统自己同步数据，速度最快</span></span><br><span class="line">123456</span><br></pre></td></tr></table></figure><p><strong>优点</strong></p><ol><li>每一次修改都会同步，文件的完整性会更加好</li><li>没秒同步一次，可能会丢失一秒的数据</li><li>从不同步，效率最高</li></ol><p><strong>缺点</strong></p><ol><li>相对于数据文件来说，aof远远大于rdb，修复速度比rdb慢！</li><li>Aof运行效率也要比rdb慢，所以我们redis默认的配置就是rdb持久化</li></ol><h2 id="十二、RDB和AOP选择"><a href="#十二、RDB和AOP选择" class="headerlink" title="十二、RDB和AOP选择"></a>十二、RDB和AOP选择</h2><h3 id="RDB-和-AOF-对比"><a href="#RDB-和-AOF-对比" class="headerlink" title="RDB 和 AOF 对比"></a>RDB 和 AOF 对比</h3><table><thead><tr><th>RDB</th><th>AOF</th><th></th></tr></thead><tbody><tr><td>启动优先级</td><td>低</td><td>高</td></tr><tr><td>体积</td><td>小</td><td>大</td></tr><tr><td>恢复速度</td><td>快</td><td>慢</td></tr><tr><td>数据安全性</td><td>丢数据</td><td>根据策略决定</td></tr></tbody></table><h3 id="如何选择使用哪种持久化方式？"><a href="#如何选择使用哪种持久化方式？" class="headerlink" title="如何选择使用哪种持久化方式？"></a>如何选择使用哪种持久化方式？</h3><p>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。</p><p>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。</p><p>有很多用户都只使用 AOF 持久化， 但并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快。</p><h2 id="十三、Redis发布与订阅"><a href="#十三、Redis发布与订阅" class="headerlink" title="十三、Redis发布与订阅"></a>十三、Redis发布与订阅</h2><p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-IBT2pjCa-1597890996526)(狂神说 Redis.assets/image-20200818162849693.png)]</p><p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513215523258.png" alt="在这里插入图片描述"></p><p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020051321553483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>PSUBSCRIBE pattern [pattern..]</code></td><td>订阅一个或多个符合给定模式的频道。</td></tr><tr><td><code>PUNSUBSCRIBE pattern [pattern..]</code></td><td>退订一个或多个符合给定模式的频道。</td></tr><tr><td><code>PUBSUB subcommand [argument[argument]]</code></td><td>查看订阅与发布系统状态。</td></tr><tr><td><code>PUBLISH channel message</code></td><td>向指定频道发布消息</td></tr><tr><td><code>SUBSCRIBE channel [channel..]</code></td><td>订阅给定的一个或多个频道。</td></tr><tr><td><code>SUBSCRIBE channel [channel..]</code></td><td>退订一个或多个频道</td></tr></tbody></table><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">------------订阅端----------------------</span><br><span class="line">127.0.0.1:6379&gt; SUBSCRIBE sakura <span class="comment"># 订阅sakura频道</span></span><br><span class="line">Reading messages... (press Ctrl-C to quit) <span class="comment"># 等待接收消息</span></span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span> <span class="comment"># 订阅成功的消息</span></span><br><span class="line">2) <span class="string">&quot;sakura&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line">1) <span class="string">&quot;message&quot;</span> <span class="comment"># 接收到来自sakura频道的消息 &quot;hello world&quot;</span></span><br><span class="line">2) <span class="string">&quot;sakura&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello world&quot;</span></span><br><span class="line">1) <span class="string">&quot;message&quot;</span> <span class="comment"># 接收到来自sakura频道的消息 &quot;hello i am sakura&quot;</span></span><br><span class="line">2) <span class="string">&quot;sakura&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello i am sakura&quot;</span></span><br><span class="line"></span><br><span class="line">--------------消息发布端-------------------</span><br><span class="line">127.0.0.1:6379&gt; PUBLISH sakura <span class="string">&quot;hello world&quot;</span> <span class="comment"># 发布消息到sakura频道</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; PUBLISH sakura <span class="string">&quot;hello i am sakura&quot;</span> <span class="comment"># 发布消息</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">-----------------查看活跃的频道------------</span><br><span class="line">127.0.0.1:6379&gt; PUBSUB channels</span><br><span class="line">1) <span class="string">&quot;sakura&quot;</span></span><br><span class="line">12345678910111213141516171819202122</span><br></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>每个 Redis 服务器进程都维持着一个表示服务器状态的 redis.h/redisServer 结构， 结构的 pubsub_channels 属性是一个字典， 这个字典就用于保存订阅频道的信息，其中，字典的键为正在被订阅的频道， 而字典的值则是一个链表， 链表中保存了所有订阅这个频道的客户端。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020051321554964.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>客户端订阅，就被链接到对应频道的链表的尾部，退订则就是将客户端节点从链表中移除。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>如果一个客户端订阅了频道，但自己读取消息的速度却不够快的话，那么不断积压的消息会使redis输出缓冲区的体积变得越来越大，这可能使得redis本身的速度变慢，甚至直接崩溃。</li><li>这和数据传输可靠性有关，如果在订阅方断线，那么他将会丢失所有在短线期间发布者发布的消息。</li></ol><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ol><li>消息订阅：公众号订阅，微博关注等等（起始更多是使用消息队列来进行实现）</li><li>多人在线聊天室。</li></ol><p>稍微复杂的场景，我们就会使用消息中间件MQ处理。</p><h2 id="十四、Redis主从复制"><a href="#十四、Redis主从复制" class="headerlink" title="十四、Redis主从复制"></a>十四、Redis主从复制</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p> 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点（Master/Leader）,后者称为从节点（Slave/Follower）， 数据的复制是单向的！只能由主节点复制到从节点（主节点以写为主、从节点以读为主）。</p><p>默认情况下，每台Redis服务器都是主节点，一个主节点可以有0个或者多个从节点，但每个从节点只能由一个主节点。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余的方式。</li><li>故障恢复：当主节点故障时，从节点可以暂时替代主节点提供服务，是一种服务冗余的方式</li><li>负载均衡：在主从复制的基础上，配合读写分离，由主节点进行写操作，从节点进行读操作，分担服务器的负载；尤其是在多读少写的场景下，通过多个从节点分担负载，提高并发量。</li><li>高可用基石：主从复制还是哨兵和集群能够实施的基础。</li></ol><h3 id="为什么使用集群"><a href="#为什么使用集群" class="headerlink" title="为什么使用集群"></a>为什么使用集群</h3><ol><li>单台服务器难以负载大量的请求</li><li>单台服务器故障率高，系统崩坏概率大</li><li>单台服务器内存容量有限。</li></ol><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>我们在讲解配置文件的时候，注意到有一个<code>replication</code>模块 (见Redis.conf中第8条)</p><p>查看当前库的信息：<code>info replication</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master <span class="comment"># 角色</span></span><br><span class="line">connected_slaves:0 <span class="comment"># 从机数量</span></span><br><span class="line">master_replid:3b54deef5b7b7b7f7dd8acefa23be48879b4fcff</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br><span class="line">123456789101112</span><br></pre></td></tr></table></figure><p>既然需要启动多个服务，就需要多个配置文件。每个配置文件对应修改以下信息：</p><ul><li>端口号</li><li>pid文件名</li><li>日志文件名</li><li>rdb文件名</li></ul><p>启动单机多服务集群：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513215610163.png" alt="在这里插入图片描述"></p><h3 id="一主二从配置"><a href="#一主二从配置" class="headerlink" title="一主二从配置"></a>一主二从配置</h3><p>==默认情况下，每台Redis服务器都是主节点；==我们一般情况下只用配置从机就好了！</p><p>认老大！一主（79）二从（80，81）</p><p>使用<code>SLAVEOF host port</code>就可以为从机配置主机了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513215637483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>然后主机上也能看到从机的状态：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513215645778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>我们这里是使用命令搭建，是暂时的，==真实开发中应该在从机的配置文件中进行配置，==这样的话是永久的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513215654634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h3><ol><li><p>从机只能读，不能写，主机可读可写但是多用于写。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> 127.0.0.1:6381&gt; <span class="built_in">set</span> name sakura <span class="comment"># 从机6381写入失败</span></span><br><span class="line">(error) READONLY You can<span class="string">&#x27;t write against a read only replica.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">127.0.0.1:6380&gt; set name sakura # 从机6380写入失败</span></span><br><span class="line"><span class="string">(error) READONLY You can&#x27;</span>t write against a <span class="built_in">read</span> only replica.</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name sakura</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">&quot;sakura&quot;</span></span><br><span class="line">12345678910</span><br></pre></td></tr></table></figure></li><li><p>当主机断电宕机后，默认情况下从机的角色不会发生变化 ，集群中只是失去了写操作，当主机恢复以后，又会连接上从机恢复原状。</p></li><li><p>当从机断电宕机后，若不是使用配置文件配置的从机，再次启动后作为主机是无法获取之前主机的数据的，若此时重新配置称为从机，又可以获取到主机的所有数据。这里就要提到一个同步原理。</p></li><li><p>第二条中提到，默认情况下，主机故障后，不会出现新的主机，有两种方式可以产生新的主机：</p><ul><li>从机手动执行命令<code>slaveof no one</code>,这样执行以后从机会独立出来成为一个主机</li><li>使用哨兵模式（自动选举）</li></ul></li></ol><blockquote><p>如果没有老大了，这个时候能不能选择出来一个老大呢？手动！</p></blockquote><p>如果主机断开了连接，我们可以使用<code>SLAVEOF no one</code>让自己变成主机！其他的节点就可以手动连接到最新的主节点（手动）！如果这个时候老大修复了，那么久重新连接！</p><h2 id="十五、哨兵模式"><a href="#十五、哨兵模式" class="headerlink" title="十五、哨兵模式"></a>十五、哨兵模式</h2><p>更多信息参考博客：<a href="https://www.jianshu.com/p/06ab9daf921d">https://www.jianshu.com/p/06ab9daf921d</a></p><p><strong>主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。\</strong>这不是一种推荐的方式，更多时候，我们优先考虑**哨兵模式**。</p><p>单机单个哨兵</p><p><img src= "/img/loading.gif" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMTMyMDAzOS01N2E3N2NhMjc1N2QwOTI0LnBuZw?x-oss-process=image/format,png" alt="img"></p><p>哨兵的作用：</p><ul><li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。</li><li>当哨兵监测到master宕机，会自动将slave切换成master，然后通过<strong>发布订阅模式</strong>通知其他的从服务器，修改配置文件，让它们切换主机。</li></ul><p>多哨兵模式</p><p><img src= "/img/loading.gif" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMTMyMDAzOS0zZjQwYjE3YzA0MTIxMTZjLnBuZw?x-oss-process=image/format,png" alt="img"></p><p>哨兵的核心配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster 127.0.0.1 6379</span><br><span class="line">1</span><br></pre></td></tr></table></figure><ul><li>数字1表示 ：当一个哨兵主观认为主机断开，就可以客观认为主机故障，然后开始选举新的主机。</li></ul><blockquote><p>测试</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel xxx&#x2F;sentinel.conf</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>成功启动哨兵模式</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513215752444.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>此时哨兵监视着我们的主机6379，当我们断开主机后：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513215806972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>哨兵模式优缺点</p></blockquote><p><strong>优点：</strong></p><ol><li>哨兵集群，基于主从复制模式，所有主从复制的优点，它都有</li><li>主从可以切换，故障可以转移，系统的可用性更好</li><li>哨兵模式是主从模式的升级，手动到自动，更加健壮</li></ol><p><strong>缺点：</strong></p><ol><li>Redis不好在线扩容，集群容量一旦达到上限，在线扩容就十分麻烦</li><li>实现哨兵模式的配置其实是很麻烦的，里面有很多配置项</li></ol><blockquote><p>哨兵模式的全部配置</p></blockquote><p>完整的哨兵模式配置文件 sentinel.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example sentinel.conf</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 哨兵sentinel实例运行的端口 默认26379</span></span><br><span class="line">port 26379</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 哨兵sentinel的工作目录</span></span><br><span class="line">dir /tmp</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 哨兵sentinel监控的redis主节点的 ip port </span></span><br><span class="line"><span class="comment"># master-name  可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。</span></span><br><span class="line"><span class="comment"># quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了</span></span><br><span class="line"><span class="comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 1</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</span></span><br><span class="line"><span class="comment"># 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span></span><br><span class="line"><span class="comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br><span class="line">sentinel auth-pass mymaster MySUPER--secret-0123passw0rd</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span></span><br><span class="line"><span class="comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，</span></span><br><span class="line">这个数字越小，完成failover所需的时间就越长，</span><br><span class="line">但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。</span><br><span class="line">可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span><br><span class="line"><span class="comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 故障转移的超时时间 failover-timeout 可以用在以下这些方面： </span></span><br><span class="line"><span class="comment">#1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span></span><br><span class="line"><span class="comment">#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</span></span><br><span class="line"><span class="comment">#3.当想要取消一个正在进行的failover所需要的时间。  </span></span><br><span class="line"><span class="comment">#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span></span><br><span class="line"><span class="comment"># 默认三分钟</span></span><br><span class="line"><span class="comment"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"> </span><br><span class="line"><span class="comment"># SCRIPTS EXECUTION</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。</span></span><br><span class="line"><span class="comment">#对于脚本的运行结果有以下规则：</span></span><br><span class="line"><span class="comment">#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span></span><br><span class="line"><span class="comment">#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span></span><br><span class="line"><span class="comment">#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span></span><br><span class="line"><span class="comment">#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，</span></span><br><span class="line"><span class="comment">#这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，</span></span><br><span class="line"><span class="comment">#一个是事件的类型，</span></span><br><span class="line"><span class="comment">#一个是事件的描述。</span></span><br><span class="line"><span class="comment">#如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span></span><br><span class="line"><span class="comment">#通知脚本</span></span><br><span class="line"><span class="comment"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">  sentinel notification-script mymaster /var/redis/notify.sh</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 客户端重新配置主节点参数脚本</span></span><br><span class="line"><span class="comment"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span></span><br><span class="line"><span class="comment"># 以下参数将会在调用脚本时传给脚本:</span></span><br><span class="line"><span class="comment"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span></span><br><span class="line"><span class="comment"># 目前&lt;state&gt;总是“failover”,</span></span><br><span class="line"><span class="comment"># &lt;role&gt;是“leader”或者“observer”中的一个。 </span></span><br><span class="line"><span class="comment"># 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的</span></span><br><span class="line"><span class="comment"># 这个脚本应该是通用的，能被多次调用，不是针对性的。</span></span><br><span class="line"><span class="comment"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</span><br><span class="line"></span><br><span class="line">1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071</span><br></pre></td></tr></table></figure><h2 id="十六、缓存穿透与雪崩"><a href="#十六、缓存穿透与雪崩" class="headerlink" title="十六、缓存穿透与雪崩"></a>十六、缓存穿透与雪崩</h2><h3 id="缓存穿透（查不到）"><a href="#缓存穿透（查不到）" class="headerlink" title="缓存穿透（查不到）"></a>缓存穿透（查不到）</h3><blockquote><p>概念</p></blockquote><p>在默认情况下，用户请求数据时，会先在缓存(Redis)中查找，若没找到即缓存未命中，再在数据库中进行查找，数量少可能问题不大，可是一旦大量的请求数据（例如秒杀场景）缓存都没有命中的话，就会全部转移到数据库上，造成数据库极大的压力，就有可能导致数据库崩溃。网络安全中也有人恶意使用这种手段进行攻击被称为洪水攻击。</p><blockquote><p>解决方案</p></blockquote><p><strong>布隆过滤器</strong></p><p>对所有可能查询的参数以Hash的形式存储，以便快速确定是否存在这个值，在控制层先进行拦截校验，校验不通过直接打回，减轻了存储系统的压力。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513215824722.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>缓存空对象</strong></p><p>一次请求若在缓存和数据库中都没找到，就在缓存中方一个空对象用于处理后续这个请求。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513215836317.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p> 这样做有一个缺陷：存储空对象也需要空间，大量的空对象会耗费一定的空间，存储效率并不高。解决这个缺陷的方式就是设置较短过期时间</p><p>即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</p><h3 id="缓存击穿（量太大，缓存过期）"><a href="#缓存击穿（量太大，缓存过期）" class="headerlink" title="缓存击穿（量太大，缓存过期）"></a>缓存击穿（量太大，缓存过期）</h3><blockquote><p>概念</p></blockquote><p> 相较于缓存穿透，缓存击穿的目的性更强，一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。这就是缓存被击穿，只是针对其中某个key的缓存不可用而导致击穿，但是其他的key依然可以使用缓存响应。</p><p> 比如热搜排行上，一个热点新闻被同时大量访问就可能导致缓存击穿。</p><blockquote><p>解决方案</p></blockquote><ol><li><p><strong>设置热点数据永不过期</strong></p><p>这样就不会出现热点数据过期的情况，但是当Redis内存空间满的时候也会清理部分数据，而且此种方案会占用空间，一旦热点数据多了起来，就会占用部分空间。</p></li><li><p><strong>加互斥锁(分布式锁)</strong></p><p>在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。保证同时刻只有一个线程访问。这样对锁的要求就十分高。</p></li></ol><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><blockquote><p>概念</p></blockquote><p>大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513215850428.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>解决方案</p></blockquote><ul><li><p>redis高可用</p><p>这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群</p></li><li><p>限流降级</p><p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p></li><li><p>数据预热</p><p>数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p></li></ul><p>出处：<a href="https://blog.csdn.net/weixin_43873227/article/details/106107270">https://blog.csdn.net/weixin_43873227/article/details/106107270</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Nosql概述&quot;&gt;&lt;a href=&quot;#一、Nosql概述&quot; class=&quot;headerlink&quot; title=&quot;一、Nosql概述&quot;&gt;&lt;/a&gt;一、Nosql概述&lt;/h1&gt;&lt;h2 id=&quot;1、单机Mysql时代&quot;&gt;&lt;a href=&quot;#1、单机Mysql时代&quot; c</summary>
      
    
    
    
    <category term="Redis" scheme="https://cddorz.github.io/categories/Redis/"/>
    
    
    <category term="数据库" scheme="https://cddorz.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>少年二字，应与平庸相斥</title>
    <link href="https://cddorz.github.io/2020/11/10/%E5%B0%91%E5%B9%B4%E4%BA%8C%E5%AD%97%EF%BC%8C%E5%BA%94%E4%B8%8E%E5%B9%B3%E5%BA%B8%E7%9B%B8%E6%96%A5/"/>
    <id>https://cddorz.github.io/2020/11/10/%E5%B0%91%E5%B9%B4%E4%BA%8C%E5%AD%97%EF%BC%8C%E5%BA%94%E4%B8%8E%E5%B9%B3%E5%BA%B8%E7%9B%B8%E6%96%A5/</id>
    <published>2020-11-10T08:49:30.000Z</published>
    <updated>2021-01-12T05:08:23.317Z</updated>
    
    <content type="html"><![CDATA[<h2 id="听闻少年二字，应与平庸相斥。"><a href="#听闻少年二字，应与平庸相斥。" class="headerlink" title="听闻少年二字，应与平庸相斥。"></a>听闻少年二字，应与平庸相斥。</h2><p>​        以后会走上怎样的道路尚不确定，只知年少的我们，生活中有诗歌和远方，脚下有坚实的土地，头顶有浩瀚的星空。宁欺白须公，莫欺少年穷，我们有着无限的可能性。</p><p>​        在高中，总有人在你身后催促着你前进，奔跑途中，身边也是与你一起冲向梦想的同学，但到了大学，似乎一切都变了。一个人在外，没有人在你身后看着你，身边的人也有了各自的目标和方向，大一的我迷茫了……</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-585af38a5f78e8a4fb027f998ac84df2_720w.jpg?source=1940ef5c" alt="img"></p><p>​        大一上，我上课玩手机，回寝室也是玩手机。点外卖，瘫坐在吊椅上无所事事，成了常态，看着室友自律的样子，也曾想做出过改变，但还是挡不住外在的诱惑（也许还幼稚），就这样浑浑噩噩的过了半年，最终成绩也只是中等。大一下，疫情爆发了，不得不在家里上网课，这导致我更加肆无忌惮的放松自己，慢性死亡，上网课没精神，看小说，几乎不出屋子，时时刻刻都在床上。这就是我的大一。</p><p>​        大二上，惊讶的发现室友有了惊天的变化，在我慢性死亡的时候，他有了自己的目标，并且为此做出了巨大的改变和努力，coding能力变得很强（发量可以看出），自己去加了学校的工作室，做了很多的业务，也得了很多的奖，那时，我才懂，他已经站在了只有少部分人站的高处，所以我也做出了改变，想清自己想要什么。现在的我，也算是刚刚起步，跳出了自己的舒适圈，<strong>希望自己能越来越好，上进且不平庸，不白来世间一趟</strong>，谨以此文激励自己。</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic3.zhimg.com/80/v2-65bedd063f12030d068046b72e425e08_720w.jpg?source=1940ef5c" alt="img"></p><p><strong>你本来就是太阳，无需凭借谁的光。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;听闻少年二字，应与平庸相斥。&quot;&gt;&lt;a href=&quot;#听闻少年二字，应与平庸相斥。&quot; class=&quot;headerlink&quot; title=&quot;听闻少年二字，应与平庸相斥。&quot;&gt;&lt;/a&gt;听闻少年二字，应与平庸相斥。&lt;/h2&gt;&lt;p&gt;​        以后会走上怎样的道路尚不确</summary>
      
    
    
    
    <category term="日常" scheme="https://cddorz.github.io/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="少年" scheme="https://cddorz.github.io/tags/%E5%B0%91%E5%B9%B4/"/>
    
  </entry>
  
  <entry>
    <title>Java集合框架</title>
    <link href="https://cddorz.github.io/2020/11/06/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    <id>https://cddorz.github.io/2020/11/06/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</id>
    <published>2020-11-06T07:33:44.000Z</published>
    <updated>2020-11-12T03:46:54.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-集合框架"><a href="#Java-集合框架" class="headerlink" title="Java 集合框架"></a>Java 集合框架</h1><p><img src= "/img/loading.gif" data-lazy-src="https://www.runoob.com/wp-content/uploads/2014/01/2243690-9cd9c896e0d512ed.gif" alt="img"></p><ul><li><strong>接口：</strong>是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象</li><li><strong>实现（类）：</strong>是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。</li><li><strong>算法：</strong>是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。</li></ul><h4 id="一、Set和List的区别："><a href="#一、Set和List的区别：" class="headerlink" title="一、Set和List的区别："></a>一、Set和List的区别：</h4><ul><li>Set 接口实例存储的是无序的，不重复的数据。List 接口实例存储的是有序的，可以重复的元素</li><li> Set检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 <strong>&lt;实现类有HashSet,TreeSet&gt;</strong></li><li>List和数组类似，可以动态增长，根据实际存储的数据的长度自动增长List的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变 <strong>&lt;实现类有ArrayList,LinkedList,Vector&gt;</strong> </li></ul><h4 id="二、如何使用迭代器："><a href="#二、如何使用迭代器：" class="headerlink" title="二、如何使用迭代器："></a>二、如何使用迭代器：</h4><h5 id="遍历-ArrayList"><a href="#遍历-ArrayList" class="headerlink" title="遍历 ArrayList"></a>遍历 ArrayList</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">     list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">     list.add(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">     list.add(<span class="string">&quot;HAHAHAHA&quot;</span>);</span><br><span class="line">     <span class="comment">//第一种遍历方法使用 For-Each 遍历 List</span></span><br><span class="line">     <span class="keyword">for</span> (String str : list) &#123;            <span class="comment">//也可以改写 for(int i=0;i&lt;list.size();i++) 这种形式</span></span><br><span class="line">        System.out.println(str);</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//第二种遍历，把链表变为数组相关的内容进行遍历</span></span><br><span class="line">     String[] strArray=<span class="keyword">new</span> String[list.size()];</span><br><span class="line">     list.toArray(strArray);</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strArray.length;i++) <span class="comment">//这里也可以改写为  for(String str:strArray) 这种形式</span></span><br><span class="line">     &#123;</span><br><span class="line">        System.out.println(strArray[i]);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//第三种遍历 使用迭代器进行相关遍历,该方法可以不用担心在遍历的过程中会超出集合的长度。</span></span><br><span class="line">     </span><br><span class="line">     Iterator&lt;String&gt; ite=list.iterator();</span><br><span class="line">     <span class="keyword">while</span>(ite.hasNext())<span class="comment">//判断下一个元素之后有值</span></span><br><span class="line">     &#123;</span><br><span class="line">         System.out.println(ite.next());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="遍历-Map"><a href="#遍历-Map" class="headerlink" title="遍历 Map"></a>遍历 Map</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">      map.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">      map.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">      map.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;value3&quot;</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//第一种：普遍使用，二次取值</span></span><br><span class="line">      System.out.println(<span class="string">&quot;通过Map.keySet遍历key和value：&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;key= &quot;</span>+ key + <span class="string">&quot; and value= &quot;</span> + map.get(key));</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//第二种</span></span><br><span class="line">      System.out.println(<span class="string">&quot;通过Map.entrySet使用iterator遍历key和value：&quot;</span>);</span><br><span class="line">      Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line">      <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">       Map.Entry&lt;String, String&gt; entry = it.next();</span><br><span class="line">       System.out.println(<span class="string">&quot;key= &quot;</span> + entry.getKey() + <span class="string">&quot; and value= &quot;</span> + entry.getValue());</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//第三种：推荐，尤其是容量大时</span></span><br><span class="line">      System.out.println(<span class="string">&quot;通过Map.entrySet遍历key和value&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;key= &quot;</span> + entry.getKey() + <span class="string">&quot; and value= &quot;</span> + entry.getValue());</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">//第四种</span></span><br><span class="line">      System.out.println(<span class="string">&quot;通过Map.values()遍历所有的value，但不能遍历key&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (String v : map.values()) &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;value= &quot;</span> + v);</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、ArrayList"><a href="#三、ArrayList" class="headerlink" title="三、ArrayList"></a>三、ArrayList</h4><p>ArrayList类是一个可以动态修改的副本，与普通副本的区别就是它是没有固定大小的限制，我们可以添加或删除元素。</p><h6 id="1、基本实现"><a href="#1、基本实现" class="headerlink" title="1、基本实现"></a>1、基本实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunoobTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; sites = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        sites.add(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Weibo&quot;</span>);</span><br><span class="line">        System.out.println(sites);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="2、常用方法"><a href="#2、常用方法" class="headerlink" title="2、常用方法"></a>2、常用方法</h6><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/java/java-arraylist-add.html">add()</a></td><td>将元素插入到指定位置的 arraylist 中</td></tr><tr><td><a href="https://www.runoob.com/java/java-arraylist-get.html">get()</a></td><td>通过索引值获取 arraylist 中的元素</td></tr><tr><td><a href="https://www.runoob.com/java/java-arraylist-remove.html">remove()</a></td><td>删除 arraylist 里的单个元素</td></tr><tr><td><a href="https://www.runoob.com/java/java-arraylist-size.html">size()</a></td><td>返回 arraylist 里元素数量</td></tr><tr><td><a href="https://www.runoob.com/java/java-arraylist-set.html">set()</a></td><td>替换 arraylist 中指定索引的元素</td></tr><tr><td><a href="https://www.runoob.com/java/java-arraylist-tostring.html">toString()</a></td><td>将 arraylist 转换为字符串</td></tr></tbody></table><h4 id="四、LinkedList"><a href="#四、LinkedList" class="headerlink" title="四、LinkedList"></a>四、LinkedList</h4><p>链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的地址。</p><p>链表可分为单向链表和双向链表。</p><p>一个单向链表包含两个值: 当前节点的值和一个指向下一个节点的链接。</p><p><img src= "/img/loading.gif" data-lazy-src="https://www.runoob.com/wp-content/uploads/2020/06/408px-Singly-linked-list.svg_.png" alt="img"></p><p>一个双向链表有三个整数值: 数值、向后的节点链接、向前的节点链接。</p><p><img src= "/img/loading.gif" data-lazy-src="https://www.runoob.com/wp-content/uploads/2020/06/610px-Doubly-linked-list.svg_.png" alt="img"></p><p>Java LinkedList（链表） 类似于 ArrayList，是一种常用的数据容器。</p><p>与 ArrayList 相比，LinkedList 的增加和删除对操作效率更高，而查找和修改的操作效率较低。</p><p><strong>以下情况使用 ArrayList :</strong></p><ul><li>频繁访问列表中的某一个元素。</li><li>只需要在列表末尾进行添加和删除元素操作。</li></ul><p><strong>以下情况使用 LinkedList :</strong></p><ul><li>你需要通过循环迭代来访问列表中的某些元素。</li><li>需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作。</li></ul><h6 id="1、创建一个简单的链表实例"><a href="#1、创建一个简单的链表实例" class="headerlink" title="1、创建一个简单的链表实例"></a>1、创建一个简单的链表实例</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunoobTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; sites = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        sites.add(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Weibo&quot;</span>);</span><br><span class="line">        System.out.println(sites);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="2、常用方法-1"><a href="#2、常用方法-1" class="headerlink" title="2、常用方法"></a>2、常用方法</h6><table><thead><tr><th align="left">方法</th><th>描述</th></tr></thead><tbody><tr><td align="left">public int size()</td><td>返回链表元素个数。</td></tr><tr><td align="left">public E set(int index, E element)</td><td>设置指定位置的元素。</td></tr><tr><td align="left">public Object clone()</td><td>克隆该列表。</td></tr><tr><td align="left">public boolean add(E e)</td><td>链表末尾添加元素，返回是否成功，成功为 true，失败为 false。</td></tr><tr><td align="left">public void add(int index, E element)</td><td>向指定位置插入元素。</td></tr><tr><td align="left">public void addFirst(E e)</td><td>元素添加到头部</td></tr><tr><td align="left">public boolean offer(E e)</td><td>向链表末尾添加元素，返回是否成功，成功为 true，失败为 false。</td></tr><tr><td align="left">public void clear()</td><td>清空链表。</td></tr><tr><td align="left">public boolean remove(Object o)</td><td>删除某一元素，返回是否成功，成功为 true，失败为 false。</td></tr><tr><td align="left">public E remove(int index)</td><td>删除指定位置的元素。</td></tr><tr><td align="left">public E remove()</td><td>删除并返回第一个元素。</td></tr><tr><td align="left">public E get(int index)</td><td>返回指定位置的元素。</td></tr></tbody></table><h4 id="五、HashMap"><a href="#五、HashMap" class="headerlink" title="五、HashMap"></a>五、HashMap</h4><h6 id="1、基本内容："><a href="#1、基本内容：" class="headerlink" title="1、基本内容："></a>1、基本内容：</h6><p>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。</p><p>HashMap 实现了 Map 接口，根据键的 HashCode 值存储数据，具有很快的访问速度，最多允许一条记录的键为 null，不支持线程同步。</p><p>HashMap 是无序的，即不会记录插入的顺序。</p><p>HashMap 继承于AbstractMap，实现了 Map、Cloneable、java.io.Serializable 接口。</p><h6 id="2、HashMap-的-key-与-value-类型可以相同也可以不同，可以是字符串（String）类型的-key-和-value，也可以是整型（Integer）的-key-和字符串（String）类型的-value。"><a href="#2、HashMap-的-key-与-value-类型可以相同也可以不同，可以是字符串（String）类型的-key-和-value，也可以是整型（Integer）的-key-和字符串（String）类型的-value。" class="headerlink" title="2、HashMap 的 key 与 value 类型可以相同也可以不同，可以是字符串（String）类型的 key 和 value，也可以是整型（Integer）的 key 和字符串（String）类型的 value。"></a>2、HashMap 的 key 与 value 类型可以相同也可以不同，可以是字符串（String）类型的 key 和 value，也可以是整型（Integer）的 key 和字符串（String）类型的 value。</h6><h6 id="3、HashMap-中的元素实际上是对象，一些常见的基本类型可以使用它的包装类。"><a href="#3、HashMap-中的元素实际上是对象，一些常见的基本类型可以使用它的包装类。" class="headerlink" title="3、HashMap 中的元素实际上是对象，一些常见的基本类型可以使用它的包装类。"></a>3、HashMap 中的元素实际上是对象，一些常见的基本类型可以使用它的包装类。</h6><table><thead><tr><th>基本类型</th><th>引用类型</th></tr></thead><tbody><tr><td>boolean</td><td>Boolean</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character</td></tr></tbody></table><h6 id="4、例："><a href="#4、例：" class="headerlink" title="4、例："></a>4、例：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 HashMap 类      </span></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunoobTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 HashMap 对象 Sites</span></span><br><span class="line">        HashMap&lt;Integer, String&gt; Sites = <span class="keyword">new</span> HashMap&lt;Integer, String&gt;();</span><br><span class="line">        <span class="comment">// 添加键值对</span></span><br><span class="line">        Sites.put(<span class="number">1</span>, <span class="string">&quot;Google&quot;</span>);</span><br><span class="line">        Sites.put(<span class="number">2</span>, <span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">        Sites.put(<span class="number">3</span>, <span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">        Sites.put(<span class="number">4</span>, <span class="string">&quot;Zhihu&quot;</span>);</span><br><span class="line">        System.out.println(Sites);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：&#123;1=Google, 2=Runoob, 3=Taobao, 4=Zhihu&#125;</span></span><br></pre></td></tr></table></figure><h6 id="5、常用方法："><a href="#5、常用方法：" class="headerlink" title="5、常用方法："></a>5、常用方法：</h6><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/java/java-hashmap-clear.html">clear()</a></td><td>删除 hashMap 中的所有键/值对</td></tr><tr><td><a href="https://www.runoob.com/java/java-hashmap-clone.html">clone()</a></td><td>复制一份 hashMap</td></tr><tr><td><a href="https://www.runoob.com/java/java-hashmap-isempty.html">isEmpty()</a></td><td>判断 hashMap 是否为空</td></tr><tr><td><a href="https://www.runoob.com/java/java-hashmap-size.html">size()</a></td><td>计算 hashMap 中键/值对的数量</td></tr><tr><td><a href="https://www.runoob.com/java/java-hashmap-put.html">put()</a></td><td>将键/值对添加到 hashMap 中</td></tr><tr><td><a href="https://www.runoob.com/java/java-hashmap-remove.html">remove()</a></td><td>删除 hashMap 中指定键 key 的映射关系</td></tr><tr><td><a href="https://www.runoob.com/java/java-hashmap-replace.html">replace()</a></td><td>替换 hashMap 中是指定的 key 对应的 value。</td></tr><tr><td><a href="https://www.runoob.com/java/java-hashmap-get.html">get()</a></td><td>获取指定 key 对应对 value</td></tr><tr><td><a href="https://www.runoob.com/java/java-hashmap-entryset.html">entrySet()</a></td><td>返回 hashMap 中所有映射项的集合集合视图。</td></tr><tr><td><a href="https://www.runoob.com/java/java-hashmap-keyset.html">keySet</a>()</td><td>返回 hashMap 中所有 key 组成的集合视图。</td></tr><tr><td><a href="https://www.runoob.com/java/java-hashmap-values.html">values()</a></td><td>返回 hashMap 中存在的所有 value 值。</td></tr></tbody></table><p><a href="https://www.runoob.com/java/java-hashmap.html">参考文章</a></p><h4 id="六、Hashcode方法与equals方法"><a href="#六、Hashcode方法与equals方法" class="headerlink" title="六、Hashcode方法与equals方法"></a>六、Hashcode方法与equals方法</h4><h5 id="（一）、hashcode是什么？"><a href="#（一）、hashcode是什么？" class="headerlink" title="（一）、hashcode是什么？"></a>（一）、hashcode是什么？</h5><h6 id="1、hash和hash表是什么"><a href="#1、hash和hash表是什么" class="headerlink" title="1、hash和hash表是什么"></a>1、hash和hash表是什么</h6><p>hash是一个函数，该函数中的实现就是一种算法，就是通过一系列的算法来得到一个hash值。这个时候，我们就需要知道另一个东西，hash表，通过hash算法得到的hash值就在这张hash表中，也就是说，hash表就是所有的hash值组成的，有很多种hash函数，也就代表着有很多种算法得到hash值</p><h6 id="2、hashcode"><a href="#2、hashcode" class="headerlink" title="2、hashcode"></a>2、hashcode</h6><p>hashcode就是通过hash函数得来的，通俗的说，就是通过某一种算法得到的，hashcode就是在hash表中有对应的位置。</p><p><strong>每个对象都有hashcode，对象的hashcode怎么得来的呢？</strong></p><p>首先一个对象肯定有物理地址，对象的物理地址跟这个hashcode地址不一样，<strong>hashcode代表对象的地址说的是对象在hash表中的位置，物理地址说的对象存放在内存中的地址</strong></p><p>通过对象的内部地址(也就是物理地址)转换成一个整数，然后该整数通过hash函数的算法就得到了hashcode。<strong>所以，hashcode就是在hash表中对应的位置。</strong></p><p>举个例子，hash表中有 hashcode为1、hashcode为2、(…)3、4、5、6、7、8这样八个位置，有一个对象A，A的物理地址转换为一个整数17(这是假如)，就通过直接取余算法，17%8=1，那么A的hashcode就为1，且A就在hash表中1的位置。</p><h5 id="（二）、hashcode有什么作用"><a href="#（二）、hashcode有什么作用" class="headerlink" title="（二）、hashcode有什么作用"></a>（二）、hashcode有什么作用</h5><p><strong>HashCode的存在主要是为了查找的快捷性，HashCode是用来在散列存储结构中确定对象的存储地址的(后半句说的用hashcode来代表对象就是在hash表中的位置)</strong></p><p>比如：我们有一个能存放1000个数这样大的内存中，在其中要存放1000个不一样的数字，用最笨的方法，就是存一个数字，就遍历一遍，看有没有相同得数，当存了900个数字，开始存901个数字的时候，就需要跟900个数字进行对比，这样就很麻烦，很是消耗时间，用hashcode来记录对象的位置，来看一下。</p><p>hash表中有1、2、3、4、5、6、7、8个位置，存第一个数，hashcode为1，该数就放在hash表中1的位置，存到100个数字，hash表中8个位置会有很多数字了，1中可能有20个数字，存101个数字时，他先查hashcode值对应的位置，假设为1，那么就有20个数字和他的hashcode相同，他只需要跟这20个数字相比较(equals)，如果每一个相同，那么就放在1这个位置，这样比较的次数就少了很多，实际上hash表中有很多位置，这里只是举例只有8个，实际上，如果hash表很大，那么比较的次数就很少很少了。</p><p><strong><em>！！！值如果相等那么hashcode一定相等，所以先比较hashcode再用equals方法比较</em></strong></p><h5 id="（三）、equals方法和hashcode的关系"><a href="#（三）、equals方法和hashcode的关系" class="headerlink" title="（三）、equals方法和hashcode的关系"></a>（三）、equals方法和hashcode的关系</h5><p>通过前面这个例子，大概可以知道，先通过hashcode来比较，如果hashcode相等，那么就用equals方法来比较两个对象是否相等。</p><p>用个例子说明：上面说的hash表中的8个位置，就好比8个桶，每个桶里能装很多的对象，对象A通过hash函数算法得到将它放到1号桶中，当然肯定有别的对象也会放到1号桶中，如果对象B也通过算法分到了1号桶，那么它如何识别桶中其他对象是否和它一样呢，这时候就需要equals方法来进行筛选了。</p><p>1、如果两个对象equals相等，那么这两个对象的HashCode一定也相同</p><p>2、如果两个对象的HashCode相同，不代表两个对象就相同，只能说明这两个对象在散列存储结构中，存放于同一个位置</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-集合框架&quot;&gt;&lt;a href=&quot;#Java-集合框架&quot; class=&quot;headerlink&quot; title=&quot;Java 集合框架&quot;&gt;&lt;/a&gt;Java 集合框架&lt;/h1&gt;&lt;p&gt;&lt;img src= &quot;/img/loading.gif&quot; data-lazy-src</summary>
      
    
    
    
    <category term="Java" scheme="https://cddorz.github.io/categories/Java/"/>
    
    
    <category term="总结" scheme="https://cddorz.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>青鸢面基大会</title>
    <link href="https://cddorz.github.io/2020/10/31/%E9%9D%92%E9%B8%A2%E9%9D%A2%E5%9F%BA%E5%A4%A7%E4%BC%9A/"/>
    <id>https://cddorz.github.io/2020/10/31/%E9%9D%92%E9%B8%A2%E9%9D%A2%E5%9F%BA%E5%A4%A7%E4%BC%9A/</id>
    <published>2020-10-31T13:32:30.000Z</published>
    <updated>2020-11-13T11:40:20.137Z</updated>
    
    <content type="html"><![CDATA[<h2 id="青鸢面基大会"><a href="#青鸢面基大会" class="headerlink" title="青鸢面基大会"></a>青鸢面基大会</h2><h4 id="10-30青鸢工作室面基大会。西安电子科技大学青鸢工作室nb！"><a href="#10-30青鸢工作室面基大会。西安电子科技大学青鸢工作室nb！" class="headerlink" title="10.30青鸢工作室面基大会。西安电子科技大学青鸢工作室nb！"></a>10.30青鸢工作室面基大会。西安电子科技大学青鸢工作室nb！</h4><p>18：30——19：00是学长树总给大家说一下工作室的代码规范。</p><p>​    之后的聚餐才是真正的重点！因为有美团大四工作学长和字节大三实习学长来和我们一起聊天。</p><p>虽然一开始大家都不是很熟悉的时候，没聊啥，但随着学长们分享去大场工作的经验，大家的兴趣也都提了起来，对大厂有抑制不住的幻想hhhhh，也了解到很多的神。</p><p>​    感觉这次聚餐之后，对字节有了更多的期望，一人一导师的制度真的感觉很好，然后在知乎上看到在字节成长度会真的很高，所有现阶段目标就是为了字节而努力，那个大三学长也是十月份才开始觉醒。</p><p>​    就感觉对未来充满了希望和有了目标吧。qwq。</p><hr><p><strong>2020.11.12更新</strong>：也算是对业务有了最基本的了解，也写了几个功能，回头看到了学长给的建议，还是想写下来: </p><p><strong>首先：面试的准备工作</strong></p><p>1、去字节招聘网站，搜索日常实习生，找java 岗位要求，多看几个岗位要求，大概就知道现在大厂要求你干嘛了，然后再根据你不会的 去针对学习。</p><p>2、背高频面试题</p><p><u><strong>其次，是坚持二字尤为重要！！</strong></u></p><p><strong>最后，学习的路</strong></p><p>工作室的业务，做一两个来练手，熟悉基本流程，更重要的是自己扎实基础，找找项目难点，寻找优化点，做的时候多想一点，不是单纯为了做功能而做，多思考为什么要这样做。</p><hr><p><a href="https://www.huxiu.com/article/267100.html">阿里云的这群疯子</a></p><p>希望大家看到的都能花一点时间去看看这篇文章。，文采不足就用其中的几句话来概括我的感受：</p><p><strong>创业维艰，唯有曾和死神擦肩而过的人，余生才会用十倍的速度奔跑。</strong></p><p><strong>认输，你才真的输了。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;青鸢面基大会&quot;&gt;&lt;a href=&quot;#青鸢面基大会&quot; class=&quot;headerlink&quot; title=&quot;青鸢面基大会&quot;&gt;&lt;/a&gt;青鸢面基大会&lt;/h2&gt;&lt;h4 id=&quot;10-30青鸢工作室面基大会。西安电子科技大学青鸢工作室nb！&quot;&gt;&lt;a href=&quot;#10-30青</summary>
      
    
    
    
    <category term="随笔" scheme="https://cddorz.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="总结" scheme="https://cddorz.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
</feed>

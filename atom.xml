<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HLY-Blog</title>
  
  <subtitle>少年应与平庸相斥</subtitle>
  <link href="https://cddorz.github.io/atom.xml" rel="self"/>
  
  <link href="https://cddorz.github.io/"/>
  <updated>2021-05-31T04:20:21.270Z</updated>
  <id>https://cddorz.github.io/</id>
  
  <author>
    <name>HLY</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法总结</title>
    <link href="https://cddorz.github.io/2021/05/31/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://cddorz.github.io/2021/05/31/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2021-05-31T02:53:05.000Z</published>
    <updated>2021-05-31T04:20:21.270Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、快速排序算法"><a href="#一、快速排序算法" class="headerlink" title="一、快速排序算法"></a>一、快速排序算法</h2><p>==主要思想==</p><ul><li>从序列中，任选一个记录k作为<strong>轴值pivot</strong></li><li>选择策略<ul><li>第一个元素</li><li>最后一个元素</li><li>中间元素</li></ul></li><li>将数组元素，分割成<strong>左子序列L</strong>和<strong>右子序列R</strong></li><li>L 中所有元素都 &lt; k， R 中所有元素都 &gt; k</li><li>对 L 和 R递归进行快排，直到子序列中有 0 个 或者 1 个元素，退出</li></ul><p>通过画图理解算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hly</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 分治思想：快速排序算法实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-31 11:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 快速排序 </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] n = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n.length; i++) &#123;</span><br><span class="line">            System.out.print(n[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        quickSort(n,<span class="number">0</span>,<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n.length; i++) &#123;</span><br><span class="line">            System.out.print(n[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归快排</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] n,<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">            dp = partition(n,left,right);</span><br><span class="line">            quickSort(n,dp + <span class="number">1</span>,right);</span><br><span class="line">            quickSort(n,left,dp - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分区函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] n, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="comment">// pivot 存储基准值</span></span><br><span class="line">        <span class="keyword">int</span> pivot = n[left];</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; n[right] &gt;= pivot)&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">                n[left] = n[right];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; n[left] &lt;= pivot)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">                n[right] = n[left];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分区值</span></span><br><span class="line">        n[left] = pivot;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">    <span class="number">1</span> <span class="number">5</span> <span class="number">6</span> <span class="number">3</span> <span class="number">2</span> <span class="number">8</span> <span class="number">9</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">9</span> </span><br></pre></td></tr></table></figure><ul><li><p>时间复杂度：</p><ul><li><p>平均：O(Nlogn)</p></li><li><p>最差：O(N^2^)</p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、快速排序算法&quot;&gt;&lt;a href=&quot;#一、快速排序算法&quot; class=&quot;headerlink&quot; title=&quot;一、快速排序算法&quot;&gt;&lt;/a&gt;一、快速排序算法&lt;/h2&gt;&lt;p&gt;==主要思想==&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从序列中，任选一个记录k作为&lt;strong&gt;轴值</summary>
      
    
    
    
    
    <category term="算法" scheme="https://cddorz.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode复盘</title>
    <link href="https://cddorz.github.io/2021/04/22/Leetcode%E5%A4%8D%E7%9B%98/"/>
    <id>https://cddorz.github.io/2021/04/22/Leetcode%E5%A4%8D%E7%9B%98/</id>
    <published>2021-04-22T01:58:33.000Z</published>
    <updated>2021-05-31T04:20:19.073Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-回文链表"><a href="#1-回文链表" class="headerlink" title="1.回文链表"></a>1.回文链表</h2><h4 id="题目描述：回文链表：1-gt-2-gt-2-gt-1-true"><a href="#题目描述：回文链表：1-gt-2-gt-2-gt-1-true" class="headerlink" title="题目描述：回文链表：1-&gt;2-&gt;2-&gt;1 true"></a>题目描述：回文链表：1-&gt;2-&gt;2-&gt;1 true</h4><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><ul><li><p>首先需要记录中间位置，以便翻转，由此想到快慢指针来进行标记</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">     fast = fast.next.next;</span><br><span class="line">     slow = slow.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遇到的一个小坑！后面解释</span></span><br><span class="line"> <span class="keyword">if</span>(fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">     slow = slow.next;</span><br><span class="line"> &#125;</span><br><span class="line">当fast指针遍历到末尾时，slow指针遍历到中间</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>其次是翻转链表，这里定义pre，prepre指针来直接翻转链表，破坏了链表结构，有坑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ListNode pre&#x3D;head,prepre&#x3D;null;</span><br><span class="line"> while(fast !&#x3D; null &amp;&amp; fast.next !&#x3D; null)&#123;</span><br><span class="line">           pre &#x3D; slow;</span><br><span class="line">           slow &#x3D; slow.next;</span><br><span class="line">           fast &#x3D; fast.next.next;</span><br><span class="line">           pre.next &#x3D; prepre;</span><br><span class="line">           prepre &#x3D; pre;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>最后，比较pre和slow</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while(pre!&#x3D;null&amp;&amp;slow!&#x3D;null)&#123;</span><br><span class="line">            if(slow.val!&#x3D;pre.val)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            pre&#x3D;pre.next;</span><br><span class="line">            slow&#x3D;slow.next;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 回文链表：1-&gt;2-&gt;2-&gt;1 true</span></span><br><span class="line"><span class="comment"> * 通过pre 和 prepre指针来反转链表</span></span><br><span class="line"><span class="comment"> * fast指针走完，slow到一半</span></span><br><span class="line"><span class="comment"> * 只是破坏了链表的结构</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-01 20:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">huiwenlianbiao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结构体链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode() &#123;&#125;</span><br><span class="line">        ListNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">        ListNode(<span class="keyword">int</span> val, ListNode next) &#123; <span class="keyword">this</span>.val = val; <span class="keyword">this</span>.next = next; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>&amp;&amp;head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//prepre pre 用来反转链表</span></span><br><span class="line">        ListNode slow=head,fast=head;</span><br><span class="line">        ListNode pre=head,prepre=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            pre.next = prepre;</span><br><span class="line">            prepre = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pre!=<span class="keyword">null</span>&amp;&amp;slow!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(slow.val!=pre.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre=pre.next;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>==坑！！！！==</p><p>一开始不知道为啥会有 if(fast!=null){slow = slow.next;}这一段代码，因为如果是1-&gt;2-&gt;3-&gt;2-&gt;1的回文链表，这样就会让slow只有2-&gt;1，除去了3的比较，一开始我一直以为pre和slow是同步的，这样才能翻转比较，但后来仔细看了看代码，pre其实是比slow晚一步的，因为这种pre的方式是破坏了链表结构，链表的前段部分是翻转了的，所以如果pre和slow是同步的话，3其实有两个next，就会出现错误。</p><p>所以如果是奇数链表，那么pre和slow都是从3的前一个，后一个元素开始比较，-如果是偶数链表，当然也不会出现这种情况。</p><h2 id="2-括号匹配"><a href="#2-括号匹配" class="headerlink" title="2.括号匹配"></a>2.括号匹配</h2><p>算是一个比较经典的问题了，首先需要了解几个Java的容器，Map、HashMap、Deque（栈）</p><h4 id="题目描述：给定一个只包括-39-39-，-39-39-，-39-39-，-39-39-，-39-39-，-39-39-的字符串-s-，判断字符串是否有效。"><a href="#题目描述：给定一个只包括-39-39-，-39-39-，-39-39-，-39-39-，-39-39-，-39-39-的字符串-s-，判断字符串是否有效。" class="headerlink" title="题目描述：给定一个只包括&#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串 s ，判断字符串是否有效。"></a>题目描述：给定一个只包括<code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</h4><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><ul><li><p>首先需要思考的是怎么匹配前后括号，因为输入形式是”{[]}”、”()[]{}”这样的，匹配的时候需要，匹配好一对括号就删除，因此想到了栈结构，通过压栈和弹栈来实现</p></li><li><p>接下来，就考虑如何匹配，想到用HashMap 的k-v键值对来存储括号，因为后括号在前括号之后，所以k存储后括号，v存储前括号，如果遇到前括号，就压栈，如果遇到后括号，看看栈顶和其匹不匹配，匹配就把前括号弹栈。</p></li><li><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 括号匹配</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-01 20:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">matching</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="comment">//如果长度是奇数，一定不匹配</span></span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character, Character&gt; pairs = <span class="keyword">new</span> HashMap&lt;Character,Character&gt;() &#123;&#123;</span><br><span class="line">            put(<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            put(<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">            put(<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        Deque&lt;Character&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//遍历s</span></span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (pairs.containsKey(ch)) &#123;</span><br><span class="line">                <span class="comment">//判断括号是否匹配</span></span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty() || !stack.peek().equals(pairs.get(ch))) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-x的n次幂-递归-快速幂"><a href="#3-x的n次幂-递归-快速幂" class="headerlink" title="3.x的n次幂(递归+快速幂)"></a>3.x的n次幂(递归+快速幂)</h2><h3 id="题目描述：实现-pow-x-n-，即计算-x-的-n-次幂函数（即，x-n-）"><a href="#题目描述：实现-pow-x-n-，即计算-x-的-n-次幂函数（即，x-n-）" class="headerlink" title="题目描述：实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，x^n^）"></a>题目描述：实现 <a href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数（即，x^n^）</h3><h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><ul><li>首先想到，从左至右<em>x</em>→<em>x</em>^2^→<em>x</em>^4^→<em>x</em>^9^→<em>x</em>^19^→<em>x</em>^38^→<em>x</em>^77^，每次都将上次的结果进行平方，但有些步骤需要多*一个x，这就会比较困难，如何判断到底要不要多×一个x</li><li>但如果我们从右往左看，分治的思想就十分明显：<ul><li>当我们要计算 x^n^时，可以先递归的算出y = x^[n/2]^,其中[a]表示对a向下取整</li><li>根据递归计算的结果，如果n为偶数，那么x^n^ = y*y，如果n为奇数，那么x^n^ = y * y * x</li><li>递归的边界为 n = 0，任意数的 0次方均为 1。</li><li>由于每次递归都会使得指数减少一半，因此递归的层数为 <em>O</em>(log<em>n</em>)</li></ul></li></ul><p>完整代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速幂+递归实现x的n次幂</span></span><br><span class="line"><span class="comment"> * 从右向左分析</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-01 23:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">pow</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> N = n;</span><br><span class="line">            <span class="comment">//若n是负数，则1/</span></span><br><span class="line">            <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> N)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (N == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">double</span> y = quickMul(x, N / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span> ? y * y : y * y * x;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(logn)，即为递归的层数。</li></ul><ul><li>空间复杂度：O(logn)，即为递归的层数。这是由于递归的函数调用会使用栈空间。</li></ul><h2 id="4-牛顿迭代法实现完全平方数的判断"><a href="#4-牛顿迭代法实现完全平方数的判断" class="headerlink" title="4.牛顿迭代法实现完全平方数的判断"></a>4.牛顿迭代法实现完全平方数的判断</h2><p>![G_YXC__JI@5_P_L~22`G5_0.png](<a href="https://i.loli.net/2021/04/22/d9fgKHIMhUOjnpZ.png">https://i.loli.net/2021/04/22/d9fgKHIMhUOjnpZ.png</a>)</p><p>由于这种解法太过神仙，就不多解释了，看图就好，这只是一种无限接近的解法，会有误差，但误差在允许的范围之内。</p><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> x = num / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (x * x &gt; num) &#123;</span><br><span class="line">      x = (x + num / x) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (x * x == num);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二分法："><a href="#二分法：" class="headerlink" title="二分法："></a>二分法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> left = <span class="number">2</span>, right = num / <span class="number">2</span>, x, guessSquared;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">      x = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">      guessSquared = x * x;</span><br><span class="line">      <span class="keyword">if</span> (guessSquared == num) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (guessSquared &gt; num) &#123;</span><br><span class="line">        right = x - <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left = x + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-判断是否是对称二叉树"><a href="#5-判断是否是对称二叉树" class="headerlink" title="5.判断是否是对称二叉树"></a>5.判断是否是对称二叉树</h2><h4 id="思路：比较左孩子的与右孩子值是否相等，由此想到递归实现，比较容易理解，就不加赘述了。"><a href="#思路：比较左孩子的与右孩子值是否相等，由此想到递归实现，比较容易理解，就不加赘述了。" class="headerlink" title="思路：比较左孩子的与右孩子值是否相等，由此想到递归实现，比较容易理解，就不加赘述了。"></a>思路：比较左孩子的与右孩子值是否相等，由此想到递归实现，比较容易理解，就不加赘述了。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过递归实现判断是否是对称二叉树</span></span><br><span class="line"><span class="comment"> * 递归终止条件：两个节点都为空；其中一个节点为空；两个节点值不相等</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-02 10:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">isSymmetric</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用递归函数，比较左节点，右节点</span></span><br><span class="line">        <span class="keyword">return</span> dfs(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(TreeNode left, TreeNode right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归的终止条件是两个节点都为空</span></span><br><span class="line">        <span class="comment">//或者两个节点中有一个为空</span></span><br><span class="line">        <span class="comment">//或者两个节点的值不相等</span></span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span> &amp;&amp; right==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span> || right==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left.val!=right.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再递归的比较 左节点的左孩子 和 右节点的右孩子</span></span><br><span class="line">        <span class="comment">//以及比较  左节点的右孩子 和 右节点的左孩子</span></span><br><span class="line">        <span class="keyword">return</span> dfs(left.left,right.right) &amp;&amp; dfs(left.right,right.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode() &#123;&#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-617-合并二叉树"><a href="#6-617-合并二叉树" class="headerlink" title="6. 617 合并二叉树"></a>6. 617 合并二叉树</h2><h4 id="思路：前序递归遍历二叉树，并将值相加"><a href="#思路：前序递归遍历二叉树，并将值相加" class="headerlink" title="思路：前序递归遍历二叉树，并将值相加"></a>思路：前序递归遍历二叉树，并将值相加</h4><ul><li><p>递归终止条件,两节点有一个或两个节点为null就返回</p></li><li><p>递归函数内,将两个树的节点相加后,再递归执行两节点的左节点和右节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">dfs</span><span class="params">(TreeNode r1, TreeNode r2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (r1 == <span class="keyword">null</span> || r2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> r1 == <span class="keyword">null</span> ? r2 : r1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//树2合并到树1上</span></span><br><span class="line">        <span class="comment">//前序遍历二叉树</span></span><br><span class="line">        r1.val += r2.val;</span><br><span class="line">        r1.left = dfs(r1.left, r2.left);</span><br><span class="line">        r1.right = dfs(r1.right, r2.right);</span><br><span class="line">        <span class="keyword">return</span> r1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>完整代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归法合并二叉树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-02 15:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">merge</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="keyword">null</span> || root2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root1 == <span class="keyword">null</span> ? root2 : root1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(root1, root2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">dfs</span><span class="params">(TreeNode r1, TreeNode r2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (r1 == <span class="keyword">null</span> || r2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> r1 == <span class="keyword">null</span> ? r2 : r1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//树2合并到树1上</span></span><br><span class="line">        <span class="comment">//前序遍历二叉树</span></span><br><span class="line">        r1.val += r2.val;</span><br><span class="line">        r1.left = dfs(r1.left, r2.left);</span><br><span class="line">        r1.right = dfs(r1.right, r2.right);</span><br><span class="line">        <span class="keyword">return</span> r1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="7-反转链表"><a href="#7-反转链表" class="headerlink" title="7.反转链表"></a>7.反转链表</h2><h3 id="思路-递归遍历到最后一个节点-然后反转"><a href="#思路-递归遍历到最后一个节点-然后反转" class="headerlink" title="思路:递归遍历到最后一个节点,然后反转"></a>思路:递归遍历到最后一个节点,然后反转</h3><ul><li><p>递归终止条件: head == null  or  head.next == null</p></li><li><p>递归函数内容:将指针反转,注意节点下一位必须指向null,否则不算成功</p></li><li><p>时间复杂度:O(n),n为节点个数们,需要遍历n个节点进行反转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归实现反转链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-02 23:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">reverseList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode newhead = reverseList(head.next);</span><br><span class="line">        <span class="comment">//反转指针</span></span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="8-移动零-leectcode-283"><a href="#8-移动零-leectcode-283" class="headerlink" title="8.移动零 leectcode 283"></a>8.移动零 leectcode 283</h2><h3 id="描述：给定一个数组-nums，编写一个函数将所有-0-移动到数组的末尾，同时保持非零元素的相对顺序。"><a href="#描述：给定一个数组-nums，编写一个函数将所有-0-移动到数组的末尾，同时保持非零元素的相对顺序。" class="headerlink" title="描述：给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。"></a>描述：给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</h3><h3 id="思路：快排实现移动0，因为除了特殊情况外，快排是所有排序中性能最好的算法。将第一个元素作为基准值，从左至右遍历，如果不为0，则交换，使得所有不为0的元素在数组左侧（数组分治思想"><a href="#思路：快排实现移动0，因为除了特殊情况外，快排是所有排序中性能最好的算法。将第一个元素作为基准值，从左至右遍历，如果不为0，则交换，使得所有不为0的元素在数组左侧（数组分治思想" class="headerlink" title="思路：快排实现移动0，因为除了特殊情况外，快排是所有排序中性能最好的算法。将第一个元素作为基准值，从左至右遍历，如果不为0，则交换，使得所有不为0的元素在数组左侧（数组分治思想"></a>思路：快排实现移动0，因为除了特殊情况外，快排是所有排序中性能最好的算法。将第一个元素作为基准值，从左至右遍历，如果不为0，则交换，使得所有不为0的元素在数组左侧（数组分治思想</h3><p>快排：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src.day3;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快排实现数组中0都在数组的末尾</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-03 22:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">moveZero</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">                temp = nums[i];</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j] = temp;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-回文链表&quot;&gt;&lt;a href=&quot;#1-回文链表&quot; class=&quot;headerlink&quot; title=&quot;1.回文链表&quot;&gt;&lt;/a&gt;1.回文链表&lt;/h2&gt;&lt;h4 id=&quot;题目描述：回文链表：1-gt-2-gt-2-gt-1-true&quot;&gt;&lt;a href=&quot;#题目描述：回</summary>
      
    
    
    
    <category term="算法" scheme="https://cddorz.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="leetcode" scheme="https://cddorz.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>ThreadAndJUc</title>
    <link href="https://cddorz.github.io/2021/04/21/ThreadAndJUc/"/>
    <id>https://cddorz.github.io/2021/04/21/ThreadAndJUc/</id>
    <published>2021-04-21T03:14:43.000Z</published>
    <updated>2021-05-19T15:07:38.110Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多线程，并发相关"><a href="#多线程，并发相关" class="headerlink" title="多线程，并发相关"></a><strong>多线程，并发相关</strong></h1><h3 id="涉及线程知识及源码解析，最后会有一个高并发，高可用的项目实例"><a href="#涉及线程知识及源码解析，最后会有一个高并发，高可用的项目实例" class="headerlink" title="涉及线程知识及源码解析，最后会有一个高并发，高可用的项目实例"></a><strong>涉及线程知识及源码解析，最后会有一个高并发，高可用的项目实例</strong></h3><h3 id="1、多线程的实现方式"><a href="#1、多线程的实现方式" class="headerlink" title="1、多线程的实现方式"></a><strong>1、多线程的实现方式</strong></h3><p><strong>==两种方式本质上是没有区别的最终都是调用start()方法来新建线程==</strong></p><h4 id="①-继承Thread类"><a href="#①-继承Thread类" class="headerlink" title="① 继承Thread类"></a><strong>① 继承Thread类</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">重写Run方法，example：</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AbstractStorage abstractStorage;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     * 设置仓库</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> abstractStorage</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(AbstractStorage abstractStorage)</span></span>&#123;<span class="keyword">this</span>.abstractStorage = abstractStorage;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        consume(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用Storage生产函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        abstractStorage.consume(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNum</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="②-实现Runnable接口"><a href="#②-实现Runnable接口" class="headerlink" title="② 实现Runnable接口"></a><strong>② 实现Runnable接口</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">实现Runnable接口把接口实例传给Thread类，example：</span><br><span class="line">public class StartOrRunMethod &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Runnable runnable &#x3D; new Runnable()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        &#x2F;&#x2F;main方法中执行一个普通的方法</span><br><span class="line">        runnable.run();</span><br><span class="line">        &#x2F;&#x2F;启动新线程，加入线程池</span><br><span class="line">        &#x2F;&#x2F;native本地方法</span><br><span class="line">        new Thread(runnable).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2、正确优雅地中断线程"><a href="#2、正确优雅地中断线程" class="headerlink" title="2、正确优雅地中断线程"></a><strong>2、正确优雅地中断线程</strong></h3><p><strong>==我们要使用interrupt来进行通知而非强制 （请求线程停止好处是安全）==</strong></p><p><strong><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/qiurunze123/imageall/master/basethread100.png"></strong></p><h4 id="①-interrupt（）用法（没有sleep和wait方法，线程不阻塞）"><a href="#①-interrupt（）用法（没有sleep和wait方法，线程不阻塞）" class="headerlink" title="①.interrupt（）用法（没有sleep和wait方法，线程不阻塞）"></a><strong>①.interrupt（）用法（没有sleep和wait方法，线程不阻塞）</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">结束run函数，run中含退出标志位()</span><br><span class="line">使用interrupt()方法中断线程</span><br><span class="line"></span><br><span class="line">public void interrupt() &#123;  ... &#125;   &#x2F;&#x2F;中断目标线程</span><br><span class="line">public boolean isInterrupted&#123; ... &#125; &#x2F;&#x2F;返回目标线程的中断状态</span><br><span class="line">public static boolean interrupted()&#123; ... &#125; &#x2F;&#x2F; 清除当前线程的中断状态,并返回它之前的值，这也是清除中断状态的唯一方式</span><br><span class="line">interrupt()其本身并不是一个强制打断线程的方法，其仅仅会修改线程的interrupt标志位，然后让线程自行去读标志位，自行判断是否需要中断</span><br><span class="line">example：</span><br><span class="line">public class RightWayStopThreadWithoutSleepAndWait implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F;查看当前是否设置了中断标示，判断当前线程是否中断 isInterrupted（）方法返回true，证明线程中断</span><br><span class="line">        while (!Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">            System.out.println(&quot;在没有sleep等方法结束了线程&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;线程结束了！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        &#x2F;&#x2F;创建一个重写了run函数的线程对象</span><br><span class="line">        Thread thread &#x3D;new Thread(new RightWayStopThreadWithoutSleepAndWait());</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(10);</span><br><span class="line">        &#x2F;&#x2F;发送中断请求</span><br><span class="line">        thread.interrupt();</span><br><span class="line">        System.out.println(&quot;thread is stopping...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="②-线程阻塞情况下（sleep和wait）"><a href="#②-线程阻塞情况下（sleep和wait）" class="headerlink" title="②.线程阻塞情况下（sleep和wait）"></a><strong>②.线程阻塞情况下（sleep和wait）</strong></h4><h5 id="线程阻塞：什么是线程阻塞？"><a href="#线程阻塞：什么是线程阻塞？" class="headerlink" title="线程阻塞：什么是线程阻塞？"></a><strong>线程阻塞：什么是线程阻塞？</strong></h5><p><strong>在某一时刻某一个线程在运行一段代码的时候，这时候另一个线程也需要运行，但是在运行过程中的那个线程执行完成之前，另一个线程是无法获取到CPU执行权的（调用sleep方法是进入到睡眠暂停状态，但是CPU执行权并没有交出去，而调用wait方法则是将CPU执行权交给另一个线程），这个时候就会造成线程阻塞。</strong></p><p><strong>为什么会出现线程阻塞？</strong></p><p><strong>1.睡眠状态：当一个线程执行代码的时候调用了sleep方法后，线程处于睡眠状态，需要设置一个睡眠时间，此时有其他线程需要执行时就会造成线程阻塞，而且sleep方法被调用之后，线程不会释放锁对象，也就是说锁还在该线程手里，CPU执行权还在自己手里，等睡眠时间一过，该线程就会进入就绪状态，典型的“占着茅坑不拉屎”；</strong></p><p><strong>2.等待状态：当一个线程正在运行时，调用了wait方法，此时该线程需要交出CPU执行权，也就是将锁释放出去，交给另一个线程，该线程进入等待状态，但与睡眠状态不一样的是，进入等待状态的线程不需要设置睡眠时间，但是需要执行notify方法或者notifyall方法来对其唤醒，自己是不会主动醒来的，等被唤醒之后，该线程也会进入就绪状态，但是进入就绪状态的该线程手里是没有执行权的，也就是没有锁，而睡眠状态的线程一旦苏醒，进入就绪状态时是自己还拿着锁的。等待状态的线程苏醒后，就是典型的“物是人非，大权旁落“；</strong></p><p><strong>3.礼让状态：当一个线程正在运行时，调用了yield方法之后，该线程会将执行权礼让给同等级的线程或者比它高一级的线程优先执行，此时该线程有可能只执行了一部分而此时把执行权礼让给了其他线程，这个时候也会进入阻塞状态，但是该线程会随时可能又被分配到执行权，这就很”中国化的线程“了，比较讲究谦让；</strong></p><p><strong>4.自闭状态：当一个线程正在运行时，调用了一个join方法，此时该线程会进入阻塞状态，另一个线程会运行，直到运行结束后，原线程才会进入就绪状态。这个比较像是”走后门“，本来该先把你的事情解决完了再解决后边的人的事情，但是这时候有走后门的人，那就会停止给你解决，而优先把走后门的人事情解决了；</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RigthWayStopThreadWithSleep</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (!Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;在有sleep的情况下中断线程&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">//线程堵塞导致线程无法停止，抛出异常</span></span><br><span class="line"><span class="comment">//当一个方法抛出InterruptedException时，它是在告诉您，如果执行该方法的线程被中断</span></span><br><span class="line"><span class="comment">//它将尝试停止它正在做的事情而提前返回，并通过InterruptedExceptio表明它提前返回。</span></span><br><span class="line"><span class="comment">// 行为良好的阻塞库方法应该能对中断作出响应并抛出InterruptedException，以便能够用于可取消活动中，而不至于影响响应。</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;线程阻塞&quot;</span>);</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="comment">//发送中断请求</span></span><br><span class="line">        thread.interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;thread is stopping..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3、多线程异常处理机制"><a href="#3、多线程异常处理机制" class="headerlink" title="3、多线程异常处理机制"></a><strong>3、多线程异常处理机制</strong></h3><p><strong>==首先：子线程抛出异常主线程不会处理、线程的异常不能用传统方法捕获==</strong></p><p><strong>所以要定义自己的异常处理器，实现异常处理器Thread.UncaughtExceptionHandler一个函数式接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadCatchProcess3</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadCatchProcess3</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置自己的异常处理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//可以进行一系列的自定义操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;线程异常终止进程&quot;</span> + t.getName());</span><br><span class="line">        System.out.println(name + <span class="string">&quot;捕获了异常&quot;</span> + t.getName() + <span class="string">&quot;异常&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>在主线程上声明需要用到的异常处理器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadCatch</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//利用自定义的异常处理器</span></span><br><span class="line">        Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> ThreadCatchProcess3(<span class="string">&quot;获取异常&quot;</span>));</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadCatch(),<span class="string">&quot;MyThread-1&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadCatch(),<span class="string">&quot;MyThread-2&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadCatch(),<span class="string">&quot;MyThread-3&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4、死锁"><a href="#4、死锁" class="headerlink" title="4、死锁"></a><strong>4、死锁</strong></h3><h4 id="①-什么是死锁"><a href="#①-什么是死锁" class="headerlink" title="①.什么是死锁"></a><strong>①.什么是死锁</strong></h4><p><strong>1.发生在并发中</strong></p><p><strong>2.当两个线程持有对方所需要的资源又不主动释放 导致所有人都没有办法继续前进 这就是死锁 如果系统资源充足进程的资源请求都能满足死锁的可能性就会很低 否则就会因为争夺优先的资源而陷入死锁</strong></p><h4 id="②-修复死锁策略：保存案发线程然后立刻重启服务器然后进行排查-重新发布"><a href="#②-修复死锁策略：保存案发线程然后立刻重启服务器然后进行排查-重新发布" class="headerlink" title="②.修复死锁策略：保存案发线程然后立刻重启服务器然后进行排查 重新发布"></a><strong>②.修复死锁策略：保存案发线程然后立刻重启服务器然后进行排查 重新发布</strong></h4><p> <strong>==一段时间检测是否有死锁 如果有就剥夺某一个资源来打开死锁==</strong></p><h4 id="③-哲学家就餐问题"><a href="#③-哲学家就餐问题" class="headerlink" title="③.哲学家就餐问题"></a><strong>③.哲学家就餐问题</strong></h4><p><strong>还有很多其他例子，这里暂且用哲学家就餐问题来说明</strong></p><p><strong>哲学家就餐问题可以这样表述，假设有五位哲学家围坐在一张圆形餐桌旁，做以下两件事情之一：吃饭，或者思考。吃东西的时候，他们就停止思考，思考的时候也停止吃东西。餐桌中间有一大碗意大利面，每两个哲学家之间有一只餐叉。因为用一只餐叉很难吃到意大利面，所以假设哲学家必须用两只餐叉吃东西。他们只能使用自己左右手边的那两只餐叉。哲学家就餐问题有时也用米饭和筷子而不是意大利面和餐叉来描述，因为很明显，吃米饭必须用两根筷子。</strong></p><p><strong>哲学家从来不交谈，这就很危险，可能产生死锁，每个哲学家都拿着左手的餐叉，永远都在等右边的餐叉（或者相反）。即使没有死锁，也有可能发生资源耗尽。例如，假设规定当哲学家等待另一只餐叉超过五分钟后就放下自己手里的那一只餐叉，并且再等五分钟后进行下一次尝试。这个策略消除了死锁（系统总会进入到下一个状态），但仍然有可能发生“<a href="https://baike.baidu.com/item/%E6%B4%BB%E9%94%81">活锁</a>”。如果五位哲学家在完全相同的时刻进入餐厅，并同时拿起左边的餐叉，那么这些哲学家就会等待五分钟，同时放下手中的餐叉，再等五分钟，又同时拿起这些餐叉。</strong></p><p><strong>在实际的计算机问题中，缺乏餐叉可以类比为缺乏共享资源。一种常用的计算机技术是资源加锁，用来保证在某个时刻，资源只能被一个程序或一段代码访问。当一个程序想要使用的资源已经被另一个程序锁定，它就等待资源解锁。当多个程序涉及到加锁的资源时，在某些情况下就有可能发生死锁。例如，某个程序需要访问两个文件，当两个这样的程序各锁了一个文件，那它们都在等待对方解锁另一个文件，而这永远不会发生。</strong></p><h5 id="这里的解决方案是换手策略。"><a href="#这里的解决方案是换手策略。" class="headerlink" title="这里的解决方案是换手策略。"></a><strong>这里的解决方案是换手策略。</strong></h5><h5 id="one：哲学家类"><a href="#one：哲学家类" class="headerlink" title="one：哲学家类"></a><strong>one：哲学家类</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.geekagain.deadlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hly</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:哲学家</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-20 16:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Philosophers</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object leftChopstick;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object rightChopstick;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Philosophers</span><span class="params">(Object leftChopstick, Object rightChopstick)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.leftChopstick = leftChopstick;</span><br><span class="line">        <span class="keyword">this</span>.rightChopstick = rightChopstick;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                doAciton(<span class="string">&quot;thinking&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (leftChopstick)&#123;</span><br><span class="line">                    doAciton(<span class="string">&quot;Pick up left chopstick&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (rightChopstick)&#123;</span><br><span class="line">                        doAciton(<span class="string">&quot;Pick up right chopstick --eating&quot;</span>);</span><br><span class="line">                        doAciton(<span class="string">&quot;Put down right chopstick&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    doAciton(<span class="string">&quot;Put down left chopstick&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAciton</span><span class="params">(String action)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + action);</span><br><span class="line">        Thread.sleep((<span class="keyword">long</span>) (Math.random()*<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="two：主线程"><a href="#two：主线程" class="headerlink" title="two：主线程"></a><strong>two：主线程</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.geekagain.deadlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决策略：哲学家换手</span></span><br><span class="line"><span class="comment"> * 原本问题：1-5号哲学家，1-5号筷子，若五位哲学家同时举起左边筷子，这就造成都不能eating，当哲学家持有对方所需要的筷子又不主动释放 导致所有人都没有办法继续eating</span></span><br><span class="line"><span class="comment"> * 解决：5号哲学家第一次举起右边的筷子，这样1号和5号会争夺1号筷子，有一位能抢到筷子，此时5号哲学家左边的筷子空出</span></span><br><span class="line"><span class="comment"> * 这样，4号哲学家就能拿起两双筷子eating，之后再放下筷子，其他哲学家开始eating。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hly</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:哲学家就餐问题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-20 16:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiningPhilosophers</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Philosophers[] philosophers = <span class="keyword">new</span> Philosophers[<span class="number">5</span>];</span><br><span class="line">        Object[] chopsticks = <span class="keyword">new</span> Object[philosophers.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chopsticks.length; i++) &#123;</span><br><span class="line">            chopsticks[i] = <span class="keyword">new</span> Object();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; philosophers.length; i++) &#123;</span><br><span class="line">            Object leftChopsticks = chopsticks[i];</span><br><span class="line">            <span class="comment">//因为坐圆桌</span></span><br><span class="line">            Object rigthChopsticks = chopsticks[(i+<span class="number">1</span>) % chopsticks.length];</span><br><span class="line">            <span class="comment">//表示第几个哲学家</span></span><br><span class="line">            <span class="keyword">if</span>(i != philosophers.length - <span class="number">1</span>)&#123;</span><br><span class="line">                philosophers[i] = <span class="keyword">new</span> Philosophers(leftChopsticks,rigthChopsticks);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//解决策略：第五位哲学家的“左边的筷子”是右边的筷子，有效解决，所有哲学家同时举起左边筷子，造成的死锁问题。</span></span><br><span class="line">                philosophers[i] = <span class="keyword">new</span> Philosophers(rigthChopsticks,leftChopsticks);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">new</span> Thread(philosophers[i],<span class="string">&quot;哲学家&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;号&quot;</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5、多线程wait-notify-notifyall-join-sleep-yield作用与方法详细解读"><a href="#5、多线程wait-notify-notifyall-join-sleep-yield作用与方法详细解读" class="headerlink" title="5、多线程wait notify notifyall join sleep yield作用与方法详细解读"></a><strong>5、多线程wait notify notifyall join sleep yield作用与方法详细解读</strong></h3><h4 id="①-wait-notify-notifyall-解读"><a href="#①-wait-notify-notifyall-解读" class="headerlink" title="①.wait notify notifyall 解读"></a><strong>①.wait notify notifyall 解读</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.wait() notify() notifyall() 方法是Object的本地final方法 无法被重写</span><br><span class="line">2.wait() 使当前的线程阻塞 前提是必须获取到锁 一般配合synchronized 关键字使用 即一般在synchronized里面 使用wait notify notifyall</span><br><span class="line">3.由于wait() notify() notifyall() 在synchronized里面执行 那么说明 当前线程一定是获取锁了</span><br><span class="line">4.当线程执行wait的时候会释放当前锁让出CPU资源进入等待状态</span><br><span class="line">5.当执行notify()&#x2F;notifyall()的时候会唤醒一个或者多个处于正在等待的线程 然后继续执行知道执行完毕synchronized或者再次遇到wait</span><br></pre></td></tr></table></figure><h4 id="②-生产者消费者model-ProducerAndConsumerModel"><a href="#②-生产者消费者model-ProducerAndConsumerModel" class="headerlink" title="②.生产者消费者model (ProducerAndConsumerModel)"></a><strong>②.生产者消费者model (ProducerAndConsumerModel)</strong></h4><p><strong><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/qiurunze123/imageall/master/threadbase004-7.png"></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.geekagain.waitnotify.producerandconsumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * wait and notify 模型————生产者和消费者模型</span></span><br><span class="line"><span class="comment"> * 所有通信都是通过中间堵塞队列进行缓冲</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-19 11:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerAndConsumerModel</span> <span class="keyword">implements</span> <span class="title">AbstractStorage</span></span>&#123;</span><br><span class="line">    <span class="comment">//仓库最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者，消费商品</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//同步</span></span><br><span class="line">        <span class="keyword">synchronized</span> (list)&#123;</span><br><span class="line">            <span class="comment">//仓库容量不足以消费</span></span><br><span class="line">            <span class="keyword">while</span> (num &gt; list.size())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;要消费的产品数量：&quot;</span>+num+<span class="string">&quot;\t库存量：&quot;</span></span><br><span class="line">                        +list.size()+<span class="string">&quot;\t暂时不能进行生产任务&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//消费条件满足，开始消费</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">                list.remove();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;已经消费的产品数量：&quot;</span>+num+<span class="string">&quot;\t库存：&quot;</span>+list.size());</span><br><span class="line">            list.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产者，生产商品</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">(<span class="keyword">int</span> num)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list)&#123;</span><br><span class="line">            <span class="comment">//仓库容量不足以生产全部商品</span></span><br><span class="line">            <span class="keyword">while</span> (list.size() + num &gt; MAX_SIZE)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;要生产的商品数量：&quot;</span>+num+<span class="string">&quot;\t剩余库存量：&quot;</span></span><br><span class="line">                        +(MAX_SIZE-list.size())+<span class="string">&quot;\t暂时不能进行生产任务&quot;</span>);</span><br><span class="line">                <span class="comment">//生产阻塞</span></span><br><span class="line">                list.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//条件满足，开始生产</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">                list.add(<span class="keyword">new</span> Object());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;已经生产的数量：&quot;</span>+num+<span class="string">&quot;\t现在仓库库存量:&quot;</span>+list.size());</span><br><span class="line">            list.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>==问题：生产者/消费者模式，并不是一个高性能的实现。为什么性能不高呢？原因如下：==</strong></p><p><strong>1.涉及到同步锁。</strong></p><p><strong>2.涉及到线程阻塞状态和可运行状态之间的切换。</strong></p><p><strong>3.涉及到线程上下文的切换。</strong></p><p><strong>以上涉及到的任何一点，都是非常耗费性能的操作。因此，有了==协程==，协程java的生态并没有实现，在Lua，Python，Go实现了协程</strong></p><h5 id="协程：协程，英文Coroutines，是一种比线程更加轻量级的存在。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。"><a href="#协程：协程，英文Coroutines，是一种比线程更加轻量级的存在。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。" class="headerlink" title="协程：协程，英文Coroutines，是一种比线程更加轻量级的存在。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。"></a><strong>协程：协程，英文Coroutines，是一种比线程更加轻量级的存在。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。</strong></h5><p><strong><img src= "/img/loading.gif" data-lazy-src="http://5b0988e595225.cdn.sohucs.com/images/20180622/6765e36cc4604fba897976638af03524.jpeg"></strong></p><p><strong>因为Java并没有实现协程，所以我没有太深究，在搜索的过程中，还了解了一种和Java互通的语言<em>Kotlin</em>，它可以编译成Java字节码，也可以编译成JavaScript，方便在没有JVM的设备上运行。这种语言实现了协程。</strong></p><h4 id="③-sleep"><a href="#③-sleep" class="headerlink" title="③.sleep"></a><strong>③.sleep</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">相同点：</span><br><span class="line">1.Wait和sleep方法都可以使线程阻塞，对应线程状态是Waiting或Time_Waiting</span><br><span class="line">2.wait和sleep方法都可以响应中断Thread.interrupt()</span><br><span class="line">不同点：</span><br><span class="line">1.wait方法的执行必须在同步方法中进行，而sleep则不需要。 </span><br><span class="line">2.在同步方法里执行sleep方法时，不会释放monitor锁，但是wait方法会释放monitor锁</span><br><span class="line">3.sleep 方法短暂休眠之后会主动退出阻塞，而没有指定时间的wait方法则需要被其他线程中断后才能退出阻塞。</span><br><span class="line">4.wait()和notify(),notifyAll()是Object类的方法，sleep()和yield()是Thread类的方法</span><br></pre></td></tr></table></figure><p><strong>sleep 方法可以让线程进入Waiting状态 并且不占用CPU资源但是不会释放锁 直到规定时间后在执行 休眠期间如果被中断会抛出异常并清楚中断状态</strong></p><h4 id="④-join"><a href="#④-join" class="headerlink" title="④.join"></a><strong>④.join</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package com.geekagain.join;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author hly</span><br><span class="line"> * @Description: TODO</span><br><span class="line"> * @create 2021-04-21 14:41</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class JoinThreadState &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        &#x2F;&#x2F;主线程</span><br><span class="line">        Thread mainThread &#x3D; Thread.currentThread();</span><br><span class="line">        Thread thread &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(3000);</span><br><span class="line">                    System.out.println(mainThread.getState());</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+&quot;执行完毕&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(&quot;等待子线程执行完毕&quot;);</span><br><span class="line">        thread.join();</span><br><span class="line">        System.out.println(&quot;子线程执行完毕&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">join 期间 线程的状态是 WAITING 状态</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">等待子线程执行完毕</span><br><span class="line">WAITING</span><br><span class="line">Thread-0执行完毕</span><br><span class="line">子线程执行完毕</span><br></pre></td></tr></table></figure><h4 id="⑤-yield"><a href="#⑤-yield" class="headerlink" title="⑤.yield"></a><strong>⑤.yield</strong></h4><p><strong>使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。cpu会从众多的可执行态里选择， 也就是说，当前也就是刚刚的那个线程还是有可能会被再次执行到的，并不是说一定会执行其他线程而该线程在下一次中不会执行到了</strong></p><h3 id="6、ThreadLocal"><a href="#6、ThreadLocal" class="headerlink" title="6、ThreadLocal"></a><strong>6、ThreadLocal</strong></h3><h4 id="①-threadlocal的作用和方法概念"><a href="#①-threadlocal的作用和方法概念" class="headerlink" title="①.threadlocal的作用和方法概念"></a><strong>①.threadlocal的作用和方法概念</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.保存一些业务内容 用户权限信息 用户系统获取用户名 userid等</span><br><span class="line">2.这些信息在同一个线程里面 但是不同的线程使用的业务内容是不相同的</span><br><span class="line">3.在线程的生命周期内 都通过这个静态的threadlocal实例的get() 方法来 自己set过得那个对象 避免将这个对象（例如user对象）</span><br><span class="line">4.强调的是同一个请求内不同方法间的共享</span><br><span class="line">5.不需要重写initialvalue方法 但是必须手动调用set方法</span><br><span class="line"></span><br><span class="line">总结： 1.让某个需要用到的对象在线程建隔离 （每个对象都有自己独立的对象）</span><br><span class="line">      2.在任何方法都可以轻松获取对象</span><br><span class="line">      </span><br><span class="line">使用：</span><br><span class="line">static final ThreadLocal&lt;T&gt; sThreadLocal &#x3D; new ThreadLocal&lt;T&gt;();</span><br><span class="line">sThreadLocal.set()</span><br><span class="line">sThreadLocal.get()</span><br></pre></td></tr></table></figure><h4 id="②-ThreadLocal的好处"><a href="#②-ThreadLocal的好处" class="headerlink" title="②.ThreadLocal的好处"></a><strong>②.ThreadLocal的好处</strong></h4><p><strong>1.线程安全</strong> </p><p><strong>2.不需要加锁 提高执行效率</strong> </p><p><strong>3.高效利用内存和开销</strong> </p><p><strong>4.避免传参的繁琐</strong></p><h4 id="③-ThreadLocal源码分析"><a href="#③-ThreadLocal源码分析" class="headerlink" title="③.ThreadLocal源码分析"></a><strong>③.ThreadLocal源码分析</strong></h4><p><strong>做个不恰当的比喻，从表面上看ThreadLocal相当于维护了一个map，key就是当前的线程，value就是需要存储的对象。</strong></p><p><strong>这里的这个比喻是不恰当的，实际上是ThreadLocal的静态内部类ThreadLocalMap为每个Thread都维护了一个数组table，ThreadLocal确定了一个数组下标，而这个下标就是value存储的对应位置。。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//set 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//获取当前线程</span></span><br><span class="line">      Thread t = Thread.currentThread();</span><br><span class="line">      <span class="comment">//实际存储的数据结构类型</span></span><br><span class="line">      ThreadLocalMap map = getMap(t);</span><br><span class="line">      <span class="comment">//如果存在map就直接set，没有则创建map并set</span></span><br><span class="line">      <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">          map.set(<span class="keyword">this</span>, value);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          createMap(t, value);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//getMap方法</span></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//thred中维护了一个ThreadLocalMap</span></span><br><span class="line">      <span class="keyword">return</span> t.threadLocals;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//createMap</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//实例化一个新的ThreadLocalMap，并赋值给线程的成员变量threadLocals</span></span><br><span class="line">      t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         ThreadLocalMap m = getMap(Thread.currentThread());<span class="comment">//只能删掉自己的 this 传进去 就知道应该删除哪个了</span></span><br><span class="line">         <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">             m.remove(<span class="keyword">this</span>);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p><strong>从上面代码可以看出每个线程持有一个ThreadLocalMap对象。每一个新的线程Thread都会实例化一个ThreadLocalMap并赋值给成员变量threadLocals，使用时若已经存在threadLocals则直接使用已经存在的对象。在一个thread的里面有一个 成员变量 ThreadLocal.ThreadLocalMap threadLocals = null;</strong></p><p><strong>==接下来看看createMap方法中的实例化过程==</strong></p><h4 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a><strong>ThreadLocalMap</strong></h4><h5 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a><strong>set方法</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Entry为ThreadLocalMap静态内部类，对ThreadLocal的若引用</span></span><br><span class="line"><span class="comment">//同时让ThreadLocal和储值形成key-value的关系</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">           <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ThreadLocalMap构造方法</span></span><br><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">        <span class="comment">//内部成员数组，INITIAL_CAPACITY值为16的常量</span></span><br><span class="line">        table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">        <span class="comment">//位运算，结果与取模相同，计算出需要存放的位置</span></span><br><span class="line">        <span class="comment">//threadLocalHashCode比较有趣</span></span><br><span class="line">        <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">        table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过上面的代码不难看出在实例化ThreadLocalMap时创建了一个长度为16的Entry数组。通过hashCode与length位运算确定出一个索引值i，这个i就是被存储在table数组中的位置。</strong></p><p><strong>前面讲过每个线程Thread持有一个ThreadLocalMap类型的实例threadLocals，结合此处的构造方法可以理解成每个线程Thread都持有一个Entry型的数组table，而一切的读取过程都是通过操作这个数组table完成的。</strong></p><p><strong>总结如下：</strong></p><ol><li><strong>对于某一ThreadLocal来讲，他的索引值i是确定的，在不同线程之间访问时访问的是不同的table数组的同一位置即都为table[i]，只不过这个不同线程之间的table是独立的。</strong></li><li><strong>对于同一线程的不同ThreadLocal来讲，这些ThreadLocal实例共享一个table数组，然后每个ThreadLocal实例在table中的索引i是不同的。</strong></li></ol><h5 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a><strong>get()方法</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ThreadLocal中get方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//ThreadLocalMap中getEntry方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">       Entry e = table[i];</span><br><span class="line">       <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="④-ThreadLocal-内存泄露"><a href="#④-ThreadLocal-内存泄露" class="headerlink" title="④.ThreadLocal 内存泄露"></a><strong>④.ThreadLocal 内存泄露</strong></h4><p><strong>1.内存泄露 某个对象不再有用 但是占用的内存却不能被回收</strong></p><p><strong>2.只有两种可能性 key 泄露 或者 value 泄露</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">            &#x2F;** The value associated with this ThreadLocal. *&#x2F;</span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                super(k);</span><br><span class="line">                value &#x3D; v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">弱引用  ThreadLocalMap 的每个Entry 都是一个key的弱引用 同时每个Entry都包含了一个对value的强引用  </span><br><span class="line">正常情况下 当线程终止 保存在Threadlocal 里面的value 会被垃圾回收 因为没有任何的强引用了</span><br><span class="line">但是如果线程不终止 比如线程需要保持很久 那么key对应的value 就不能被回收 比如线程池就是用一个线程反复被使用  因此就有了一下的调用链：</span><br><span class="line">Thread -- ThreadLocalMap -- entry (Key为null) -- value </span><br><span class="line">因为 value 和Thread之间 还存在这个强引用链路 所以导致value无法回收 就可能会出现OOM</span><br><span class="line">JDK已经考虑到这个问题了 所以在set remove rehash 方法中 会扫描 key为null 的 entry </span><br><span class="line">并吧对应的value设置为null  这样value对象 就可以被回收 </span><br><span class="line"></span><br><span class="line">但是如果一个Threadlocal 不被使用 那么实际上set remove rehash 方法也不会被调用 </span><br><span class="line">如果同时线程又不停止 那么调用链就一直存在那么就会导致value的泄露 </span><br></pre></td></tr></table></figure><h4 id="如何避免内存泄露？？"><a href="#如何避免内存泄露？？" class="headerlink" title="如何避免内存泄露？？"></a><strong>如何避免内存泄露？？</strong></h4><p><strong>调用remove方法 就会删除对应的entry对象 可以避免内存泄露 所以使用完ThreadLocal之后 应该调用remove()方法</strong></p><p><strong>在进行get 之前 必须先set 否则可能会报空指针异常吗 不会 返回null 但是进行装箱和拆箱 会出现错误</strong></p><p><strong>共享变量：如果在每个线程中ThreadLocal.set() 进去的东西本来就是多线程共享的同一个对象 比如static对象 那么多个线程的ThreadLocal.get() 取得的还是共享变量本身 还是有并发访问的问题</strong></p><h3 id="7、CAS原子性操作"><a href="#7、CAS原子性操作" class="headerlink" title="7、CAS原子性操作"></a><strong>7、CAS原子性操作</strong></h3><h4 id="①-CAS-是-compare-And-Swap-的缩写-比较交换-类似于java中的乐观锁"><a href="#①-CAS-是-compare-And-Swap-的缩写-比较交换-类似于java中的乐观锁" class="headerlink" title="①. CAS 是 compare And Swap 的缩写 比较交换 类似于java中的乐观锁"></a><strong>①. CAS 是 compare And Swap 的缩写 比较交换 类似于java中的乐观锁</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.geek.AtomicIntegerDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hly</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: CAS(compare and swap)demo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-24 0:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CAS</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//value == expect update value to 10</span></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>,<span class="number">10</span>));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line">        <span class="comment">//value ！= expect 不更新</span></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>,<span class="number">11</span>));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="②-CAS底层原理"><a href="#②-CAS底层原理" class="headerlink" title="②.CAS底层原理"></a><strong>②.CAS底层原理</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>底层大部分都是有unsafe完成，unsafe自己属于JDK– sun包下的，在我查看源码发现unsafe是 是CAS的核心类 由于Java 方法无法直接访问底层 ,需要通过本地(native)方法来访问,UnSafe相当于一个后门,基于该类可以直接操作特定的内存数据. UnSafe类在于sun.misc包中,其内部方法操作可以向C的指针一样直接操作内存,因为Java中CAS操作的执行依赖于UNSafe类的方法.</strong></p><p><strong>CAS的全称compare-And-Swap 它是一条CPU并发原语 它的功能是判断内存某个位置是否为预期值 如果是则更改为新值整个过程是原子的</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CAS并发原语提现在Java语言中就是sun.miscUnSaffe类中的各个方法.调用UnSafe类中的CAS方法,JVM会帮我实现CAS汇编指令.这是一种完全依赖于硬件 功能,通过它实现了原子操作,再次强调,由于CAS是一种系统原语,原语属于操作系统用于范畴,是由若干条指令组成,用于完成某个功能的一个过程,并且原语的执行必须是连续的,在执行过程中不允许中断,也即是说CAS是一条原子指令,不会造成所谓的数据不一致的问题. 简单来说是原子操作</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="③-ABA问题"><a href="#③-ABA问题" class="headerlink" title="③.ABA问题"></a>③.ABA问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CAS算法实现一个比较重要的前提是需要取出内存中某个时刻的数据并在当下的时刻比较并替换 那么这个时间差会导致数据的变化，比如说一个线程one从内存中位置V取出A 这时候另一个线程two也从内存位置取出A 那么线程TWO进行了一些操作将值变为了B 然后TWO又将V位置的数据变为了A 这时候线程one进行CAS操作发现内存仍然是A 然后线程one操作成功。尽管线程oneCAS操作成功但是不代表这个过程是没有问题的，因为对象地址变换了</span><br></pre></td></tr></table></figure><p>解决方法：stampedReference.compareAndSet通过增加版本号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.geek.AtomicIntegerDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hly</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 解决ABA问题</span></span><br><span class="line"><span class="comment"> * CAS：对于内存中的某一个值V，提供一个旧值A和一个新值B。如果提供的旧值V和A相等就把B写入V。这个过程是原子性的。</span></span><br><span class="line"><span class="comment"> * ABA：如果另一个线程修改V值假设原来是A，先修改成B，再修改回成A。当前线程的CAS操作无法分辨当前V值是否发生过变化。</span></span><br><span class="line"><span class="comment"> * 解决方法：AtomicStampedReference。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-23 23:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABASolution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicReference&lt;Integer&gt; atomicReference=<span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; stampedReference=<span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===以下是ABA问题的产生===&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>);</span><br><span class="line">            atomicReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//先暂停1秒 保证完成ABA</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//无法判断是否改变过，所以会写入新值2019</span></span><br><span class="line">            System.out.println(atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>) + <span class="string">&quot;\t&quot;</span> + atomicReference.get());</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;===以下是ABA问题的解决===&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = stampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 第1次版本号&quot;</span> + stamp + <span class="string">&quot;\t值是&quot;</span> + stampedReference.getReference());</span><br><span class="line">            <span class="comment">//暂停1秒钟t3线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            stampedReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, stampedReference.getStamp(), stampedReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 第2次版本号&quot;</span> + stampedReference.getStamp() + <span class="string">&quot;\t值是&quot;</span> + stampedReference.getReference());</span><br><span class="line">            stampedReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>, stampedReference.getStamp(), stampedReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 第3次版本号&quot;</span> + stampedReference.getStamp() + <span class="string">&quot;\t值是&quot;</span> + stampedReference.getReference());</span><br><span class="line">        &#125;, <span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = stampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 第1次版本号&quot;</span> + stamp + <span class="string">&quot;\t值是&quot;</span> + stampedReference.getReference());</span><br><span class="line">            <span class="comment">//保证线程3完成1次ABA</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;=====================&quot;</span>+stampedReference.getStamp());</span><br><span class="line">            <span class="comment">//此时的stamp还是初始值，与当前stamp不同，证明被修改过，所以交换失败</span></span><br><span class="line">            <span class="keyword">boolean</span> result = stampedReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 修改成功否===&quot;</span> + result + <span class="string">&quot;\t最新版本号&quot;</span> + stampedReference.getStamp());</span><br><span class="line">            System.out.println(<span class="string">&quot;最新的值\t&quot;</span> + stampedReference.getReference());</span><br><span class="line">        &#125;, <span class="string">&quot;t4&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;多线程，并发相关&quot;&gt;&lt;a href=&quot;#多线程，并发相关&quot; class=&quot;headerlink&quot; title=&quot;多线程，并发相关&quot;&gt;&lt;/a&gt;&lt;strong&gt;多线程，并发相关&lt;/strong&gt;&lt;/h1&gt;&lt;h3 id=&quot;涉及线程知识及源码解析，最后会有一个高并发，高可</summary>
      
    
    
    
    <category term="Java" scheme="https://cddorz.github.io/categories/Java/"/>
    
    
    <category term="多线程" scheme="https://cddorz.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>练手记录</title>
    <link href="https://cddorz.github.io/2021/03/10/%E7%BB%83%E6%89%8B%E8%AE%B0%E5%BD%95/"/>
    <id>https://cddorz.github.io/2021/03/10/%E7%BB%83%E6%89%8B%E8%AE%B0%E5%BD%95/</id>
    <published>2021-03-10T07:06:11.000Z</published>
    <updated>2021-03-20T11:28:43.190Z</updated>
    
    <content type="html"><![CDATA[<h4 id="写在前言：主要记录练手小项目，当作一个mad文档，也同时记录一些遇到的问题和总结经验。"><a href="#写在前言：主要记录练手小项目，当作一个mad文档，也同时记录一些遇到的问题和总结经验。" class="headerlink" title="写在前言：主要记录练手小项目，当作一个mad文档，也同时记录一些遇到的问题和总结经验。"></a>写在前言：主要记录练手小项目，当作一个mad文档，也同时记录一些遇到的问题和总结经验。</h4><hr><h4 id="1-项目准备"><a href="#1-项目准备" class="headerlink" title="1.项目准备"></a>1.项目准备</h4><p>​    需求分析    模块    功能</p><p>​    库表设计    数据库</p><p>​    详细设计    流程图伪代码的方式</p><p>​    编码环节：</p><p>​        a.环境准备</p><p>​        b.正式进入编码环节</p><p>​    测试     部署上线</p><h4 id="2-技术选型"><a href="#2-技术选型" class="headerlink" title="2.技术选型"></a>2.技术选型</h4><p>​    前端：vue + axios</p><p>​    后端：spring boot   +   mybatis   +  mysql   + tomcat   +Redis</p><h4 id="3-需求分析"><a href="#3-需求分析" class="headerlink" title="3.需求分析"></a>3.需求分析</h4><h5 id="用户模块"><a href="#用户模块" class="headerlink" title="用户模块"></a>用户模块</h5><p>​            a.用户登录</p><p>​            b.用户注册</p><p>​            c.验证码实现</p><p>​            d.欢迎xx用户展示</p><p>​            e.安全退出</p><p>​            f.员工列表展示</p><h5 id="员工模块"><a href="#员工模块" class="headerlink" title="员工模块"></a>员工模块</h5><p>​            g.员工添加</p><p>​            h.员工删除</p><p>​            i.员工修改</p><p>​            j.员工列表加入Redis缓存实现</p><h4 id="4-库表设计"><a href="#4-库表设计" class="headerlink" title="4.库表设计"></a>4.库表设计</h4><p>​            1.分析系统中有哪些表     2.分析表与表之间关系</p><p>​            用户表</p><p>​                        id     username    realname    password    sex    stauts    registerTime（注册时间）</p><p>​            员工表</p><p>​                        id     name    path（头像）    salary    age</p><h4 id="5-编码环节"><a href="#5-编码环节" class="headerlink" title="5.编码环节"></a>5.编码环节</h4><p>​        a.环境搭建：<br>​                springboot + myabtis + mysql      引入员工管理系统页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">项目名： ems_vue</span><br><span class="line">项目中包：</span><br><span class="line">src&#x2F;main&#x2F;java</span><br><span class="line">com.hly.xxx</span><br><span class="line">    .util</span><br><span class="line">    .dao</span><br><span class="line">    .service</span><br><span class="line">    .......</span><br><span class="line">src&#x2F;main&#x2F;resource</span><br><span class="line">application.propertiesspringboot配置文件</span><br><span class="line">application-dev.properties  测试配置</span><br><span class="line">application-prod.properties生产配置</span><br><span class="line">com&#x2F;hly&#x2F;mapper&#x2F;用来存放mybatis的mapper配置文件</span><br><span class="line">com&#x2F;hly&#x2F;sql用来存放项目中数据可文件</span><br><span class="line">static用来存放静态资源</span><br><span class="line"></span><br><span class="line">项目编码：UTF-8</span><br></pre></td></tr></table></figure><h4 id="6-总结："><a href="#6-总结：" class="headerlink" title="6.总结："></a>6.总结：</h4><h5 id="1-收获："><a href="#1-收获：" class="headerlink" title="1.收获："></a>1.收获：</h5><blockquote><p>耗时三天做完了这个小项目，对mvc的结构有了更深层次的理解，对mybatis的集成有了更好的掌握。</p><p>controller: 调取service层方法；返回前端jason数据；与前端交互最深的api</p><p>dao层：与mapper层相连，主要用于操作数据库数据</p><p>entity:实体类</p><p>service:service接口</p><p>serviceImpl: 实现service接口方法的实现类，调用dao层方法，主要用于实现相应的修改数据库的功能</p><p>utils：工具类层：主要是封装好的工具类便于其他接口调用，如 redis工具类</p><p>mapper：集成mybatis用sql语句操作数据库</p><p>会解决git错误，对git指令有了更好的运用</p><p>熟悉Linux操作，并独立解决了某些配置问题</p><p>注：以上为自己理解所写出的东西，有一定的不专业性，这次的小练手让我对错误并不那么惧怕了。</p></blockquote><h5 id="2-不足："><a href="#2-不足：" class="headerlink" title="2.不足："></a>2.不足：</h5><blockquote><p>对创建数据库还不够熟悉，不能根据功能来建造具体的数据库。</p><p>对集成redis还不够熟悉，只懂得redis基础和如何配置</p><p>对于如果没有前端代码，如何测试后端接口还不够熟悉（apipost and postman需要学习如何使用）</p><p>对于如何发短信验证码还不知道</p><p>对于如何保存图片信息还不够熟悉</p></blockquote><h5 id="3-未来展望："><a href="#3-未来展望：" class="headerlink" title="3.未来展望："></a>3.未来展望：</h5><blockquote><p>希望每做完一个项目之后都有自己的思考，因为现在学得不够多的原因，无法拓展，优化功能，但这是一个很重要的点。希望以后能够多思考。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;写在前言：主要记录练手小项目，当作一个mad文档，也同时记录一些遇到的问题和总结经验。&quot;&gt;&lt;a href=&quot;#写在前言：主要记录练手小项目，当作一个mad文档，也同时记录一些遇到的问题和总结经验。&quot; class=&quot;headerlink&quot; title=&quot;写在前言：主</summary>
      
    
    
    
    <category term="日常" scheme="https://cddorz.github.io/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="小项目" scheme="https://cddorz.github.io/tags/%E5%B0%8F%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>springcloud</title>
    <link href="https://cddorz.github.io/2020/12/07/springcloud/"/>
    <id>https://cddorz.github.io/2020/12/07/springcloud/</id>
    <published>2020-12-07T01:15:02.000Z</published>
    <updated>2020-12-07T14:01:23.812Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-2-文章大纲"><a href="#1-2-文章大纲" class="headerlink" title="1.2 文章大纲"></a>1.2 文章大纲</h4><blockquote><p>Spring Cloud 五大组件</p></blockquote><ul><li>服务注册与发现——<strong>Netflix Eureka</strong></li><li>负载均衡：<ul><li>客户端负载均衡——<strong>Netflix Ribbon</strong></li><li>服务端负载均衡：——<strong>Feign</strong>(其也是依赖于Ribbon，只是将调用方式RestTemplete 更改成Service 接口)</li></ul></li><li>断路器——<strong>Netflix Hystrix</strong></li><li>服务网关——<strong>Netflix Zuul</strong></li><li>分布式配置——<strong>Spring Cloud Config</strong></li></ul><h4 id="1-3-常见面试题"><a href="#1-3-常见面试题" class="headerlink" title="1.3 常见面试题"></a>1.3 常见面试题</h4><p>1.1 什么是微服务？</p><p>1.2 微服务之间是如何独立通讯的？</p><p>1.3 SpringCloud 和 Dubbo有那些区别？</p><p>1.4 SpringBoot 和 SpringCloud，请谈谈你对他们的理解</p><p>1.5 什么是服务熔断？什么是服务降级？</p><p>1.6 微服务的优缺点分别是什么？说下你在项目开发中遇到的坑</p><p>1.7 你所知道的微服务技术栈有哪些？列举一二</p><p>1.8 Eureka和Zookeeper都可以提供服务注册与发现的功能，请说说两者的区别</p><p>…</p><h2 id="2-微服务概述"><a href="#2-微服务概述" class="headerlink" title="2. 微服务概述"></a>2. 微服务概述</h2><h4 id="2-1-什么是微服务？"><a href="#2-1-什么是微服务？" class="headerlink" title="2.1 什么是微服务？"></a>2.1 什么是微服务？</h4><blockquote><p>什么是微服务？</p></blockquote><p>微服务(Microservice Architecture) 是近几年流行的一种架构思想，关于它的概念很难一言以蔽之。</p><p>究竟什么是微服务呢？我们在此引用ThoughtWorks 公司的首席科学家 Martin Fowler 于2014年提出的一段话：</p><p>原文：<a href="https://martinfowler.com/articles/microservices.html">https://martinfowler.com/articles/microservices.html</a></p><p>汉化：<a href="https://www.cnblogs.com/liuning8023/p/4493156.html">https://www.cnblogs.com/liuning8023/p/4493156.html</a></p><ul><li>就目前而言，对于微服务，业界并没有一个统一的，标准的定义。</li><li>但通常而言，微服务架构是一种架构模式，或者说是一种架构风格，<strong>它体长将单一的应用程序划分成一组小的服务</strong>，每个服务运行在其独立的自己的进程内，服务之间互相协调，互相配置，为用户提供最终价值，服务之间采用轻量级的通信机制(<strong>HTTP</strong>)互相沟通，每个服务都围绕着具体的业务进行构建，并且能狗被独立的部署到生产环境中，另外，应尽量避免统一的，集中式的服务管理机制，对具体的一个服务而言，应该根据业务上下文，选择合适的语言，工具(<strong>Maven</strong>)对其进行构建，可以有一个非常轻量级的集中式管理来协调这些服务，可以使用不同的语言来编写服务，也可以使用不同的数据存储。</li></ul><blockquote><p>再来从技术维度角度理解下：</p></blockquote><ul><li>微服务化的核心就是将传统的一站式应用，根据业务拆分成一个一个的服务，彻底地去耦合，每一个微服务提供单个业务功能的服务，一个服务做一件事情，从技术角度看就是一种小而独立的处理过程，类似进程的概念，能够自行单独启动或销毁，拥有自己独立的数据库。</li></ul><h4 id="2-2-微服务与微服务架构"><a href="#2-2-微服务与微服务架构" class="headerlink" title="2.2 微服务与微服务架构"></a>2.2 微服务与微服务架构</h4><blockquote><p>微服务</p></blockquote><p>强调的是服务的大小，它关注的是某一个点，是具体解决某一个问题/提供落地对应服务的一个服务应用，狭义的看，可以看作是IDEA中的一个个微服务工程，或者Moudel。IDEA 工具里面使用Maven开发的一个个独立的小Moudel，它具体是使用SpringBoot开发的一个小模块，专业的事情交给专业的模块来做，一个模块就做着一件事情。强调的是一个个的个体，每个个体完成一个具体的任务或者功能。</p><blockquote><p>微服务架构</p></blockquote><p>一种新的架构形式，Martin Fowler 于2014年提出。</p><p>微服务架构是一种架构模式，它体长将单一应用程序划分成一组小的服务，服务之间相互协调，互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务之间采用轻量级的通信机制**(如HTTP)<strong>互相协作，每个服务都围绕着具体的业务进行构建，并且能够被独立的部署到生产环境中，另外，应尽量避免统一的，集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具</strong>(如Maven)**对其进行构建。</p><h4 id="2-3-微服务优缺点"><a href="#2-3-微服务优缺点" class="headerlink" title="2.3 微服务优缺点"></a>2.3 微服务优缺点</h4><blockquote><p>优点</p></blockquote><ul><li>单一职责原则；</li><li>每个服务足够内聚，足够小，代码容易理解，这样能聚焦一个指定的业务功能或业务需求；</li><li>开发简单，开发效率高，一个服务可能就是专一的只干一件事；</li><li>微服务能够被小团队单独开发，这个团队只需2-5个开发人员组成；</li><li>微服务是松耦合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的；</li><li>微服务能使用不同的语言开发；</li><li>易于和第三方集成，微服务允许容易且灵活的方式集成自动部署，通过持续集成工具，如jenkins，Hudson，bamboo；</li><li>微服务易于被一个开发人员理解，修改和维护，这样小团队能够更关注自己的工作成果，无需通过合作才能体现价值；</li><li>微服务允许利用和融合最新技术；</li><li><strong>微服务只是业务逻辑的代码，不会和HTML，CSS，或其他的界面混合;</strong></li><li><strong>每个微服务都有自己的存储能力，可以有自己的数据库，也可以有统一的数据库；</strong></li></ul><blockquote><p>缺点</p></blockquote><ul><li>开发人员要处理分布式系统的复杂性；</li><li>多服务运维难度，随着服务的增加，运维的压力也在增大；</li><li>系统部署依赖问题；</li><li>服务间通信成本问题；</li><li>数据一致性问题；</li><li>系统集成测试问题；</li><li>性能和监控问题；</li></ul><h4 id="2-4-微服务技术栈有那些？"><a href="#2-4-微服务技术栈有那些？" class="headerlink" title="2.4 微服务技术栈有那些？"></a>2.4 微服务技术栈有那些？</h4><table><thead><tr><th><strong>微服务技术条目</strong></th><th>落地技术</th></tr></thead><tbody><tr><td>服务开发</td><td>SpringBoot、Spring、SpringMVC等</td></tr><tr><td>服务配置与管理</td><td>Netfix公司的Archaius、阿里的Diamond等</td></tr><tr><td>服务注册与发现</td><td>Eureka、Consul、Zookeeper等</td></tr><tr><td>服务调用</td><td>Rest、PRC、gRPC</td></tr><tr><td>服务熔断器</td><td>Hystrix、Envoy等</td></tr><tr><td>负载均衡</td><td>Ribbon、Nginx等</td></tr><tr><td>服务接口调用(客户端调用服务的简化工具)</td><td>Fegin等</td></tr><tr><td>消息队列</td><td>Kafka、RabbitMQ、ActiveMQ等</td></tr><tr><td>服务配置中心管理</td><td>SpringCloudConfig、Chef等</td></tr><tr><td>服务路由(API网关)</td><td>Zuul等</td></tr><tr><td>服务监控</td><td>Zabbix、Nagios、Metrics、Specatator等</td></tr><tr><td>全链路追踪</td><td>Zipkin、Brave、Dapper等</td></tr><tr><td>数据流操作开发包</td><td>SpringCloud Stream(封装与Redis，Rabbit，Kafka等发送接收消息)</td></tr><tr><td>时间消息总栈</td><td>SpringCloud Bus</td></tr><tr><td>服务部署</td><td>Docker、OpenStack、Kubernetes等</td></tr></tbody></table><h4 id="2-5-为什么选择SpringCloud作为微服务架构"><a href="#2-5-为什么选择SpringCloud作为微服务架构" class="headerlink" title="2.5 为什么选择SpringCloud作为微服务架构"></a>2.5 为什么选择SpringCloud作为微服务架构</h4><ol><li><p>选型依据</p><ul><li>整体解决方案和框架成熟度</li><li>社区热度</li><li>可维护性</li><li>学习曲线</li></ul></li><li><p>当前各大IT公司用的微服务架构有那些？</p><ul><li><p>阿里：dubbo+HFS</p></li><li><p>京东：JFS</p></li><li><p>新浪：Motan</p></li><li><p>当当网：DubboX</p><p>…</p></li></ul></li><li><p>各微服务框架对比</p></li></ol><table><thead><tr><th><strong>功能点/服务框架</strong></th><th>Netflix/SpringCloud</th><th>Motan</th><th>gRPC</th><th>Thri t</th><th>Dubbo/DubboX</th></tr></thead><tbody><tr><td>功能定位</td><td>完整的微服务框架</td><td>RPC框架，但整合了ZK或Consul，实现集群环境的基本服务注册发现</td><td>RPC框架</td><td>RPC框架</td><td>服务框架</td></tr><tr><td>支持Rest</td><td>是，Ribbon支持多种可拔插的序列号选择</td><td>否</td><td>否</td><td>否</td><td>否</td></tr><tr><td>支持RPC</td><td>否</td><td>是(Hession2)</td><td>是</td><td>是</td><td>是</td></tr><tr><td>支持多语言</td><td>是(Rest形式)</td><td>否</td><td>是</td><td>是</td><td>否</td></tr><tr><td>负载均衡</td><td>是(服务端zuul+客户端Ribbon)，zuul-服务，动态路由，云端负载均衡Eureka（针对中间层服务器）</td><td>是(客户端)</td><td>否</td><td>否</td><td>是(客户端)</td></tr><tr><td>配置服务</td><td>Netfix Archaius，Spring Cloud Config Server 集中配置</td><td>是(Zookeeper提供)</td><td>否</td><td>否</td><td>否</td></tr><tr><td>服务调用链监控</td><td>是(zuul)，zuul提供边缘服务，API网关</td><td>否</td><td>否</td><td>否</td><td>否</td></tr><tr><td>高可用/容错</td><td>是(服务端Hystrix+客户端Ribbon)</td><td>是(客户端)</td><td>否</td><td>否</td><td>是(客户端)</td></tr><tr><td>典型应用案例</td><td>Netflix</td><td>Sina</td><td>Google</td><td>Facebook</td><td></td></tr><tr><td>社区活跃程度</td><td>高</td><td>一般</td><td>高</td><td>一般</td><td>2017年后重新开始维护，之前中断了5年</td></tr><tr><td>学习难度</td><td>中等</td><td>低</td><td>高</td><td>高</td><td>低</td></tr><tr><td>文档丰富程度</td><td>高</td><td>一般</td><td>一般</td><td>一般</td><td>高</td></tr><tr><td>其他</td><td>Spring Cloud Bus为我们的应用程序带来了更多管理端点</td><td>支持降级</td><td>Netflix内部在开发集成gRPC</td><td>IDL定义</td><td>实践的公司比较多</td></tr></tbody></table><h2 id="3-SpringCloud入门概述"><a href="#3-SpringCloud入门概述" class="headerlink" title="3. SpringCloud入门概述"></a>3. SpringCloud入门概述</h2><h4 id="3-1-SpringCloud是什么？"><a href="#3-1-SpringCloud是什么？" class="headerlink" title="3.1 SpringCloud是什么？"></a>3.1 SpringCloud是什么？</h4><p>Spring官网：<a href="https://spring.io/">https://spring.io/</a></p><p><img src= "/img/loading.gif" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zczEuYmRzdGF0aWMuY29tLzcwY0Z1WFNoX1ExWW54R2twb1dLMUhGNmhoeS9pdC91PTM1NzgwMTc3ODAsMTIxODQyMDAyOSZmbT0yNiZncD0wLmpwZw?x-oss-process=image/format,png" alt="img"></p><p><img src= "/img/loading.gif" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zczIuYmRzdGF0aWMuY29tLzcwY0Z2blNoX1ExWW54R2twb1dLMUhGNmhoeS9pdC91PTE2Mzc3ODY4OTcsNzQ1MTM1MjUxJmZtPTI2JmdwPTAuanBn?x-oss-process=image/format,png" alt="img"></p><h4 id="3-2-SpringCloud和SpringBoot的关系"><a href="#3-2-SpringCloud和SpringBoot的关系" class="headerlink" title="3.2 SpringCloud和SpringBoot的关系"></a>3.2 SpringCloud和SpringBoot的关系</h4><ul><li>SpringBoot专注于开苏方便的开发单个个体微服务；</li><li>SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务，整合并管理起来，为各个微服务之间提供：配置管理、服务发现、断路器、路由、为代理、事件总栈、全局锁、决策竞选、分布式会话等等集成服务；</li><li>SpringBoot可以离开SpringCloud独立使用，开发项目，但SpringCloud离不开SpringBoot，属于依赖关系；</li><li>SpringBoot专注于快速、方便的开发单个个体微服务，SpringCloud关注全局的服务治理框架；</li></ul><h4 id="3-3-Dubbo-和-SpringCloud技术选型"><a href="#3-3-Dubbo-和-SpringCloud技术选型" class="headerlink" title="3.3 Dubbo 和 SpringCloud技术选型"></a>3.3 Dubbo 和 SpringCloud技术选型</h4><h5 id="1-分布式-服务治理Dubbo"><a href="#1-分布式-服务治理Dubbo" class="headerlink" title="1. 分布式+服务治理Dubbo"></a>1. 分布式+服务治理Dubbo</h5><p>目前成熟的互联网架构，应用服务化拆分 + 消息中间件</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/12/07/6UQOhiet1gn97dx.png" alt="互联网架构"></p><h5 id="2-Dubbo-和-SpringCloud对比"><a href="#2-Dubbo-和-SpringCloud对比" class="headerlink" title="2. Dubbo 和 SpringCloud对比"></a>2. Dubbo 和 SpringCloud对比</h5><p>可以看一下社区活跃度：</p><p><a href="https://github.com/dubbo">https://github.com/dubbo</a></p><p><a href="https://github.com/spring-cloud">https://github.com/spring-cloud</a></p><p><strong>对比结果：</strong></p><table><thead><tr><th></th><th>Dubbo</th><th>SpringCloud</th></tr></thead><tbody><tr><td>服务注册中心</td><td>Zookeeper</td><td>Spring Cloud Netfilx Eureka</td></tr><tr><td>服务调用方式</td><td>RPC</td><td>REST API</td></tr><tr><td>服务监控</td><td>Dubbo-monitor</td><td>Spring Boot Admin</td></tr><tr><td>断路器</td><td>不完善</td><td>Spring Cloud Netfilx Hystrix</td></tr><tr><td>服务网关</td><td>无</td><td>Spring Cloud Netfilx Zuul</td></tr><tr><td>分布式配置</td><td>无</td><td>Spring Cloud Config</td></tr><tr><td>服务跟踪</td><td>无</td><td>Spring Cloud Sleuth</td></tr><tr><td>消息总栈</td><td>无</td><td>Spring Cloud Bus</td></tr><tr><td>数据流</td><td>无</td><td>Spring Cloud Stream</td></tr><tr><td>批量任务</td><td>无</td><td>Spring Cloud Task</td></tr></tbody></table><p><strong>最大区别：Spring Cloud 抛弃了Dubbo的RPC通信，采用的是基于HTTP的REST方式</strong></p><p>严格来说，这两种方式各有优劣。虽然从一定程度上来说，后者牺牲了服务调用的性能，但也避免了上面提到的原生RPC带来的问题。而且REST相比RPC更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖，这个优点在当下强调快速演化的微服务环境下，显得更加合适。</p><p><strong>总结：</strong>二者解决的问题域不一样：Dubbo的定位是一款RPC框架，而SpringCloud的目标是微服务架构下的一站式解决方案。</p><h4 id="3-4-SpringCloud能干嘛？"><a href="#3-4-SpringCloud能干嘛？" class="headerlink" title="3.4 SpringCloud能干嘛？"></a>3.4 SpringCloud能干嘛？</h4><ul><li>Distributed/versioned configuration 分布式/版本控制配置</li><li>Service registration and discovery 服务注册与发现</li><li>Routing 路由</li><li>Service-to-service calls 服务到服务的调用</li><li>Load balancing 负载均衡配置</li><li>Circuit Breakers 断路器</li><li>Distributed messaging 分布式消息管理</li><li>…</li></ul><h4 id="3-5-SpringCloud下载"><a href="#3-5-SpringCloud下载" class="headerlink" title="3.5 SpringCloud下载"></a>3.5 SpringCloud下载</h4><p>官网：<a href="http://projects.spring.io/spring-cloud/">http://projects.spring.io/spring-cloud/</a></p><p>版本号有点特别：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200521130004420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>SpringCloud没有采用数字编号的方式命名版本号，而是采用了伦敦地铁站的名称，<strong>同时根据字母表的顺序来对应版本时间顺序</strong>，比如最早的Realse版本：Angel，第二个Realse版本：Brixton，然后是Camden、Dalston、Edgware，目前最新的是Hoxton SR4 CURRENT GA通用稳定版。</p><p><strong>自学参考书：</strong></p><ul><li>SpringCloud Netflix 中文文档：<a href="https://springcloud.cc/spring-cloud-netflix.html">https://springcloud.cc/spring-cloud-netflix.html</a></li><li>SpringCloud 中文API文档(官方文档翻译版)：<a href="https://springcloud.cc/spring-cloud-dalston.html">https://springcloud.cc/spring-cloud-dalston.html</a></li><li>SpringCloud中国社区：<a href="http://springcloud.cn/">http://springcloud.cn/</a></li><li>SpringCloud中文网：<a href="https://springcloud.cc/">https://springcloud.cc</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-2-文章大纲&quot;&gt;&lt;a href=&quot;#1-2-文章大纲&quot; class=&quot;headerlink&quot; title=&quot;1.2 文章大纲&quot;&gt;&lt;/a&gt;1.2 文章大纲&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Spring Cloud 五大组件&lt;/p&gt;
&lt;/blockquot</summary>
      
    
    
    
    <category term="springcloud" scheme="https://cddorz.github.io/categories/springcloud/"/>
    
    
    <category term="微服务" scheme="https://cddorz.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>token、session、cookie那些事</title>
    <link href="https://cddorz.github.io/2020/12/01/token%E3%80%81session%E3%80%81cookie/"/>
    <id>https://cddorz.github.io/2020/12/01/token%E3%80%81session%E3%80%81cookie/</id>
    <published>2020-12-01T02:55:08.000Z</published>
    <updated>2020-12-01T03:10:25.889Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、美好的旧时光"><a href="#1、美好的旧时光" class="headerlink" title="1、美好的旧时光"></a>1、美好的旧时光</h4><p>我经常怀念三十年前那美好的旧时光， 工作很轻松， 生活很悠闲。</p><p>上班的时候偶尔有些HTTP的请求发到我这里， 我简单的看一下， 取出相对应的html文档，图片，发回去就可以了， 然后就可以继续喝茶聊天。</p><p>我的创造者们对我很严格， 他们制定的一个简单HTTP协议， 就是请求加响应，  尤其是我不用记住是谁刚刚发了HTTP请求，  每个请求对我来说都是全新的！</p><p>邮件服务器很羡慕我， 他说：老弟，你的生活太惬意了，  哪像我， 每次有人从客户端访问邮箱， 我都得专门给他建立一个会话， 来处理他发的消息， 你倒好， 完全不用管理会话。</p><p>这是由应用的特性决定的， 如果邮件服务器不管理会话， 那多个人之间的邮件消息就会完全混到一起了， 乱作一团了。</p><p>而30年前的Web 基本上就是文档的浏览而已， 既然是浏览，我作为一个服务器， 为什么要记住谁在一段时间里都浏览了什么文档呢？</p><h4 id="2、Session"><a href="#2、Session" class="headerlink" title="2、Session"></a>2、Session</h4><p>但是好日子没持续多久， 很快大家就不满足于静态的Html 文档了， 交互式的Web应用开始兴起， 尤其是论坛， 在线购物等网站。</p><p>我马上就遇到了和邮件服务器一样的问题， 那就是必须管理会话，必须记住哪些人登录系统，  哪些人往自己的购物车中放了商品，  也就是说我必须把每个人区分开。</p><p>这对我来说是个不小的挑战， 由于HTTP协议的无状态特性， 我必须加点小手段，才能完成会话管理。</p><p>我想出的办法就是给大家发一个会话标识(session id), 说白了就是一个随机的字符串，每个人收到的都不一样，  每次大家向我发起HTTP请求的时候，把这个字符串给一并捎过来， 这样我就能区分开谁是谁了。</p><h4 id="3、沉重的负担"><a href="#3、沉重的负担" class="headerlink" title="3、沉重的负担"></a>3、沉重的负担</h4><p>大家都很高兴， 可是我就不爽了。</p><p>每个人只需要保存自己的session id，而我需要保存所有人的session id ！  如果访问我的人多了， 就得由成千上万，甚至几十万个。</p><p>这对我来说是一个巨大的开销 ， 严重的限制了我的扩展能力， 比如说我用两个机器组成了一个集群， 小F通过机器A登录了系统，  那session id会保存在机器A上，  假设小F的下一次请求被转发到机器B怎么办？  机器B可没有小F的 session id啊。</p><p>有时候我会采用一点小伎俩： session sticky ， 就是让小F的请求一直粘连在机器A上， 但是这也不管用， 要是机器A挂掉了， 还得转到机器B去。</p><p>那我只好做session 的复制了， 把session id  在两个机器之间搬来搬去， 快累死了。</p><p><img src= "/img/loading.gif" data-lazy-src="http://mmbiz.qpic.cn/mmbiz_png/KyXfCrME6ULYaJ4jzPaPeibAKbBdpJ73vNJe66yhKRkVOxqS9gxftlwCuh8yicUcPPFaMMLv0oia9Xzf5IutmIPwQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>后来有个叫Memcached的给我支了招： 把session id 集中存储到一个地方， 所有的机器都来访问这个地方的数据， 这样一来，就不用复制了， 但是增加了单点失败的可能性， 要是那个负责session 的机器挂了，  所有人都得重新登录一遍， 估计得被人骂死。</p><p><img src= "/img/loading.gif" data-lazy-src="http://mmbiz.qpic.cn/mmbiz_png/KyXfCrME6ULYaJ4jzPaPeibAKbBdpJ73vwDyicwnvVayaKBpxXY4W5mUgQDwHD7Iwu3yY2OhV4qXG49oMbIgQP0A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>我也尝试把这个单点的机器也搞出集群，增加可靠性， 但不管如何， 这小小的session 对我来说是一个沉重的负担。</p><h4 id="4、时间换空间"><a href="#4、时间换空间" class="headerlink" title="4、时间换空间"></a>4、时间换空间</h4><p>这几天的晚上我一直在思考， 我为什么要保存这可恶的session呢， 只让每个客户端去保存该多好？</p><p>可是如果我不保存这些session id ,  我怎么验证客户端发给我的session id 的确是我生成的呢？  如果我不去验证，我都不知道他们是不是合法登录的用户， 那些不怀好意的家伙们就可以伪造session id , 为所欲为了。</p><p>嗯，对了，关键点就是验证 ！</p><p>比如说， 小F已经登录了系统， 我给他发一个令牌(token)， 里边包含了小F的 user id， 下一次小F 再次通过Http 请求访问我的时候， 把这个token 通过Http header 带过来不就可以了。</p><p>不过这和session id没有本质区别啊， 任何人都可以可以伪造，  所以我得想点儿办法， 让别人伪造不了。</p><p>那就对数据做一个签名吧， 比如说我用HMAC-SHA256 算法，加上一个只有我才知道的密钥，  对数据做一个签名， 把这个签名和数据一起作为token ，  由于密钥别人不知道， 就无法伪造token了。</p><p><img src= "/img/loading.gif" data-lazy-src="http://mmbiz.qpic.cn/mmbiz_png/KyXfCrME6ULYaJ4jzPaPeibAKbBdpJ73vGvJXhJuyPdxDdLibYVQpLATicy3FfQyGIvPe8y2iaGicbmWqVgEXWdOGqA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>这个token 我不保存，  当小F把这个token 给我发过来的时候，我再用同样的HMAC-SHA256 算法和同样的密钥，对数据再计算一次签名， 和token 中的签名做个比较， 如果相同， 我就知道小F已经登录过了，并且可以直接取到小F的user id ,  如果不相同， 数据部分肯定被人篡改过， 我就告诉发送者： 对不起，没有认证。</p><p><img src= "/img/loading.gif" data-lazy-src="http://mmbiz.qpic.cn/mmbiz_png/KyXfCrME6ULYaJ4jzPaPeibAKbBdpJ73vicfOmZHQhQ7e6Wjk7licKBMh38rPZfnEQxAibWXjY84P0icEVoFU51ibwiaQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>Token 中的数据是明文保存的（虽然我会用Base64做下编码， 但那不是加密）， 还是可以被别人看到的， 所以我不能在其中保存像密码这样的敏感信息。</p><p>当然， 如果一个人的token 被别人偷走了， 那我也没办法， 我也会认为小偷就是合法用户， 这其实和一个人的session id 被别人偷走是一样的。</p><p>这样一来， 我就不保存session id 了， 我只是生成token , 然后验证token ，  我用我的CPU计算时间获取了我的session 存储空间 ！</p><p>解除了session id这个负担，  可以说是无事一身轻， 我的机器集群现在可以轻松地做水平扩展， 用户访问量增大， 直接加机器就行。  这种无状态的感觉实在是太好了！</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>​         cookie 是一个非常具体的东西，指的就是浏览器里面能永久存储的一种数据，仅仅是浏览器实现的一种数据存储功能。 cookie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该 cookie发送给服务器。由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁 盘空间，所以每个域的cookie数量是有限的。</p><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>​    session 从字面上讲，就是会话。这个就类似于你和一个人交谈，你怎么知道当前和你交谈的是张三而不是李四呢？对方肯定有某种 特征（长相等）表明他就是张三。 session 也是类似的道理，服务器要知道当前发请求给自己的是谁。为了做这种区分，服务器就要给每个客户端分配不同的“身份标 识”，然后客户端每次向服务器发请求的时候，都带上这个“身份标识”，服务器就知道这个请求来自于谁了。至于客户端怎么保存这个 “身份标识”，可以有很多种方式，对于浏览器客户端，大家都默认采用 cookie 的方式。 服务器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。这种用户信息存储方式相对cookie来说 更安全，可是session有一个缺陷：如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失</p><h4 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h4><p>   基于Token的验证原理</p><p>基于Token的身份验证是无状态的，我们不将用户信息存在服务器或Session中。</p><p>这种概念解决了在服务端存储信息时的许多问题</p><p>　　NoSession意味着你的程序可以根据需要去增减机器，而不用去担心用户是否登录。</p><p>基于Token的身份验证的过程如下:</p><p>1.用户通过用户名和密码发送请求。</p><p>2.程序验证。</p><p>3.程序返回一个签名的token 给客户端。</p><p>4.客户端储存token,并且每次用于每次发送请求。</p><p>5.服务端验证token并返回数据。</p><p> 每一次请求都需要token。token应该在HTTP的头部发送从而保证了Http请求无状态。我们同样通过设置服务器属性Access-Control</p><p>Allow-Origin:* ，让服务器能接受到来自所有域的请求。需要主要的是，在ACAO头部标明(designating)*时，不得带有像HTTP认</p><p>证，客户端SSL证书和cookies的证书。</p><p> 实现思路:</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/12/01/ozayftpLJ4gNXin.png" alt="P_A_2_0K8_UC9_I3_IQYYI1.png"></p><p>1.用户登录校验，校验成功后就返回Token给客户端。</p><p>2.客户端收到数据后保存在客户端</p><p>3.客户端每次访问API是携带Token到服务器端。</p><p>4.服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码</p><p>当我们在程序中认证了信息并取得token之后，我们便能通过这个Token做许多的事情。</p><p>我们甚至能基于创建一个基于权限的token传给第三方应用程序，这些第三方程序能够获取到我们的数据（当然只有在我们允许的特</p><p>定的token）</p><p>Tokens的优势</p><p>无状态、可扩展</p><p>在客户端存储的Tokens是无状态的，并且能够被扩展。基于这种无状态和不存储Session信息，负载负载均衡器能够将用户信息从一</p><p>个服务传到其他服务器上。</p><p>如果我们将已验证的用户的信息保存在Session中，则每次请求都需要用户向已验证的服务器发送验证信息(称为Session亲和性)。用</p><p>户量大时，可能会造成</p><p> 一些拥堵。</p><p>但是不要着急。使用tokens之后这些问题都迎刃而解，因为tokens自己hold住了用户的验证信息。</p><p>安全性</p><p>请求中发送token而不再是发送cookie能够防止CSRF(跨站请求伪造)。即使在客户端使用cookie存储token，cookie也仅仅是一个存储</p><p>机制而不是用于认证。不将信息存储在Session中，让我们少了对session操作。 </p><p>token是有时效的，一段时间之后用户需要重新验证。我们也不一定需要等到token自动失效，token有撤回的操作，通过token</p><p>revocataion可以使一个特定的token或是一组有相同认证的token无效。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1、美好的旧时光&quot;&gt;&lt;a href=&quot;#1、美好的旧时光&quot; class=&quot;headerlink&quot; title=&quot;1、美好的旧时光&quot;&gt;&lt;/a&gt;1、美好的旧时光&lt;/h4&gt;&lt;p&gt;我经常怀念三十年前那美好的旧时光， 工作很轻松， 生活很悠闲。&lt;/p&gt;
&lt;p&gt;上班的时候偶尔</summary>
      
    
    
    
    <category term="JavaWeb" scheme="https://cddorz.github.io/categories/JavaWeb/"/>
    
    
    <category term="token" scheme="https://cddorz.github.io/tags/token/"/>
    
  </entry>
  
  <entry>
    <title>网络编程</title>
    <link href="https://cddorz.github.io/2020/11/29/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>https://cddorz.github.io/2020/11/29/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</id>
    <published>2020-11-29T14:16:19.000Z</published>
    <updated>2020-11-29T14:18:40.274Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p><strong>计算机网络：</strong></p><blockquote><p>计算机网络是指将地理]位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统,网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。</p></blockquote><p><strong>网络编程的目的：</strong></p><p>无限电台、传播交流信息、数据交换、通信…</p><p><strong>想要达到这个效果需要什么：</strong></p><ol><li>如何准确的定位网络上的一台主机 ip 地址：端口，定位到这个计算机上的某个资源</li><li>找到了这个主机，如何传输数据？</li></ol><p><strong>概念B/S与C/S：</strong></p><p>javaweb： 网页编程 B/S</p><p>网络编程：TCP/IP C/S</p><h3 id="2-网络通讯的要素"><a href="#2-网络通讯的要素" class="headerlink" title="2.网络通讯的要素"></a>2.网络通讯的要素</h3><p>如何实现网络的通信？</p><p><strong>通信双方的地址：</strong></p><ul><li>ip</li><li>端口号</li></ul><p><strong>规则：网络通信协议</strong></p><p><strong>TCP/IP参考模型：</strong></p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-7kHrwRVX-1589985207621)(C:\Users\86150\Desktop\狂神java\第一阶段\网络编程\images\TCP-IP.png)]</p><p>小结：</p><ol><li>网络编程中的两个主要问题：<ul><li>如何准确的定位到网络上的一台或者多台主机</li><li>找到主机之后如何进行通信</li></ul></li><li>网络编程中的要素：<ul><li>IP和端口号 IP</li><li>网络通信协议 UDP、TCP</li></ul></li><li>万物皆对象：<ul><li>在java中一定存在与网络通信相关的类</li><li>没有的类需要自己进行相关的定义</li></ul></li></ol><h3 id="3-IP"><a href="#3-IP" class="headerlink" title="3. IP"></a>3. IP</h3><p>ip地址：InetAdress</p><ul><li><p>唯一定位一台网络上的计算机</p></li><li><p>127.0.0.1：本机地址 即localhost</p></li><li><p>ip地址的分类</p><ul><li><p>ipv4/ipv6</p><ul><li><p>IPV4：4个字节组成。约42亿，北美占了30亿，亚洲4亿，2011年已经用完</p></li><li><p>IPV6：12位。8个无符号整数，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1111</span>:<span class="number">2222</span>:<span class="number">3333</span>:<span class="number">4444</span>:<span class="number">5555</span>:<span class="number">6666</span>:aaaa:cccc</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>公网（互联网）和私网（局域网）</p><ul><li>ABCD类地址</li><li>192.1688.xx.xx，专门给组织内部使用</li></ul></li></ul></li><li><p>域名：记忆IP</p></li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMyip</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查询本机地址</span></span><br><span class="line">        InetAddress InetAddress1 = InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        InetAddress InetAddress2 = InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        InetAddress InetAddress3 = InetAddress.getLocalHost();</span><br><span class="line">        System.out.println(InetAddress1);</span><br><span class="line">        System.out.println(InetAddress2);</span><br><span class="line">        System.out.println(InetAddress3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查询网站的ip 地址</span></span><br><span class="line">        InetAddress InetAddress4 = InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">        System.out.println(InetAddress4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//常用的方法</span></span><br><span class="line"></span><br><span class="line">        System.out.println(InetAddress4.getCanonicalHostName()); <span class="comment">//规范的名字</span></span><br><span class="line">        System.out.println(InetAddress4.getHostAddress()); <span class="comment">//ip</span></span><br><span class="line">        System.out.println(InetAddress4.getHostName()); <span class="comment">//域名或者自己电脑的名字</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728</span></span><br></pre></td></tr></table></figure><h3 id="4-端口"><a href="#4-端口" class="headerlink" title="4. 端口"></a>4. 端口</h3><p>端口表示计算机上的一个程序的进程</p><ul><li><p>不同得端口用来区分不同的软件</p></li><li><p>规定端口的范围：0~65535</p></li><li><p>TCP和UDP分别占有65535个，即电脑端口总数为65535*2</p></li><li><p>端口分类</p><ul><li><p>公有端口 0~1023</p><ul><li>HTTP : 80</li><li>HTTPS : 443</li><li>FTP : 21</li><li>Telent : 23</li></ul></li><li><p>程序注册端口：1024~49151，分配用户或者程序</p><ul><li>Tomcat：8080</li><li>MySQL：3306</li><li>Oracle：1521</li></ul></li><li><p>动态、私有：49152~65535</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano <span class="comment">//查看所有的端口</span></span><br><span class="line">netstat -ano |findstr “端口号” <span class="comment">//查看指定的端口号</span></span><br><span class="line">tasklist|findstr <span class="string">&quot;端口号&quot;</span>  <span class="comment">//查看指定端口号的进程 </span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pers.mobian.socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSocket02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InetSocketAddress inetSocketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8080</span>);</span><br><span class="line">        InetSocketAddress inetSocketAddress2 = <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>,<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(inetSocketAddress);</span><br><span class="line">        System.out.println(inetSocketAddress2);</span><br><span class="line"></span><br><span class="line">        System.out.println(inetSocketAddress.getAddress());<span class="comment">//获取地址</span></span><br><span class="line">        System.out.println(inetSocketAddress.getHostName());<span class="comment">//获取主机名字</span></span><br><span class="line">        System.out.println(inetSocketAddress.getPort());<span class="comment">//获取端口</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718</span></span><br></pre></td></tr></table></figure><h3 id="5-网络通信协议"><a href="#5-网络通信协议" class="headerlink" title="5.网络通信协议"></a>5.网络通信协议</h3><blockquote><p>网络通信协议：速率、传输码率、代码结构、传输控制…</p></blockquote><p>TCP/IP协议簇：是一组协议</p><ul><li>TCP：用户传输协议</li><li>UDP：用户数据报协议</li><li>IP：网络互连协议</li></ul><p><strong>TCP与UDP的对比：</strong></p><p>TCP：打电话</p><ul><li><p>连接稳定</p></li><li><p>三次握手、四次挥手</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最少需要三次，保证稳定连接！&lt;连接&gt;</span></span><br><span class="line">A：你瞅啥？</span><br><span class="line">B：瞅你咋地？</span><br><span class="line">A：干一场</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//四次挥手 &lt;断开&gt;</span></span><br><span class="line">A：我要走了</span><br><span class="line">B：你真的要走了吗？</span><br><span class="line">B：你真的真的要走了吗？</span><br><span class="line">A：我真的要走了</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure></li><li><p>客户端、服务器</p></li><li><p>传输完成、释放连接、效率低</p></li></ul><p>UDP:发短信</p><ul><li>不连接、不稳定</li><li>客户端、服务器：没有明确的界限</li><li>不管有没有准备好，都可以发送给你</li><li>DDOS：洪水攻击（发送大量的信息，堵塞端口，饱和攻击）</li></ul><h3 id="6-TCP"><a href="#6-TCP" class="headerlink" title="6.TCP"></a>6.TCP</h3><p><strong>文字传输：</strong></p><ol><li>客户端：</li></ol><ul><li>连接服务器 (Socket)</li><li>发送消息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pers.mobian.socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClientSocket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1、要知道服务器得地址、端口号</span></span><br><span class="line">            InetAddress serverIP = InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> port = <span class="number">9999</span>;</span><br><span class="line">            <span class="comment">//2、创建一个socket连接</span></span><br><span class="line">            socket = <span class="keyword">new</span> Socket(serverIP, port);</span><br><span class="line">            <span class="comment">//3、发送IO流信息</span></span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">            os.write(<span class="string">&quot;你好，世界!&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//关闭资源，对关闭得资源进行一个判定，如果没有开启则不需要关闭</span></span><br><span class="line">            <span class="keyword">if</span>(os!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(socket!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637383940414243444546</span></span><br></pre></td></tr></table></figure><ol><li>服务器:</li></ol><ul><li>建立服务器的端口号 ServerSocket</li><li>等待用户的链接 accept</li><li>接受用户的信息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pers.mobian.socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务器端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServersSocket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1、给自己新建一个端口号</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//2、等待客户端进行连接</span></span><br><span class="line">        Socket socket = serverSocket.accept();</span><br><span class="line">        <span class="comment">//3、读取客户端的消息</span></span><br><span class="line">        InputStream inputStream = socket.getInputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、管道流</span></span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = inputStream.read(buffer))!= -<span class="number">1</span>)&#123;</span><br><span class="line">            baos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(baos.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5、关闭资源（后开先关）</span></span><br><span class="line">        baos.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536</span></span><br></pre></td></tr></table></figure><p><strong>文件上传:</strong></p><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">package</span> pers.mobian.socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClientSocket2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1、创建一个Socket连接</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//2、创建一个输出流</span></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        <span class="comment">//3、读取文件</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;dj.jpg&quot;</span>));</span><br><span class="line">        <span class="comment">//4、写出文件</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            os.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5、确定服务器接受完毕，才能断开连接</span></span><br><span class="line">        InputStream inputStream = socket.getInputStream();</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] buffer2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len2;</span><br><span class="line">        <span class="keyword">while</span> ((len2=inputStream.read(buffer2))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            baos.write(buffer2,<span class="number">0</span>,len2);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(baos.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6、关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">        os.close();</span><br><span class="line">        os.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839</span></span><br></pre></td></tr></table></figure><p><strong>服务器:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务器</span></span><br><span class="line"><span class="keyword">package</span> pers.mobian.socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServersSocket2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1、创建服务</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//2、监听客户端得连接</span></span><br><span class="line">        Socket socket = serverSocket.accept();<span class="comment">//阻塞式监听，会一直等待</span></span><br><span class="line">        <span class="comment">//3、获取输入流</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="comment">//4、文件输出</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;3.jpg&quot;</span>));</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5、通知客户端，我接受完毕了</span></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        os.write(<span class="string">&quot;我接受完了&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">//6、关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">        is.close();</span><br><span class="line">        socket.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233</span></span><br></pre></td></tr></table></figure><h3 id="7-Tomcat"><a href="#7-Tomcat" class="headerlink" title="7.Tomcat"></a>7.Tomcat</h3><p><strong>服务端:</strong></p><ul><li>自定义 S</li><li>Tomcat服务器 S</li></ul><p><strong>客户端：</strong></p><ul><li>自定义 C</li><li>浏览器 B</li></ul><h3 id="8-UDP"><a href="#8-UDP" class="headerlink" title="8.UDP"></a>8.UDP</h3><p><strong>UDP没有服务器和客户端得概念，只有发送端和接收端得概念</strong></p><p><strong>发送端:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pers.mobian.socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClientSocket3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1、建立一个Socket</span></span><br><span class="line">        DatagramSocket socket = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、建包</span></span><br><span class="line">        String msg = <span class="string">&quot;你好,世界&quot;</span>;</span><br><span class="line">        InetAddress localhost = InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">9090</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//参数得列表分别是：数据，数据长度始，数据长度终，地址，端口号</span></span><br><span class="line">        DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(msg.getBytes(),<span class="number">0</span>,msg.getBytes().length,localhost,port);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、发送包</span></span><br><span class="line">        socket.send(packet);</span><br><span class="line">        <span class="comment">//4、关闭资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526</span></span><br></pre></td></tr></table></figure><p><strong>接收端：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pers.mobian.socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServersSocket3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1、设置开放端口</span></span><br><span class="line">        DatagramSocket socket = <span class="keyword">new</span> DatagramSocket(<span class="number">9090</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、准备接受数据包</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(buffer, <span class="number">0</span>, buffer.length);</span><br><span class="line">        socket.receive(packet);</span><br><span class="line"></span><br><span class="line">        System.out.println(packet.getAddress().getHostAddress());</span><br><span class="line">        <span class="comment">//3、将需要打印得数据进行格式转换</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(packet.getData(),<span class="number">0</span>,packet.getLength()));</span><br><span class="line"></span><br><span class="line">        socket.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324</span></span><br></pre></td></tr></table></figure><h3 id="9-URL"><a href="#9-URL" class="headerlink" title="9.URL"></a>9.URL</h3><p><a href="https://www.baidu.com/">https://www.baidu.com/</a></p><p>统一资源定位符：定位资源的，定位互联网上的某一个资源</p><p>DNS 域名解析 <a href="http://www.baidu.com/">www.baidu.com</a> xxx.x.x.x</p><blockquote><p>协议：//IP地址：端口/项目名/资源</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pers.mobian.udp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestURL</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MalformedURLException </span>&#123;</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">&quot;http://localhost:8080/dajie/index.jsp?username=dajie&amp;password=123456&quot;</span>);</span><br><span class="line">        System.out.println(url.getProtocol());<span class="comment">//使用的协议</span></span><br><span class="line">        System.out.println(url.getHost());<span class="comment">//主机IP</span></span><br><span class="line">        System.out.println(url.getPort());<span class="comment">//使用的端口号</span></span><br><span class="line">        System.out.println(url.getPath());<span class="comment">//文件路径</span></span><br><span class="line">        System.out.println(url.getFile());<span class="comment">//文件的全路径</span></span><br><span class="line">        System.out.println(url.getQuery());<span class="comment">//参数列表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;网络编程&quot;&gt;&lt;a href=&quot;#网络编程&quot; class=&quot;headerlink&quot; title=&quot;网络编程&quot;&gt;&lt;/a&gt;网络编程&lt;/h2&gt;&lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.概述&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="后端" scheme="https://cddorz.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="网络" scheme="https://cddorz.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>浅层神经网络</title>
    <link href="https://cddorz.github.io/2020/11/27/%E6%B5%85%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>https://cddorz.github.io/2020/11/27/%E6%B5%85%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</id>
    <published>2020-11-27T12:43:21.000Z</published>
    <updated>2020-11-27T12:45:35.331Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-神经网络表示"><a href="#1-神经网络表示" class="headerlink" title="1. 神经网络表示"></a><strong>1. 神经网络表示</strong></h2><p>简单神经网络示意图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-57166f7b5bb26904e62433ffffd01e61_720w.jpg" alt="img"></p><p>神经网络基本的结构和符号可以从上面的图中看出，这里不再复述。</p><p>主要需要注意的一点，是层与层之间参数矩阵的规格大小：</p><ul><li><p>输入层和隐藏层之间</p></li><li><ul><li><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=w%5E%7B%5B1%5D%7D-%3E(4,3)" alt="[公式]"> ：前面的4是隐层神经元的个数，后面的3是输入层神经元的个数；</li><li><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=b%5E%7B%5B1%5D%7D-%3E(4,1)" alt="[公式]"> ：和隐藏层的神经元个数相同；</li></ul></li><li><p>隐藏层和输出层之间</p></li><li><ul><li><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=w%5E%7B%5B1%5D%7D-%3E(1,4)" alt="[公式]"> ：前面的1是输出层神经元的个数，后面的4是隐层神经元的个数；</li><li><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=b%5E%7B%5B1%5D%7D-%3E(1,1)" alt="[公式]"> ：和输出层的神经元个数相同；</li></ul></li></ul><p>由上面我们可以总结出，在神经网络中，我们以相邻两层为观测对象，前面一层作为输入，后面一层作为输出，两层之间的w参数矩阵大小为 <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=(n_%7Bout%7D,n_%7Bin%7D)" alt="[公式]"> ，b参数矩阵大小为 <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=(n_%7Bout%7D,1)" alt="[公式]"> ，这里是作为 <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=z+=+wX+b" alt="[公式]"> 的线性关系来说明的，在神经网络中， <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=w%5E%7B%5Bi%5D%7D=w%5E%7BT%7D" alt="[公式]"> 。</p><p>在logistic regression中，一般我们都会用 <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=(n_%7Bin%7D,n_%7Bout%7D)" alt="[公式]"> 来表示参数大小，计算使用的公式为： <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=z+=+w%5E%7BT%7DX+b" alt="[公式]"> ，要注意这两者的区别。</p><h2 id="2-计算神经网络的输出"><a href="#2-计算神经网络的输出" class="headerlink" title="2. 计算神经网络的输出"></a><strong>2. 计算神经网络的输出</strong></h2><p>除输入层之外每层的计算输出可由下图总结出：</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-722991018136c95bff18be8e2932d987_720w.jpg" alt="img"></p><p>其中，每个结点都对应这两个部分的运算，z运算和a运算。 在编程中，我们使用向量化去计算神经网络的输出：</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic3.zhimg.com/80/v2-6eb2bc22d2d7953ab4fb4115a2a33a96_720w.jpg" alt="img"></p><p>在对应图中的神经网络结构，我们只用Python代码去实现右边的四个公式即可实现神经网络的输出计算。</p><h2 id="3-向量化实现"><a href="#3-向量化实现" class="headerlink" title="3. 向量化实现"></a><strong>3. 向量化实现</strong></h2><p>假定在m个训练样本的神经网络中，计算神经网络的输出，用向量化的方法去实现可以避免在程序中使用for循环，提高计算的速度。</p><p>下面是实现向量化的解释：</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-1615f9d56a1561b3aef3bc4deb895110_720w.jpg" alt="img"></p><p>由图可以看出，在m个训练样本中，每次计算都是在重复相同的过程，均得到同样大小和结构的输出，所以利用向量化的思想将单个样本合并到一个矩阵中，其大小为 <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=(x_%7Bn%7D,m)" alt="[公式]"> ，其中 <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=x_%7Bn%7D" alt="[公式]"> 表示每个样本输入网络的神经元个数，也可以认为是单个样本的特征数，m表示训练样本的个数。</p><p>通过向量化，可以更加便捷快速地实现神经网络的计算。</p><h2 id="4-激活函数的选择"><a href="#4-激活函数的选择" class="headerlink" title="4. 激活函数的选择"></a><strong>4. 激活函数的选择</strong></h2><p>几种不同的激活函数 <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=g(x)" alt="[公式]"> ：</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-58168196b7618a2dfe6b2f02a714fabb_720w.jpg" alt="img"></p><ul><li><p>sigmoid：<img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=a+=+%5Cdfrac%7B1%7D%7B1+e%5E%7B-z%7D%7D" alt="[公式]"></p></li><li><ul><li>导数： <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=a%27+=+a(1-a)" alt="[公式]"></li></ul></li><li><p>tanh： <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=a=%5Cdfrac%7Be%5E%7Bz%7D-e%5E%7B-z%7D%7D%7Be%5E%7Bz%7D+e%5E%7B-z%7D%7D" alt="[公式]"></p></li><li><ul><li>导数：</li></ul></li><li><p>ReLU（修正线性单元）： <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=a+=+%5Cmax(0,z)" alt="[公式]"></p></li><li><p>Leaky ReLU： <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=a+=+%5Cmax(0.01z,z)" alt="[公式]"></p></li></ul><p><strong>激活函数的选择：</strong></p><p>sigmoid函数和tanh函数比较：</p><ul><li>隐藏层：tanh函数的表现要好于sigmoid函数，因为tanh取值范围为 <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=%5B-1,+1%5D" alt="[公式]"> ，输出分布在0值的附近，均值为0，从隐藏层到输出层数据起到了归一化（均值为0）的效果。</li><li>输出层：对于二分类任务的输出取值为 <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=%5C%7B0,1%5C%7D" alt="[公式]"> ，故一般会选择sigmoid函数。</li></ul><p>然而sigmoid和tanh函数在当 <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=%7Cz%7C" alt="[公式]"> 很大的时候，梯度会很小，在依据梯度的算法中，更新在后期会变得很慢。在实际应用中，要使 <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=%7Cz%7C" alt="[公式]"> 尽可能的落在0值附近。</p><p>ReLU弥补了前两者的缺陷，当 <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=z%3E0" alt="[公式]"> 时，梯度始终为1，从而提高神经网络基于梯度算法的运算速度。然而当 <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=z%3C0" alt="[公式]"> 时，梯度一直为0，但是实际的运用中，该缺陷的影响不是很大。</p><p>Leaky ReLU保证在 <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=z%3C0" alt="[公式]"> 的时候，梯度仍然不为0。</p><p>在选择激活函数的时候，如果在不知道该选什么的时候就选择ReLU，当然也没有固定答案，要依据实际问题在交叉验证集合中进行验证分析。</p><h2 id="5-神经网络的梯度下降法"><a href="#5-神经网络的梯度下降法" class="headerlink" title="5. 神经网络的梯度下降法"></a><strong>5. 神经网络的梯度下降法</strong></h2><p>以本节中的浅层神经网络为例，我们给出神经网络的梯度下降法的公式。</p><ul><li>参数： <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=W%5E%7B%5B1%5D%7D,b%5E%7B%5B1%5D%7D,W%5E%7B%5B2%5D%7D,b%5E%7B%5B2%5D%7D" alt="[公式]"> ；</li><li>输入层特征向量个数： <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=n_%7Bx%7D=n%5E%7B%5B0%5D%7D" alt="[公式]"> ；</li><li>隐藏层神经元个数： <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=n%5E%7B%5B1%5D%7D" alt="[公式]"> ；</li><li>输出层神经元个数： <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=n%5E%7B%5B2%5D%7D=1" alt="[公式]"> ；</li><li><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=W%5E%7B%5B1%5D%7D" alt="[公式]"> 的维度为 <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=(n%5E%7B%5B1%5D%7D,n%5E%7B%5B0%5D%7D)" alt="[公式]"> ， <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=b%5E%7B%5B1%5D%7D" alt="[公式]"> 的维度为 <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=(n%5E%7B%5B1%5D%7D,1)" alt="[公式]"> ；</li><li><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=W%5E%7B%5B2%5D%7D" alt="[公式]"> 的维度为 <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=(n%5E%7B%5B2%5D%7D,n%5E%7B%5B1%5D%7D)" alt="[公式]"> ， <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=b%5E%7B%5B2%5D%7D" alt="[公式]"> 的维度为 <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=(n%5E%7B%5B2%5D%7D,1)" alt="[公式]"> ；</li></ul><p>下面为该例子的神经网络反向梯度下降公式（左）和其代码向量化（右）：</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic3.zhimg.com/80/v2-88e08b98b1d6ee1acba5f79a326fbb82_720w.jpg" alt="img"></p><h2 id="6-随机初始化"><a href="#6-随机初始化" class="headerlink" title="6. 随机初始化"></a><strong>6. 随机初始化</strong></h2><p>如果在初始时，两个隐藏神经元的参数设置为相同的大小，那么两个隐藏神经元对输出单元的影响也是相同的，通过反向梯度下降去进行计算的时候，会得到同样的梯度大小，所以在经过多次迭代后，两个隐藏层单位仍然是对称的。无论设置多少个隐藏单元，其最终的影响都是相同的，那么多个隐藏神经元就没有了意义。</p><p>在初始化的时候， <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=W" alt="[公式]"> 参数要进行随机初始化， <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=b" alt="[公式]"> 则不存在对称性的问题它可以设置为0。 以2个输入，2个隐藏神经元为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">W &#x3D; np.random.rand((2,2))* 0.01</span><br><span class="line">b &#x3D; np.zero((2,1))</span><br></pre></td></tr></table></figure><p>这里我们将W的值乘以0.01是为了尽可能使得权重W初始化为较小的值，这是因为如果使用sigmoid函数或者tanh函数作为激活函数时，W比较小，则 <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=Z+=+WX+b" alt="[公式]"> 所得的值也比较小，处在0的附近，0点区域的附近梯度较大，能够大大提高算法的更新速度。而如果W设置的太大的话，得到的梯度较小，训练过程因此会变得很慢。</p><p>ReLU和Leaky ReLU作为激活函数时，不存在这种问题，因为在大于0的时候，梯度均为1。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-神经网络表示&quot;&gt;&lt;a href=&quot;#1-神经网络表示&quot; class=&quot;headerlink&quot; title=&quot;1. 神经网络表示&quot;&gt;&lt;/a&gt;&lt;strong&gt;1. 神经网络表示&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;简单神经网络示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=</summary>
      
    
    
    
    <category term="吴恩达深度学习" scheme="https://cddorz.github.io/categories/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="浅层" scheme="https://cddorz.github.io/tags/%E6%B5%85%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>神经网络基础</title>
    <link href="https://cddorz.github.io/2020/11/25/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <id>https://cddorz.github.io/2020/11/25/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</id>
    <published>2020-11-25T07:39:13.000Z</published>
    <updated>2020-11-25T07:51:47.130Z</updated>
    
    <content type="html"><![CDATA[<p>每天两小时学习深度学习，自己比较感兴趣的方面，作为兴趣学习。唉，数学感觉需要恶补了。。</p><p>笔记是转载自：<a href="https://zhuanlan.zhihu.com/p/29688927">笔记</a>，可能笔记语法不同，排版有点问题，懒得改了，但本地typora上排版是好的，上传之后就有点难看了…….可能跟这个主题的页面布局有关吧……呜呜呜，不想改了。</p><h2 id="1-二分类问题"><a href="#1-二分类问题" class="headerlink" title="1. 二分类问题"></a>1. 二分类问题</h2><p>对于二分类问题，大牛给出了一个小的Notation。</p><ul><li>样本： <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=(x,y)" alt="[公式]"> ，训练样本包含 <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=m" alt="[公式]"> 个；</li><li>其中 <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=x%5Cin+R%5E%7Bn_%7Bx%7D%7D" alt="[公式]"> ，表示样本<img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=x+" alt="[公式]"> 包含 <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=n_%7Bx%7D" alt="[公式]">个特征；</li><li><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=y%5Cin%7B0,1%7D" alt="[公式]"> ，目标值属于0、1分类；</li><li>训练数据： <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=%5C%7B(x%5E%7B(1)%7D,y%5E%7B(1)%7D),(x%5E%7B(2)%7D,y%5E%7B(2)%7D),%5Ccdots,(x%5E%7B(m)%7D,y%5E%7B(m)%7D)%5C%7D" alt="[公式]"></li></ul><p>输入神经网络时样本数据的形状：</p><p><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=X.shape=(n_%7Bx%7D,+m)" alt="[公式]"></p><p>目标数据的形状：</p><p><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=Y=%5By_%7B(1)%7D,y_%7B(2)%7D,%5Ccdots,y_%7B(m)%7D%5D+" alt="[公式]"></p><p><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=Y.shape=(1,+m)" alt="[公式]"></p><h2 id="2-logistic-Regression"><a href="#2-logistic-Regression" class="headerlink" title="2. logistic Regression"></a><strong>2. logistic Regression</strong></h2><p>逻辑回归中，预测值：</p><p><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=%5C%5B%5Chat+h+=+P(y=1%7Cx)%5C%5D" alt="[公式]"></p><p>其表示为1的概率，取值范围在 <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=%5B0,1%5D" alt="[公式]"> 之间。 引入Sigmoid函数，预测值：</p><p><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=%5Chat+y+=+Sigmoid(w%5E%7BT%7Dx+b)=%5Csigma(w%5E%7BT%7Dx+b)" alt="[公式]"></p><p>其中</p><p><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=+Sigmoid(z)=%5Cdfrac%7B1%7D%7B1+e%5E%7B-z%7D%7D" alt="[公式]"></p><p><strong>注意点：</strong>函数的一阶导数可以用其自身表示，</p><p><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=%5Csigma%27(z)=%5Csigma(z)(1-%5Csigma(z))" alt="[公式]"></p><p>这里可以解释梯度消失的问题，当 <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=z=0" alt="[公式]"> 时，导数最大，但是导数最大为 <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=%5Csigma%27(0)=%5Csigma(0)(1-%5Csigma(0))=0.5(1-0.5)=0.25" alt="[公式]"> ，这里导数仅为原函数值的0.25倍。 参数梯度下降公式的不断更新， <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=%5Csigma%27(z)" alt="[公式]"> 会变得越来越小，每次迭代参数更新的步伐越来越小，最终接近于0，产生梯度消失的现象。</p><h2 id="3-logistic回归-损失函数"><a href="#3-logistic回归-损失函数" class="headerlink" title="3. logistic回归 损失函数"></a><strong>3. logistic回归 损失函数</strong></h2><p><strong>Loss function</strong></p><p>一般经验来说，使用平方错误（squared error）来衡量Loss Function：</p><p><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=L(%5Chat+y,+y)=%5Cdfrac%7B1%7D%7B2%7D(%5Chat+y-y)%5E%7B2%7D" alt="[公式]"></p><p>但是，对于logistic regression 来说，一般不适用平方错误来作为Loss Function，这是因为上面的平方错误损失函数一般是非凸函数（non-convex），其在使用低度下降算法的时候，容易得到局部最优解，而不是全局最优解。因此要选择凸函数。</p><p>逻辑回归的Loss Function：</p><p><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=L(%5Chat+y,+y)=-(y%5Clog%5Chat+y+(1-y)%5Clog(1-%5Chat+y))" alt="[公式]"></p><ul><li>当 <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=y=1" alt="[公式]"> 时， <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=L(%5Chat+y,+y)=-%5Clog+%5Chat+y" alt="[公式]"> 。如果 <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=%5Chat+y" alt="[公式]"> 越接近1， <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=L(%5Chat+y,+y)+%5Capprox+0" alt="[公式]"> ，表示预测效果越好；如果 <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=%5Chat+y" alt="[公式]"> 越接近0， <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=L(%5Chat+y,+y)+%5Capprox++%5Cinfty" alt="[公式]"> ，表示预测效果越差；</li><li>当 <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=y=0" alt="[公式]"> 时， <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=L(%5Chat+y,+y)=-%5Clog+(1-%5Chat+y)" alt="[公式]"> 。如果 <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=%5Chat+y" alt="[公式]"> 越接近0， <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=L(%5Chat+y,+y)+%5Capprox+0" alt="[公式]"> ，表示预测效果越好；如果 <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=%5Chat+y" alt="[公式]"> 越接近1， <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=L(%5Chat+y,+y)+%5Capprox++%5Cinfty" alt="[公式]"> ，表示预测效果越差；</li><li>我们的目标是最小化样本点的损失Loss Function，损失函数是针对单个样本点的。</li></ul><p><strong>Cost function</strong></p><p>全部训练数据集的Loss function总和的平均值即为训练集的代价函数（Cost function）。</p><p><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=J(w,b)=%5Cdfrac%7B1%7D%7Bm%7D%5Csum_%7Bi=1%7D%5E%7Bm%7DL(%5Chat+y%5E%7B(i)%7D,+y%5E%7B(i)%7D)=-%5Cdfrac%7B1%7D%7Bm%7D%5Csum_%7Bi=1%7D%5E%7Bm%7D%5Cleft%5By%5E%7B(i)%7D%5Clog%5Chat+y%5E%7B(i)%7D+(1-y%5E%7B(i)%7D)%5Clog(1-%5Chat+y%5E%7B(i)%7D)%5Cright%5D" alt="[公式]"></p><ul><li>Cost function是待求系数w和b的函数；</li><li>我们的目标就是迭代计算出最佳的w和b的值，最小化Cost function，让其尽可能地接近于0。</li></ul><h2 id="4-梯度下降"><a href="#4-梯度下降" class="headerlink" title="4. 梯度下降"></a><strong>4. 梯度下降</strong></h2><p>用梯度下降法（Gradient Descent）算法来最小化Cost function，以计算出合适的w和b的值。</p><p>每次迭代更新的修正表达式：</p><p><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=w:=w-%5Calpha%5Cdfrac%7B%5Cpartial+J(w,b)%7D%7B%5Cpartial+w%7D" alt="[公式]"></p><p><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=b:=b-%5Calpha%5Cdfrac%7B%5Cpartial+J(w,b)%7D%7B%5Cpartial+b%7D" alt="[公式]"></p><p>在程序代码中，我们通常使用dw来表示 <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=%5Cdfrac%7B%5Cpartial+J(w,b)%7D%7B%5Cpartial+w%7D" alt="[公式]"> ，用db来表示 <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=%5Cdfrac%7B%5Cpartial+J(w,b)%7D%7B%5Cpartial+b%7D" alt="[公式]"> 。</p><h2 id="5-逻辑回归中的梯度下降法"><a href="#5-逻辑回归中的梯度下降法" class="headerlink" title="5. 逻辑回归中的梯度下降法"></a><strong>5. 逻辑回归中的梯度下降法</strong></h2><p>对单个样本而言，逻辑回归Loss function表达式：</p><p><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=z=+w%5E%7BT%7Dx+b" alt="[公式]"></p><p><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=%5Chat+y=a=%5Csigma(z)" alt="[公式]"></p><p><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=L(a,+y)=-(y%5Clog+(a)+(1-y)%5Clog(1-a))" alt="[公式]"></p><p>前面过程的da、dz求导：</p><p><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=da+=+%5Cdfrac%7B%5Cpartial+L%7D%7B%5Cpartial+a%7D=-%5Cdfrac%7By%7D%7Ba%7D+%5Cdfrac%7B1-y%7D%7B1-a%7D" alt="[公式]"></p><p><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=dz+=+%5Cdfrac%7B%5Cpartial+L%7D%7B%5Cpartial+z%7D=%5Cdfrac%7B%5Cpartial+L%7D%7B%5Cpartial+a%7D%5Ccdot%5Cdfrac%7B%5Cpartial+a%7D%7B%5Cpartial+z%7D=(-%5Cdfrac%7By%7D%7Ba%7D+%5Cdfrac%7B1-y%7D%7B1-a%7D)%5Ccdot+a(1-a)=a-y" alt="[公式]"></p><p>再对 <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=w_%7B1%7D%E3%80%81w_%7B2%7D" alt="[公式]"> 和b进行求导：</p><p><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=dw_%7B1%7D+=+%5Cdfrac%7B%5Cpartial+L%7D%7B%5Cpartial+w_%7B1%7D%7D=%5Cdfrac%7B%5Cpartial+L%7D%7B%5Cpartial+z%7D%5Ccdot%5Cdfrac%7B%5Cpartial+z%7D%7B%5Cpartial+w_%7B1%7D%7D=x_%7B1%7D%5Ccdot+dz=x_%7B1%7D(a-y)" alt="[公式]"></p><p><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=db+=+%5Cdfrac%7B%5Cpartial+L%7D%7B%5Cpartial+b+%7D=%5Cdfrac%7B%5Cpartial+L%7D%7B%5Cpartial+z%7D%5Ccdot%5Cdfrac%7B%5Cpartial+z%7D%7B%5Cpartial+b+%7D=1%5Ccdot+dz=a-y" alt="[公式]"></p><p>梯度下降法：</p><p><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=w_%7B1%7D:=w_%7B1%7D-%5Calpha+dw_%7B1%7D" alt="[公式]"></p><p><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=w_%7B2%7D:=w_%7B2%7D-%5Calpha+dw_%7B2%7D" alt="[公式]"></p><p><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=b:=b-%5Calpha+db" alt="[公式]"></p><h2 id="6-m个样本的梯度下降"><a href="#6-m个样本的梯度下降" class="headerlink" title="6. m个样本的梯度下降"></a><strong>6. m个样本的梯度下降</strong></h2><p>对m个样本来说，其Cost function表达式如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=z%5E%7B(i)%7D=+w%5E%7BT%7Dx%5E%7B(i)%7D+b" alt="[公式]"></p><p><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=%5Chat+y%5E%7B(i)%7D=a%5E%7B(i)%7D=%5Csigma(z%5E%7B(i)%7D)" alt="[公式]"></p><p><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=J(w,b)=%5Cdfrac%7B1%7D%7Bm%7D%5Csum_%7Bi=1%7D%5E%7Bm%7DL(%5Chat+y%5E%7B(i)%7D,+y%5E%7B(i)%7D)=-%5Cdfrac%7B1%7D%7Bm%7D%5Csum_%7Bi=1%7D%5E%7Bm%7D%5Cleft%5By%5E%7B(i)%7D%5Clog%5Chat+y%5E%7B(i)%7D+(1-y%5E%7B(i)%7D)%5Clog(1-%5Chat+y%5E%7B(i)%7D)%5Cright%5D" alt="[公式]"></p><p>Cost function 关于w和b的偏导数可以写成所有样本点偏导数和的平均形式：</p><p><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=dw_%7B1%7D+=%5Cdfrac%7B1%7D%7Bm%7D%5Csum_%7Bi=1%7D%5E%7Bm%7Dx_%7B1%7D%5E%7B(i)%7D(a%5E%7B(i)%7D-y%5E%7B(i)%7D)" alt="[公式]"></p><p><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=db+=+%5Cdfrac%7B1%7D%7Bm%7D%5Csum_%7Bi=1%7D%5E%7Bm%7D(a%5E%7B(i)%7D-y%5E%7B(i)%7D)" alt="[公式]"></p><h2 id="7-向量化（Vectorization）"><a href="#7-向量化（Vectorization）" class="headerlink" title="7. 向量化（Vectorization）"></a><strong>7. 向量化（Vectorization）</strong></h2><p>在深度学习的算法中，我们通常拥有大量的数据，在程序的编写过程中，应该尽最大可能的少使用loop循环语句，利用python可以实现矩阵运算，进而来提高程序的运行速度，避免for循环的使用。</p><p><strong>逻辑回归向量化</strong></p><ul><li>输入矩阵X：<img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=(n_%7Bx%7D,m)" alt="[公式]"></li><li>权重矩阵w： <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=(n_%7Bx%7D,1)" alt="[公式]"></li><li>偏置b：为一个常数</li><li>输出矩阵Y： <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=(1,m)" alt="[公式]"></li></ul><p>所有m个样本的线性输出Z可以用矩阵表示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=Z+=+w%5E%7BT%7DX+b" alt="[公式]"></p><p>python代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db &#x3D; 1&#x2F;m*np.sum(dZ)</span><br></pre></td></tr></table></figure><p><strong>单次迭代梯度下降算法流程</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Z &#x3D; np.dot(w.T,X) + b</span><br><span class="line">A &#x3D; sigmoid(Z)</span><br><span class="line">dZ &#x3D; A-Y</span><br><span class="line">dw &#x3D; 1&#x2F;m*np.dot(X,dZ.T)</span><br><span class="line">db &#x3D; 1&#x2F;m*np.sum(dZ)</span><br><span class="line"></span><br><span class="line">w &#x3D; w - alpha*dw</span><br><span class="line">b &#x3D; b - alpha*db</span><br></pre></td></tr></table></figure><h2 id="8-python的notation"><a href="#8-python的notation" class="headerlink" title="8. python的notation"></a><strong>8. python的notation</strong></h2><p>虽然在Python有广播的机制，但是在Python程序中，为了保证矩阵运算的正确性，可以使用reshape()函数来对矩阵设定所需要进行计算的维度，这是个好的习惯；</p><p>如果用下列语句来定义一个向量，则这条语句生成的a的维度为（5，），既不是行向量也不是列向量，称为秩（rank）为1的array，如果对a进行转置，则会得到a本身，这在计算中会给我们带来一些问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; np.random.randn(5)</span><br></pre></td></tr></table></figure><p>如果需要定义（5，1）或者（1，5）向量，要使用下面标准的语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; np.random.randn(5,1)</span><br><span class="line">b &#x3D; np.random.randn(1,5)</span><br></pre></td></tr></table></figure><p>可以使用assert语句对向量或数组的维度进行判断。assert会对内嵌语句进行判断，即判断a的维度是不是（5，1），如果不是，则程序在此处停止。使用assert语句也是一种很好的习惯，能够帮助我们及时检查、发现语句是否正确。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert(a.shape &#x3D;&#x3D; (5,1))</span><br></pre></td></tr></table></figure><p>可以使用reshape函数对数组设定所需的维度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.reshape((5,1))</span><br></pre></td></tr></table></figure><h2 id="8-logistic-regression代价函数的解释"><a href="#8-logistic-regression代价函数的解释" class="headerlink" title="8. logistic regression代价函数的解释"></a><strong>8. logistic regression代价函数的解释</strong></h2><p><strong>Cost function的由来</strong></p><p>预测输出 <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=%5Chat+y" alt="[公式]"> 的表达式：</p><p><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=+%5Chat+y+=%5Csigma(w%5E%7BT%7Dx+b)" alt="[公式]"></p><p>其中， <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=%5Csigma(z)=%5Cdfrac%7B1%7D%7B1+e%5E%7B-z%7D%7D" alt="[公式]"> 。</p><p><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=%5Chat+y" alt="[公式]"> 可以看作预测输出为正类（+1）的概率：</p><p><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=%5Chat+y+=+P(y=1%7Cx)" alt="[公式]"></p><p>当 <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=y=1" alt="[公式]"> 时， <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=P(y%7Cx)=%5Chat+y" alt="[公式]"> ；当 <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=y=0" alt="[公式]"> 时， <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=P(y%7Cx)=1-%5Chat+y" alt="[公式]"> 。</p><p>将两种情况整合到一个式子中，可得：</p><p><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=P(y%7Cx)=%5Chat+y%5E%7By%7D(1-%5Chat+y+)%5E%7B(1-y)%7D" alt="[公式]"></p><p>对上式进行log处理（这里是因为log函数是单调函数，不会改变原函数的单调性）：</p><p><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=%5Clog+P(y%7Cx)=%5Clog%5Cleft%5B%5Chat+y%5E%7By%7D(1-%5Chat+y+)%5E%7B(1-y)%7D%5Cright%5D=y%5Clog%5Chat+y+(1-y)%5Clog(1-%5Chat+y)" alt="[公式]"></p><p>概率 <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=P(y%7Cx)" alt="[公式]"> 越大越好，即判断正确的概率越大越好。这里对上式加上负号，则转化成了单个样本的Loss function，我们期望其值越小越好：</p><p><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=L(%5Chat+y,+y)=-(y%5Clog%5Chat+y+(1-y)%5Clog(1-%5Chat+y))" alt="[公式]"></p><p><strong>m个训练样本</strong></p><p>假设样本之间是独立同分布的，我们总是希望训练样本判断正确的概率越大越好，则有： <img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=%5Cmax+%5Cprod%5Climits_%7Bi=1%7D%5E%7Bm%7D+%7BP(y%5E%7B(i)%7D%7Cx%5E%7B(i)%7D)%7D" alt="[公式]"></p><p>同样引入log函数，加负号，则可以得到Cost function：</p><p><img src= "/img/loading.gif" data-lazy-src="https://www.zhihu.com/equation?tex=J(w,b)=%5Cdfrac%7B1%7D%7Bm%7D%5Csum_%7Bi=1%7D%5E%7Bm%7DL(%5Chat+y%5E%7B(i)%7D,+y%5E%7B(i)%7D)=-%5Cdfrac%7B1%7D%7Bm%7D%5Csum_%7Bi=1%7D%5E%7Bm%7D%5Cleft%5By%5E%7B(i)%7D%5Clog%5Chat+y%5E%7B(i)%7D+(1-y%5E%7B(i)%7D)%5Clog(1-%5Chat+y%5E%7B(i)%7D)%5Cright%5D" alt="[公式]"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;每天两小时学习深度学习，自己比较感兴趣的方面，作为兴趣学习。唉，数学感觉需要恶补了。。&lt;/p&gt;
&lt;p&gt;笔记是转载自：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29688927&quot;&gt;笔记&lt;/a&gt;，可能笔记语法不同，排版有点问题，懒得改了，但本地</summary>
      
    
    
    
    <category term="吴恩达深度学习" scheme="https://cddorz.github.io/categories/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="神经网络基础" scheme="https://cddorz.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>SCP</title>
    <link href="https://cddorz.github.io/2020/11/21/SCP/"/>
    <id>https://cddorz.github.io/2020/11/21/SCP/</id>
    <published>2020-11-21T03:50:33.000Z</published>
    <updated>2020-11-21T04:25:40.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回味无穷的SCP基金会系列"><a href="#回味无穷的SCP基金会系列" class="headerlink" title="回味无穷的SCP基金会系列"></a>回味无穷的SCP基金会系列</h1><p>记录一些很有趣的scp基金会文章。</p><p><a href="http://scp-wiki-cn.wikidot.com/">scp基金会中国分部官网</a></p><hr><p><strong>scp基金会：</strong></p><p><strong>基金会宣言:</strong></p><p><strong>人类到如今已经繁衍了近百万年，只有最近的4000年是有意义的。</strong></p><p><strong>所以，我们在将近25000年中在干嘛？我们躲在山洞中，围坐在小小的篝火边，畏惧那些我们不懂得的事物——那些关于太阳如何升起的解释，那些人头鸟身的怪物，那些有生命的石头。所以我们称他们为“神”和“恶魔”，并向他们祈求宽恕和祈祷拯救。</strong></p><p><strong>之后，他们的数量在减少，我们的数量在增加。当我们恐惧的事物越来越少，我们开始更理智的看待这个世界。然而，不能解释的事物并没有消失，好像宇宙故意要表现出荒谬与不可思议一样。</strong></p><p><strong>人类不能再生活在恐惧中。 没有东西能保护我们，我们必须保护我们自己。</strong></p><p><strong>当其他人在阳光下生活时，我们必须在阴影中和它们战斗，并防止它们暴露在大众眼中，这样其他人才能生活在一个理智的，普通的世界中。</strong></p><p><strong>我们控制，我们收容，我们保护。</strong></p><p><strong>— The Administrator</strong></p><p><strong><u>那么scp基金会真的存在吗？？</u></strong></p><hr><p><strong>项目编号：</strong>SCP-1733</p><p><strong>项目等级：</strong>Safe</p><p><strong>特殊收容措施：</strong>收录有SCP-1733的硬盘录像机被收容于Site-██的一间安全的视频档案室内。SCP-1733的录像回放被严格限定于仅供研究之用。研究人员需联系Geller博士以取得研究SCP-1733的权限。</p><p><strong>描述：</strong>SCP-1733是一份2010年10月26日在马萨诸塞州波士顿花园球馆，由波士顿凯尔特人队迎战迈亚密热火队的NBA2010-2012赛季开幕战的数字录像。特工们在监控社交网站的过程中注意到，一条由波士顿本地人████ █████撰写的FACEBOOK内容提到，在10月27号的比赛第三节过程中，在他录制的视频里涉及到凯尔特人队员雷·阿伦与热火队员克里斯·波什的一次技术性犯规根本就不曾发生过。当他发现这件事后，████ █████上传了相关的片段来反击那些嘲笑谩骂他的评论。潜伏在FACEBOOK监控团队中的基金会特工旋即删除了相关内容并获得了████ █████和所有参与评论用户的IP地址，对他们实施了定位和A級记忆消除。收录有SCP-1733的磁盘录像机被回收作研究用途。</p><p>自这份录像的异常性质被发现后，基金会的研究人员对其进行了大量的研究。尽管在最初的阶段，SCP-1733所包含的影像与本来放送的影响之间只有非常细微甚至可以忽略的不同，例如双方的每节总分或是犯规情况，但项目的内容确实是与它上次播放时有所区别。根据观察，录像中所拍摄到的个体保留有关于上一次播放的内容的记忆碎片，并且有部分个体已经觉察到了这些记忆碎片的存在。据推测，重复回放将会以记忆碎片的形式向这些实体传递目前尚无法估量其数量的信息，而这些信息越发使人群和球员们感到困惑和混乱，这个效应是积累性的，而且对球场内所有实体都有效。由于继承了前一次播放内容的记忆碎片，现场球评人麦克和汤米称他们对眼前看到的比赛似曾相识，由此可以看出这一效应正在发展中。然而，值得注意的是，没有任何一个实体直接与观察者说过话，他们或许就是这份数字录像中的居民。</p><p>被拍摄到的个体他们的行为与现实生活中别无二致，包括他们的球技、行为和举止。球迷们在各方面的举止也与一般人类没有区别，同时基金会对这些个体在现实世界中的调查并没有结果。从他们的行为和意图看来，被拍摄到的实体似乎都是真实存在的人，只是由于某种未知的原因，他们生活在这个数字介质当中。根据花园球馆的记录，2010年10月26日到场观看比赛的人数为██████。</p><p>在最初，SCP-1733的本质被认为是一个能对这场比赛的无限推演的集合，因为每次回放球员们都能根据记忆碎片的内容能预测对方球队的战术并作出相应的调整。在第34播放中，运动员和教练已经对对方球队的一举一动了如指掌，以至于在第一节进行到3分34秒前，双方比分都保持在0比0。由于记忆碎片所显现出的强度较弱，在早期的重复播放试验中，球员们、球迷和场地工作人员都将其理解为一种模糊的直觉，他们对比赛表现得越来越不紧张。</p><p>然而，当进行到第45次重复播放时，对他们处境的理解达到某个临界点后，球员们开始罢赛，并和球场中的其他人一起开始策划一个从球场中逃脱的计划。基于基金会研究员的结论，这些SCP-1733中的居民是被禁锢在这盘录像中，而且他们没有任何办法可以逃脱。所有通向球场外的门在据观测高达█████N的推力面前纹丝不动。球场内的人通过更衣室、球员设施或是豪华包厢离开的尝试也同样失败了。尝试在比赛开始前等待观众入场的时间离开的尝试也没有成功：进入到观众通道的个体根本就无法从那仅仅是绕了球场一圈的通道里逃出去。逃生的尝试显得越发让人绝望，制造土制炸彈、总动员的大破坏等尝试均以失败告终，人们开始分裂成三个相互对立的派系，而在第███次回放中，开始出现带有仪式性质的谋杀，球员们被迫剖腹自杀尝试去取悦那个禁锢他们的未知的存在（详见时间轴文件001）。然而，当再一次开始重新播放，所有个体都会恢复到比赛前无恙的状态。</p><p>研究人员在该DVR中储存的新片段并没有产生类似SCP-1733的效应，由此可以推断该DVR并不是SCP-1733异常属性的来源。基于观察到的SCP-1733的居民们那痛苦的状况，后续测试已被无限期暂停。</p><table><thead><tr><th>播放次数</th><th>显著变化</th></tr></thead><tbody><tr><td>002</td><td>记录到第一个与电视放送内容的不同。花园球馆的观众们对正在入场的热火队予以嘘声。迈亚密热火队前锋勒布朗·詹姆斯看着观众们皱了皱眉，轻轻的摇了摇头。</td></tr><tr><td>015</td><td>连续八次进攻后比分依旧是0比0。从比分板上的高清屏幕所显示的球迷表情可以看得出他们很郁闷。凯尔特人大前锋格伦·戴维斯在第四节完成了对勒布朗·詹姆斯的一次盖帽，并保住了球队的领先，这是他在之前的回放中都没能做到的。评述员对格伦·戴维斯在比赛中前后场皆优对比赛的贡献的评述取代了原来对三巨头在进攻时的快速运球的评述。一个关于前一次播放的新意识开始形成。</td></tr><tr><td>026</td><td>迈亚密热火队的首次胜利，比分最终锁定在112比85。人群变得相当激动，开始粗话连篇并向凯尔特人队投掷杂物。评述员汤姆·海因索恩说他理解球迷们沮丧的心情，并批评凯尔特人队的教练团队在破解了迈亚密热火队的进攻路数后显得过于自大。同时他也指出，这场比赛是迈亚密三巨头的初阵，很难想象他们的为何能在一场比赛里就将这样一个并不熟悉的进攻组合玩得得心应手。</td></tr><tr><td>027</td><td>评述员麦克和汤米在热火队入场的时候感觉到这一场景似乎似曾相识。在这样一场对于凯尔特人队来说相当重要的比赛中，观众们显得很沉寂。凯尔特人队获得了胜利，汤姆·海因索恩评论“凯尔特人队要想赢回他们球迷的心还有很长的路要走”。当被记者问到时，他说这支队伍需要一雪前耻，而至于其他东西，现阶段还很难说。</td></tr><tr><td>044</td><td>球员们表现出迷失和困惑。比赛并没有进行。录像大部分的时间里队医们都在为那些坚称自己头天晚上做梦打过很多次开幕赛的队员们做精神鉴定。当球队工作人员将这个消息告诉麦克和汤米时，他们也表示自己有类似的感觉。观众们似乎也有同样的感觉。当记者们开始就这些梦的本质进行采访时，录像结束了。</td></tr><tr><td>045</td><td>球员们罢赛。球员们、摄影师、工作人员还有观众们聚集到球场上开始分析当前的情况。所有人都坚信他们是在重复地经历同一场比赛。球场的门在尝试后被证实无法开启。当人们开始准备各种土制武器去撬门的时候录像结束了。这是最后一次观察到镜头是被摄制组操作着的，之后所有的回放都是以一个固定的演播摄像机为视点。</td></tr><tr><td>051</td><td>逃出这栋建筑物的尝试全部以失败告终。所有通向球场外以及相邻区域的门都封死了。在看台318区发生了暴力事件，一群喝醉了的男大学生和另外两个较老的男人发生了冲突，其中一人被打成了脑震荡瘫倒在地，另一个则不省人事。由于演播摄像机无法清楚收到来自球场对面的声音，推测这起事件是发生在并没有打算协助逃生的男性之间。</td></tr><tr><td>052</td><td>之前被殴打致脑震荡的男子在重新开始回放之后恢复到无恙的状态。两名在之前的回放中被殴打的男子伏击了殴打他们的人，并在录像进行到34分12秒的时候用棍棒打死了其中一个人。</td></tr><tr><td>055</td><td>认知效应已经发展到这群人能记得一周内发生过的事，以及他们在这个建筑外的朋友和家人。试图联系外界以获得帮助的尝试失败了。</td></tr><tr><td>065</td><td>人们无法逃离这个地方。人群开始分裂成数个派系：球员们、教练员以及可能已将自己锁在镜头之外的球员设施里的球队工作人员。体弱者和家长们带着他们的孩子聚集到了看台的东北角选择等待回放再次重新开始，他们用凯尔特人队的队旗围起了看台的320区，将其标示为自己的领土。██个个体，以下简称为“Faithkeepers”，他们认为花园球馆是对于泛滥的物欲主义的一次惩罚。在连续四次回放中，他们到处收集手机、车钥匙、手袋、钱包等他们认为可以当做“祭品”的东西，并在球场中心焚烧。这一批人的成员主要来自波士顿教友会以及[数据删除]。然而，依然有为数不少，接近████个成年人依然在积极地策划着逃生的方案。</td></tr><tr><td>073</td><td>在前一次回放中，三个人被固定在出口大门上引爆的土制炸彈所伤，而门没有显现出任何可见的伤痕。在这一事件后，“Faithkeepers”的数量明显增多</td></tr><tr><td>095</td><td>暴力和性的享乐主义很大程度地让传教者们（指Faithkeepers）的努力化成了无用功。在320成员的督促下，在八号包厢里开狂欢派对的人才挂起了几块布来稍作遮掩。</td></tr><tr><td>112</td><td>情况越来越糟，在第112次回放开始的十分钟里，已有██人从看台上跳下自杀。</td></tr><tr><td>███</td><td>Faithkeepers突袭了球员更衣室，并把保罗·皮尔斯和勒布朗·詹姆斯揪了出来。两位球员在仪式上被作为祭品献祭了，他们的尸体随后被展示在该区域的大屏幕上<a href="javascript:;">1</a>。两位球员的死似乎并未对该录像带造成影响。</td></tr><tr><td>███</td><td>传教者们开始要求献祭儿童。大人们在Faithkeepers与320组之间筑起人墙。</td></tr><tr><td>███</td><td>首次记录到球场灯光偏深红色。[数据删除]。</td></tr></tbody></table><p>scp-1733补充：</p><h1 id="花园球馆今天没有比赛"><a href="#花园球馆今天没有比赛" class="headerlink" title="花园球馆今天没有比赛"></a>花园球馆今天没有比赛</h1><p>最新的研究项目完成了。签订保密协议后，Caya博士被准许放假。她今天要和丈夫、女儿到花园球场看开季赛。他们落座以后，静待比赛开始。这时她包里的康德计数器响了起来。她口袋里的手机几乎同时响了。<br>现实扭曲者袭击，不要泄露机密。我们会来救你。<br>她想起接受过的训练。可是她知道没有用。</p><p><a href="https://www.bilibili.com/read/cv2534467?from=search">又一次回放。</a><br>为数不多的大人们艰难地守卫着320区。享乐主义者们又一次冲破防线，进来掠走了好几个小女孩，还有一个男孩。Caya看见丈夫抡起手提箱，砸翻了一个暴徒，又立即被如雨的棍棒打倒在地。有女人声嘶力竭地哭喊着。<br>Caya发现女儿不见了。<br>她脑海里充斥着在之前的轮回中，女儿无数次被暴徒以不同方式蹂躏的场景。大部分她没看见，那时候她要么头破血流，倒在地上，已处于“死亡”当中，只听得到声音，要么正被迫在别的地方接受着暴徒的侵犯，丝毫无法反抗。还有些时候她看到了，于是她记住了。那是第几次回放？享乐主义者和教徒破天荒地联手，杀光了320区的所有男人。然后……那一次的轮回好像格外久。</p><p>录像带重置了。<br>所有人都再次坐在看台上，球员依旧还未入场。场面在一瞬间内骚动起来——她下意识地转过身躯，想搂住坐在左边的女儿——这时她头部受到了重击，她趴倒在前排座位上。果然。她知道她右后座的那个年轻人经常在轮回刚开始时猛击她的头部，然后夺走她的女儿和枪。尽管这事现在已经不常发生了——至少有六十次轮回里他没有这么做了。</p><p>Caya勉强支撑起身体，回过身去。<br>她看见，丈夫丢下了一直作为武器的手提箱，正在撕扯女儿的衣服。“就这一次……反正也会回放的，不是吗？”那个是她丈夫的人说。女儿又哭又叫。Caya寄希望于后排的那年轻人，希望他能打倒她丈夫，可那年轻人早已不见踪影。<br>Caya身躯一软，眼前发黑。她支撑着身体，终于栽倒在过道上，险些滚了下去。她扒住一个座椅。有人拿走了她的手枪，顺便摸了一下她的屁股——这把枪的位置早就在一遍遍回放里被所有人知道了。她浑身无力，垂下头，望着花园球馆。</p><p>球场那边，勒布朗·詹姆斯目光空洞。他手持铁片，再一次剖开了自己的腹部。动作熟练。鲜红的内脏流了出来。他旁边跪着保罗·皮尔斯。</p><p>另一边的观众区，有十几个人正翻过玻璃护栏，纵身跃下看台。后跳的人坠落在尸体或活人身上，因而没有马上死去。还能活动的人便挣扎着寻找最近的铁器，只求一死，然后在什么都感知不到的黑暗中等待下一次轮回。</p><p>球场中央，享乐主义者们再次迅速聚集起来了。他们就在球场正中，脱下来的衣物铺满了地板。呻吟声和狂叫声，间或有哭喊声。</p><p>是的。<br>花园球馆里，肉体碰撞声此起彼伏。有的造成死亡，有的带来快感。</p><p>地狱盛景。活现人间。<br>那现实扭曲者真是个天才。Caya想。</p><p>在Area-CN-07工作的时候，她听同事说过几百种现实扭曲者审问犯人的方法。而只是封住球馆，将一万个人关在一起，其他什么也不做，这种方法她闻所未闻。<br>但毫无疑问。这是最惨绝的方法。</p><p>她艰难地转过头，所见之物险些击碎她的心脏。她发现女儿已经不再反抗。她也在呻吟着，脸上扬起迷乱的笑颜，娇小的身躯配合着节奏律动着。<br>像无数次曾发生过的那样，女儿闭着眼。在无数次轮回中，女儿已像个成人了。对她来说，人类女性能经历的所有悲惨，已没有什么是她十四岁的内心所不熟悉的了。她早已不是她的女儿了。</p><p>Caya闭上眼睛。她想张嘴把所有她知道的都说出来。她知道一旦她这么做，这一切马上会结束。她至少会死。</p><p>说吧。<br>丈夫模糊地呼唤着某个人的名字。<br>说吧。<br>女儿的叫声听起来像远方的山音。<br>说吧。<br>因为花园球场早已没有人在祈祷。<br>说吧，<br>CAYA。</p><p>CAYA。</p><p>说啊，<br>CAYA。</p><p>Caya笑了。<br>血液从唇角流进嘴中。尝起来竟然清甜。<br>她知道她不能。因为他们已不配死。</p><p>正当她想把头狠狠撞在台阶上，然后进入死亡的时候，Caya看见一个在无数次轮回中，她竟完全不记得的面孔。<br>那人面色阴沉，坐在她的位置上，然后掏出一包骆驼牌香烟，取出一支，那烟立即燃烧。他抽了一口，抬眼扫视花园球场。然后他定定地看着她。神情中似乎有一丝怜悯。<br>还是不说吗？</p><p>Caya凄惨地一笑。<br>玩够了吗？还是他们终于来了？</p><p>那男人站起来。吐出烟。</p><p>一声巨响。曾被引爆过无数次的土制炸药再次爆炸了，飞起鲜艳的烟云。<br>Caya望向入口。<br>花园球馆的大门，轰然洞开。</p><p>一切都消失了。<br>所有人都坐在座位上，比赛还没有开始。<br>烟云还未完全散去，Caya看见身着黑色制服，全副武装的基金会人员，带着现实稳定设备，成严正队列冲了进来。所有观众都骚动起来，互相询问发生了什么。Caya感到女儿的小手拉住了她的衣角。</p><blockquote><p>波士顿晚报 2010年10月26日<br>今日，花园球馆遭遇袭击，土制炸药在大门处被引爆，球馆设施损毁，所幸无人受伤。原定今日举行的波士顿凯尔特人队迎战迈亚密热火队的开幕战将延期举行。</p></blockquote><p>Caya抬头，摆着披萨的木制餐桌旁坐着丈夫和女儿，丈夫讲了一个笑话，女儿捂嘴轻轻笑着。<br>Caya没笑。她放下报纸，站起身，端着咖啡回到了卧室。</p><p>他们根本没去过花园球馆。<br>她试着说服自己。<br>不。<br>她记得。<br>她记得他们家从没订过什么《波士顿晚报》。</p><p>她记得他们去过，他们所有人。<br>她记得他们是怎么从面对绝望走向制造绝望的。<br>她放下咖啡，打开抽屉。里面躺着一把格洛克。</p><p>她记得每一张脸的每一个不同表情。<br>她记得他们的语调，记得他们的姿态。<br>她草草写下遗书。然后签名。</p><p>她记得他们的所有癖好。有些可能永远不会再被发现。<br>她记得一切。一切已经发生，也不会再发生的东西。<br>她含住枪，枪管冰凉。</p><p>她记得他们是人。是她能遇见的，所有年龄、职业、背景，所有一样的人。<br>她记得她也是人。</p><p>砰。</p><p>Caya死死盯着桌上凭空多出来的基金会之星勋章。<br>就在刚刚，枪口里蹦出了一颗深红色的彩虹糖，然后枪管从中间弯曲，像塑料一样折成两段。复进簧弹在她脸上。</p><p>她好像闻到一股烟味。</p><p>耳边有人说，<br>“别急，</p><p>还没完呢。”</p><h3 id="评价："><a href="#评价：" class="headerlink" title="评价："></a><strong><em>评价</em></strong>：</h3><p>​    这一篇scp系列文章真的很令人回味，特别是当你认为已经逃出去可以松一口气之后，正在为Caya的自杀感到痛苦以及对人性的厌恶的时候，一声“别急，还没完呢”，又让我不禁发出一声“卧槽”，反转的结局让我回味无穷，同时也为Caya的命运感到担忧。</p><p>   但回到这篇scp想表达的本质上来：如果真的发生了一万人被困在一个封闭空间，且会无限循环，永远逃不出去，那么道德、人性会变成什么样呢？=-=，光想想就令人胆寒，这其实就是人本性的恶是无法被磨灭的，虽然现在社会的文明，那是因为有法律和道德的约束，真到没有约束的时候，能像Caya一样还有善的人又能有多少呢？扪心自问，我要是在那种情况下，也会堕落。**<u>人的恶，无法逆转，无法改变！</u>**</p><p>​    如果那一万人中有你，可以想想你会做什么……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;回味无穷的SCP基金会系列&quot;&gt;&lt;a href=&quot;#回味无穷的SCP基金会系列&quot; class=&quot;headerlink&quot; title=&quot;回味无穷的SCP基金会系列&quot;&gt;&lt;/a&gt;回味无穷的SCP基金会系列&lt;/h1&gt;&lt;p&gt;记录一些很有趣的scp基金会文章。&lt;/p&gt;
&lt;p&gt;&lt;</summary>
      
    
    
    
    <category term="scp" scheme="https://cddorz.github.io/categories/scp/"/>
    
    
    <category term="狂想" scheme="https://cddorz.github.io/tags/%E7%8B%82%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>订单自动过期实现方案</title>
    <link href="https://cddorz.github.io/2020/11/20/%E8%AE%A2%E5%8D%95%E8%87%AA%E5%8A%A8%E8%BF%87%E6%9C%9F%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"/>
    <id>https://cddorz.github.io/2020/11/20/%E8%AE%A2%E5%8D%95%E8%87%AA%E5%8A%A8%E8%BF%87%E6%9C%9F%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/</id>
    <published>2020-11-20T08:59:53.000Z</published>
    <updated>2020-11-20T11:46:16.126Z</updated>
    
    <content type="html"><![CDATA[<h2 id="订单自动过期时实现方案"><a href="#订单自动过期时实现方案" class="headerlink" title="订单自动过期时实现方案"></a>订单自动过期时实现方案</h2><h4 id="具体是因为要做的项目需要做一个过滤过期任务的方案：一开始考虑做定时任务，但发现定时任务并不能完成要求，因为定时任务只能是静态某一时间进行遍历数据库进行修改操作，一般用于清楚数据库缓存等，所以考虑做延时队列。"><a href="#具体是因为要做的项目需要做一个过滤过期任务的方案：一开始考虑做定时任务，但发现定时任务并不能完成要求，因为定时任务只能是静态某一时间进行遍历数据库进行修改操作，一般用于清楚数据库缓存等，所以考虑做延时队列。" class="headerlink" title="具体是因为要做的项目需要做一个过滤过期任务的方案：一开始考虑做定时任务，但发现定时任务并不能完成要求，因为定时任务只能是静态某一时间进行遍历数据库进行修改操作，一般用于清楚数据库缓存等，所以考虑做延时队列。"></a>具体是因为要做的项目需要做一个过滤过期任务的方案：一开始考虑做定时任务，但发现定时任务并不能完成要求，因为定时任务只能是静态某一时间进行遍历数据库进行修改操作，一般用于清楚数据库缓存等，所以考虑做<em>延时队列</em>。</h4><h4 id="1-延时队列"><a href="#1-延时队列" class="headerlink" title="1. 延时队列"></a>1. 延时队列</h4><p>基于JDK的实现方法，将未支付的订单放到一个有序的队列中，程序会自动依次取出过期的订单。<br>如果当前没有过期的订单，就会阻塞，直至有过期的订单。由于每次只处理过期的订单，并且处理的时间也很精准，不存在定时调度方案的那两个弊端。<br>实现：<br>1.首先创建一个订单类<code>OrderDelayDto</code>需要实现<code>Delayed</code>接口。然后重写<code>getDelay()</code>方法和<code>compareTo()</code>方法，只加了订单编号和过期时间两个属性。<br>这两个方法很重要，<br><code>getDelay()</code>方法实现过期的策略，比如，订单的过期时间等于当前时间就是过期，返回负数就代表需要处理。否则不处理。<br><code>compareTo()</code>方法实现订单在队列中的排序规则，这样即使后面加入的订单，也能加入到排序中，我这里写的规则是按照过期时间排序，最先过期的排到最前面，这一点很重要，因为排在最前面的如果没有被处理，就会进入阻塞状态，后面的不会被处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qingyuan.pigeon;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.jetbrains.annotations.NotNull;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Delayed;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> han long yi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-11-20 16:14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderDelayDto</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String taskId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过期时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Date taskEndTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断过期条件：过期时间大于等于当前时间就算过期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * getDelay: 返回与此对象关联的剩余延迟，以给定的时间单位表示。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(<span class="meta">@NotNull</span> TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unit.convert(<span class="keyword">this</span>.taskEndTime.getTime() - System.currentTimeMillis(), TimeUnit.NANOSECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单加入队列的排序规则：最先过期的排在前面</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * compareTo: 将此对象与order的指定对象进行比较。当此对象小于、等于或大于指定对象时，返回负整数、零或正整数。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(<span class="meta">@NotNull</span> Delayed o)</span> </span>&#123;</span><br><span class="line">        OrderDelayDto orderDelayDto  = (OrderDelayDto) o;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Date.getTime(long):</span></span><br><span class="line"><span class="comment">         * 返回此&#123;<span class="doctag">@code</span> Date&#125;对象表示的自1970年1月1日00:00:00 GMT*以来的毫秒数。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">long</span> time =orderDelayDto.getTaskEndTime().getTime();</span><br><span class="line">        <span class="keyword">long</span> time1 = <span class="keyword">this</span>.taskEndTime.getTime();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果 time == time1 返回0</span></span><br><span class="line"><span class="comment">         * 如果 time &lt; time1 返回1</span></span><br><span class="line"><span class="comment">         * 如果 time &gt; time1 返回-1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span>  time == time1 ? <span class="number">0</span> : time &lt; time1 ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>convert : 将给定单位中的给定持续时间转换为该单位。</li><li>System.currentTimeMillis() : 返回当前时间（毫秒）。</li><li>NANOSECONDS ：表示千分之一微秒的时间单位。</li></ul><p>写个test 方法测试一下，创建两个订单o1和o2，放入到延时队列中，然后while()方法不断的去取。<br>在此方法内通过队列的<code>take()</code>方法获得已过期的订单，然后做出相应的处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">teat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DelayQueue&lt;OrderDelayDto&gt; queue = <span class="keyword">new</span> DelayQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第一个订单，过期时间设置为一分钟后</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        OrderDelayDto o1 = <span class="keyword">new</span> OrderDelayDto();</span><br><span class="line">        o1.setTaskId(<span class="string">&quot;1001&quot;</span>);</span><br><span class="line">        Calendar calendar = Calendar.getInstance();</span><br><span class="line">        calendar.add(Calendar.MINUTE,<span class="number">1</span>);</span><br><span class="line">        o1.setTaskEndTime(calendar.getTime());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第二个订单，过期时间设置为现在</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        OrderDelayDto o2 = <span class="keyword">new</span> OrderDelayDto();</span><br><span class="line">        o2.setTaskId(<span class="string">&quot;1002&quot;</span>);</span><br><span class="line">        o2.setTaskEndTime(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 往队列中放入数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        queue.offer(o1);</span><br><span class="line">        queue.offer(o2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 延时队列</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                OrderDelayDto take = queue.take();</span><br><span class="line">                System.out.println(<span class="string">&quot;订单编号：&quot;</span> + take.getTaskId() + <span class="string">&quot;过期时间:&quot;</span> + take.getTaskEndTime());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试结果</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/11/20/jdyx6ktwzTvEcf8.png" alt="QQ图片20201120172903.png"></p><p><strong>即便往队列中放入数据时，先放入o1，先取出的依旧是o2，以此验证队列的排序规则是谁最先过期，无关放入队列的顺序！</strong></p><p>2.然而通常情况下，我们会使用多线程去取延时队列中的数据，这样即使线程启动之后也能动态的向队列中添加订单。<br>创建一个线程类<code>OrderCheckScheduler</code>实现<code>Runnable</code>接口，<br>添加一个延时队列属性，重写<code>run()</code>方法，在此方法内通过队列的<code>take()</code>方法获得已过期的订单，然后做出相应的处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.DelayQueue;</span><br><span class="line">&#x2F;**</span><br><span class="line">* @author mashu</span><br><span class="line">* Date 2020&#x2F;5&#x2F;17 14:27</span><br><span class="line">*&#x2F;</span><br><span class="line">public class OrderCheckScheduler implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 延时队列</span><br><span class="line">  private DelayQueue&lt;OrderDelayDto&gt; queue;</span><br><span class="line"></span><br><span class="line">  public OrderCheckScheduler(DelayQueue&lt;OrderDelayDto&gt; queue) &#123;</span><br><span class="line">      this.queue &#x3D; queue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">      while (true) &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">              OrderDelayDto take &#x3D; queue.take();</span><br><span class="line">              System.out.println(&quot;订单编号：&quot; + take.getOrderCode() + &quot; 过期时间：&quot; + take.getExpirationTime());</span><br><span class="line">          &#125; catch (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">1234567891011121314151617181920212223242526</span><br></pre></td></tr></table></figure><p>好了，写个方法测试一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建延时队列</span><br><span class="line">    DelayQueue&lt;OrderDelayDto&gt; queue &#x3D; new DelayQueue&lt;&gt;();</span><br><span class="line">    OrderDelayDto o1 &#x3D; new OrderDelayDto();</span><br><span class="line">    &#x2F;&#x2F;第一个订单，过期时间设置为一分钟后</span><br><span class="line">    o1.setOrderCode(&quot;1001&quot;);</span><br><span class="line">    Calendar calendar &#x3D; Calendar.getInstance();</span><br><span class="line">    calendar.add(Calendar.MINUTE, 1);</span><br><span class="line">    o1.setExpirationTime(calendar.getTime());</span><br><span class="line">    OrderDelayDto o2 &#x3D; new OrderDelayDto();</span><br><span class="line">    &#x2F;&#x2F;第二个订单，过期时间设置为现在</span><br><span class="line">    o2.setOrderCode(&quot;1002&quot;);</span><br><span class="line">    o2.setExpirationTime(new Date());</span><br><span class="line">    &#x2F;&#x2F;运行线程</span><br><span class="line">    ExecutorService exec &#x3D; Executors.newFixedThreadPool(1);</span><br><span class="line">    exec.execute(new OrderCheckScheduler(queue));</span><br><span class="line">    &#x2F;&#x2F;往队列中放入数据</span><br><span class="line">    queue.offer(o1);</span><br><span class="line">    queue.offer(o2);</span><br><span class="line">    exec.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;订单自动过期时实现方案&quot;&gt;&lt;a href=&quot;#订单自动过期时实现方案&quot; class=&quot;headerlink&quot; title=&quot;订单自动过期时实现方案&quot;&gt;&lt;/a&gt;订单自动过期时实现方案&lt;/h2&gt;&lt;h4 id=&quot;具体是因为要做的项目需要做一个过滤过期任务的方案：一开始考</summary>
      
    
    
    
    <category term="项目具体问题" scheme="https://cddorz.github.io/categories/%E9%A1%B9%E7%9B%AE%E5%85%B7%E4%BD%93%E9%97%AE%E9%A2%98/"/>
    
    
    <category term="延时队列" scheme="https://cddorz.github.io/tags/%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>骚话合集</title>
    <link href="https://cddorz.github.io/2020/11/19/%E9%AA%9A%E8%AF%9D%E5%90%88%E9%9B%86/"/>
    <id>https://cddorz.github.io/2020/11/19/%E9%AA%9A%E8%AF%9D%E5%90%88%E9%9B%86/</id>
    <published>2020-11-19T12:58:58.000Z</published>
    <updated>2021-01-12T05:08:14.837Z</updated>
    
    <content type="html"><![CDATA[<h3 id="骚话合集（-）"><a href="#骚话合集（-）" class="headerlink" title="骚话合集（=-=）"></a>骚话合集（=-=）</h3><p>作者：言予<br>链接：<a href="https://www.zhihu.com/question/347077309/answer/1414532301">https://www.zhihu.com/question/347077309/answer/1414532301</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>1.人是不能太闲的，闲久了，努力一下就以为是拼命。</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/50/v2-5316b8eb3c993d95435e19e7ab3b2b7f_hd.jpg?source=1940ef5c" alt="img"></p><p>2.我或许败北，或许迷失自己，或许哪里也抵达不了，或许我已失去一切，任凭怎么挣扎也只能徒呼奈何，或许我只是徒然掬一把废墟灰烬，唯我一人蒙在鼓里，或许这里没有任何人把赌注下在我身上。无所谓。有一点是明确的：至少我有值得等待有值得寻求的东西。                                                         ——村上春树 《奇鸟行状录》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/50/v2-6dbfecf502abedec642fdd7a8f55844f_hd.jpg?source=1940ef5c" alt="img"></p><p>3.沉不下心看书，浮跋和焦虑，都是因为年纪渐长，不信正道而太重功利导致的。 真正坚持到最后的人靠的不是激情，而是恰到好处的喜欢和投入。</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic4.zhimg.com/50/v2-8c9022dddadb9afe59ada697424368f9_hd.jpg?source=1940ef5c" alt="img"></p><p>4.对未来的真正慷慨，是把一切都献给现在。                                                                 ——阿尔贝・加缪 《反抗者》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic2.zhimg.com/50/v2-b0f52fb3c451d6c087adee09a25f39de_hd.jpg?source=1940ef5c" alt="img"></p><p>5.我们一路奋战，不是为了改变世界，而是为了不让世界改变我们。                             ——《熔炉》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic4.zhimg.com/50/v2-fa0c650b3ab8df6e9b66020fdb7d0b7c_hd.jpg?source=1940ef5c" alt="img"></p><p>6.闭上眼睛，好好回想之前的努力，自信会喷涌而出。                                                    ——东野圭吾 《放学后》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic4.zhimg.com/50/v2-d9d147e508df2fcfba8e1df4ee61c854_hd.jpg?source=1940ef5c" alt="img"></p><p>7.人的一生，未必都波澜壮阔、荡气回肠，左右我们如何活着的往往是那些每天都在上演、都在谢幕的生命场景。在阳光下细碎如微尘般翻飞跳跃的，恰似我们的一生，只是，有的人拼尽全身力气把微尘舞出了光芒。                                                                 ——《网易云热评》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/50/v2-753111cbfa792fcc85273d5783e03881_hd.jpg?source=1940ef5c" alt="img"></p><p>8.每个人都会有缺陷，就像被上帝咬过的苹果，有的人缺陷比较大，正是因为上帝特别喜欢他的芬芳。                                            —— 托尔斯泰 《战争与和平》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/50/v2-96dcfe896609b091f0f0c940558d2e19_hd.jpg?source=1940ef5c" alt="img"></p><p>9.所谓努力，就是主动而有目的的活动。 ——村上春树</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-2f0e4f0431449c948fda21d490e51800_720w.jpg?source=1940ef5c" alt="img"></p><p>10.如果你还在乎别人说你什么，那你一定是也在潜意识里认同别人说你的东西。只有你真正强大了，才可以不惧怕任何言论。 ——张皓宸 《你是最好的自己》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-7d0e134e06d976eb7a43ff09e9cac31f_720w.jpg?source=1940ef5c" alt="img"></p><p>11.人生在世，委屈、烦难、辛酸，都是难免，重要的是你得翻过去，因为推开暗壁，对面总还有蓝天。                                         ——伊北</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-e0881cea56fbe5219d137e16b572a08b_720w.jpg?source=1940ef5c" alt="img"></p><p>12.生活在阴沟里，依然有仰望星空的权利。                                                                 ——王尔德</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-ae6664f065aba3903a677178be2efb10_720w.jpg?source=1940ef5c" alt="img"></p><p>13.失败的人只有一种，就是在抵达成功之前放弃的人。                                                 ——盖聂 《秦时明月》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-b6f787655b1ca58f9924d7c608cff0a1_720w.jpg?source=1940ef5c" alt="img"></p><p>14.懒惰是很奇怪的东西，它使你以为那是安逸，是休息，是福气；但实际上它所给你的是无聊，是倦怠，是消沉；它剥夺你对前途的希望，割断你和别人之间的友情，使你心胸日渐狭窄，对人生也越来越怀疑 。  ——罗兰 《忙碌与进取》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-d7a8c9c82ce768295b274c305df6adf2_720w.jpg?source=1940ef5c" alt="img"></p><p>15.鹏北海，凤朝阳。又携书剑路茫茫。  —— 辛弃疾</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic3.zhimg.com/80/v2-f6ebc221bd12003692799fb5accd3396_720w.jpg?source=1940ef5c" alt="img"></p><p>16.生活总是让我们遍体鳞伤，可是后来，那些受伤的地方一定会变成我们最强壮的地方。                                                                 ——海明威 《永别了武器》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-2556be31f1c2d598da4f4d6cf02d897d_720w.jpg?source=1940ef5c" alt="img"></p><p>17.要有最朴素的生活，与最遥远的梦想，即使明日天寒地冻，路远马亡。                ——七堇年 《被窝是青春的坟墓》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-6e87a629e01599f0d040f876178b30cf_720w.jpg?source=1940ef5c" alt="img"></p><p>18.纵使黑夜吞噬了一切，太阳还可以重新回来。                                                             ——汪国真</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-ac0dd6046f3c5dd07ad22080f4ad13f8_720w.jpg?source=1940ef5c" alt="img"></p><p>19.世界上什么事都可能发生，就是不会发生不劳而获的事情。                                    ——洛克菲勒 《洛克菲勒给儿子的38封信》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-09ce71a99769d992eb447180bce1a212_720w.jpg?source=1940ef5c" alt="img"></p><p>20.有些事情不是看到希望才去坚持，而是坚持了才会看到希望。                                 ——蜘蛛 《十宗罪》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-fe1508fa6730a13a7387333a2733348e_720w.jpg?source=1940ef5c" alt="img"></p><p>21.看什么励志的书籍？你本来就要活的很励志！</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-5316994cc1beda5eaf5b402b82b7e0fb_720w.jpg?source=1940ef5c" alt="img"></p><p>22.努力会说谎，但努力不会白费。          ——羽生结弦</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-aba3768fd9d2ba2b3a0d778322c0f01f_720w.jpg?source=1940ef5c" alt="img"></p><p>23.越是低谷的时候，越能看出一个人的本质。最差的结果无非是失败，有人等着失败，有人骂着失败，有人尽了力仍然失败。在这样的环境里，心态就是每个人自身的光，你颓唐就是颓唐，你顽强就是顽强。——刘同</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-74936c7dce5718371e79cc08d6d8c4d8_720w.jpg?source=1940ef5c" alt="img"></p><p>24.生活原本沉闷，但跑起来就有风。</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-6b96c9225e64feef2831ddd767f1b148_720w.jpg?source=1940ef5c" alt="img"></p><p>25.不要总以为鹤立鸡群，有本事就离开那群鸡。</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-e09f5a88d9a27df4cbd0aa106cd75b95_720w.jpg?source=1940ef5c" alt="img"></p><p>26.及时当勉励，岁月不待人。                   ——陶渊明 《杂诗》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-d992c1c652c347f0bc94bb26a3eb16a8_720w.jpg?source=1940ef5c" alt="img"></p><p>27.不要停止奔跑，不要回顾来路，来路无可眷恋，值得期待的只有前方。                 ——《马男波杰克》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-a43dcce4162111d62ea42f0b6b202b9c_720w.jpg?source=1940ef5c" alt="img"></p><p>28.人生有时难免会陷入困境，但人的高贵在于，困境中依然保持操守，决不能放纵自我，任错误的欲望泛滥。                            ——鲁迅 《朝花夕拾》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-3cb325ff608201199974e2293eaab709_720w.jpg?source=1940ef5c" alt="img"></p><p>29.有些路很远，走下去会很累，可是，不走，又会后悔。                                            ——安娜・昆德兰 《不曾走过，怎会懂得》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-5a43775763fe83a69b1bdd9b5200bb8c_720w.jpg?source=1940ef5c" alt="img"></p><p>30.你只有不停地奔跑，才能留在原地。   ——刘易斯・卡罗尔 《爱丽丝漫游仙境》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-369e9e3892c0566122983c80e62143ad_720w.jpg?source=1940ef5c" alt="img"></p><p>31.没有谁的生活会一直完美，但无论什么时候都要眼看前方，满怀希望就会所向披靡。                                                                 —— 巫哲 《撒野》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-c8c8bbec89f76936d2bbc29282d9b132_720w.jpg?source=1940ef5c" alt="img"></p><p>32.优于别人，并不高贵，真正的高贵应该是优于过去的自己。                                    ——海明威</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-32f905d1b65f5c1ad915b8a71e8f0053_720w.jpg?source=1940ef5c" alt="img"></p><p>33.怕什么真理无穷，进一寸有一寸的欢喜。                                                                ——胡适</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-69f08346a90dae2076ec3728334451fe_720w.jpg?source=1940ef5c" alt="img"></p><p>34.愿你所得过少时，不会终日愤愤；愿你所得过多时，不必终日惶恐。                    ——东野圭吾 《解忧杂货店》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-c8808b3a917eb913aaefb5849aa77e92_720w.jpg?source=1940ef5c" alt="img"></p><p>35.很多事情就像是旅行一样，当你决定要出发的时候，最困难的那部分其实就已经完成了。                                                             ——卢思浩 《你要去相信，没有到不了的明天》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-f2461a01b84dcafec22647da7c178db0_720w.jpg?source=1940ef5c" alt="img"></p><p>36.也许你感觉自己的努力总是徒劳无功，但不必怀疑，你每天都离顶点更进一步。今天的你离顶点还遥遥无期。但你通过今天的努力，积蓄了明天勇攀高峰的力量。        ——尼采</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-d5025cd62977bba64002e7d7cbc3c019_720w.jpg?source=1940ef5c" alt="img"></p><p>37.只有计划却没有行动的人，不过是一个伪理想主义者，只能眼睁睁地看着人家风光。                                                                 ——辰格 《戒了吧！拖延症》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-97effa387d705480b99d4c05e86f82d7_720w.jpg?source=1940ef5c" alt="img"></p><p>38.凡是不能杀死你的，最终都会让你更强。                                                                 ——尼采</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-390618b0eec72495309a96b84782e52c_720w.jpg?source=1940ef5c" alt="img"></p><p>39.Be yourself; everyone else is already taken.  做你自己，因为别人都有人做了。 ——王尔德</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-647afdecc251a50c3ee0ad6db40861c9_720w.jpg?source=1940ef5c" alt="img"></p><p>40.生活是苦难的，我又划着我的断桨出发了。                                                                ——博尔赫斯</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-ac9759420ceec15a05fdc43c37ed4de4_720w.jpg?source=1940ef5c" alt="img"></p><p>41.很多人的失落，是违背了自己少年时的立志。自认为成熟、自认为练达、自认为精明，从前多幼稚，总算看透了、想穿了。于是，我们就此变成自己年少时最憎恶的那种人。                                                                  ——木心</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-ca6b86fe6486926b714d253872d55c4c_720w.jpg?source=1940ef5c" alt="img"></p><p>42.人生的路程就像爬山一样，看起来走了许多冤枉的路，但最终都会到达山顶。    ——林海音 《城南旧事》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-9ba9b20792c0b794d1e51b780bd1661e_720w.jpg?source=1940ef5c" alt="img"></p><p>43.做有用的事，说勇敢的话，想美好的事，睡安稳的觉。把时间用在进步上，而不是抱怨上。</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-e81e423369ed0f748c8d4b1a608aa5a5_720w.jpg?source=1940ef5c" alt="img"></p><p>44.人要锻炼自己的人格、风骨，不要随风雨破落，失去自己的样子。                         ——林清玄</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-388a216abc2650abf268c9d4a7b24abf_720w.jpg?source=1940ef5c" alt="img"></p><p>45.若要梦想实现，先从梦中醒来。</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-5643814cc9f4983bf871a5d2a33e2a96_720w.jpg?source=1940ef5c" alt="img"></p><p>46.生活从不会因为你是女生就给你开绿灯，你真心想要的，没有一样是轻而易举就可以得到的。你所有的努力，只为在那个对的人出现时，可以理直气壮的说一句：我知道你很好，但是我也不差。                         ——《青春励志》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-4a4212d2a63e36d209352496adf757c6_720w.jpg?source=1940ef5c" alt="img"></p><p>47.谁终将声震人间，必长久深自缄默；谁终将点燃闪电，必长久如云漂泊。             ——尼采</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-706cd577a4e6b915c50c325df9e2bd39_720w.jpg?source=1940ef5c" alt="img"></p><p>48.常常是最后一把钥匙打开了门。            ——钱学森</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-a5e5898650082832f180251230283a89_720w.jpg?source=1940ef5c" alt="img"></p><p>49.无论这个世界对你怎样，都请你一如既往的努力、勇敢、充满希望。                     ——毕淑敏 《愿你与这世界温暖相拥》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-599dbd5fab5347a47156f12a6fddce88_720w.jpg?source=1940ef5c" alt="img"></p><p>50.人生路上若是有绊脚石，那你一定是平行，向上爬，绊脚石都会成为垫脚石。    ——坏瓜 《坏瓜不坏》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-91320e42d8f0580b21962e547f7bec0b_720w.jpg?source=1940ef5c" alt="img"></p><p>51.人们总说时间可以改变很多事，但事实上必须由你自己做出那些改变。                ——安迪·沃霍尔</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-93cd8d576d063e6cf388cbf27037cc56_720w.jpg?source=1940ef5c" alt="img"></p><p>52.不管是谁，不作任何思考、随波逐流地过日子，都会变得很寂寞。                         ——松浦弥太郎</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-17cb90d7f6a7d08d278a88be566e546f_720w.jpg?source=1940ef5c" alt="img"></p><p>53.如果你第一步不迈出，就永远不知道你的梦想是多么容易实现。                             ——李尚龙 《你只是看起来很努力》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-80ba7167c0248fdc5811ee0872769809_720w.jpg?source=1940ef5c" alt="img"></p><p>54.可以不再骄傲，可以失去耐心，也可以丧失理智，但是无论如何，都不要丢掉希望。                                                                ——《英语，励志，佳句》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-56e1605f0a6b69547a0e9436411b08c5_720w.jpg?source=1940ef5c" alt="img"></p><p>55.我需要机会脱离我出生的环境，我认识的人全都充满了怨气，他们活着只是为了生存，但是我相信有比那更好的地方，那里更发达，我要活在那种地方，就是这样。就在那一刻，我明白了，我得作出选择。我可以为自己寻找各种借口对生活低头，也可以迫使自己创造更好的生活。                            ——《风雨哈佛路》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-725840d1bb0f849bcdf2c93d10c3690f_720w.jpg?source=1940ef5c" alt="img"></p><p>56.任何值得做的事，做的糟糕也值得做。</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic3.zhimg.com/80/v2-f0dc0dde7cf57840b69b6e76bece03ed_720w.jpg?source=1940ef5c" alt="img"></p><p>57.一个人只要知道自己去哪里，全世界都会给他让步。                                                 ——爱默生</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-38f70d24348d0dd67772e30653b8ef9f_720w.jpg?source=1940ef5c" alt="img"></p><p>58.若命运不公，就和他斗到底。               ——《哪吒之魔童降世》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-798669b7b21339320615820f97472626_720w.jpg?source=1940ef5c" alt="img"></p><p>59.你们认为没有路，是因为没有学会不择手段。                                                            ——托马斯・维德 《三体》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-01029aaffc3fc39398831945e26625ed_720w.jpg?source=1940ef5c" alt="img"></p><p>60.万物皆有裂痕，那是光进来的地方。   ——莱昂纳德・科恩</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-d8712bcd8371ec2c0f3e460f7a19bea5_720w.jpg?source=1940ef5c" alt="img"></p><p>61.无论怎么样，一个人借故堕落总是不值得原谅的，越是没有人爱，越要爱自己。 ——亦舒</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-4bfe7571a17598e07490f7d1ef9373df_720w.jpg?source=1940ef5c" alt="img"></p><p>62.人一切的痛苦，本质上都是对自己无能的愤怒。而自律，恰恰是解决人生痛苦的根本途径。——王小波</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-6b1474672c45b84f455042a7d3655911_720w.jpg?source=1940ef5c" alt="img"></p><p>63.毋庸置疑，好的事情总会到来。而当它来晚时，也不失为一种惊喜。                      —— 《托斯卡纳艳阳下》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-30abe8100c73996c5cfb5f5d1b7133b8_720w.jpg?source=1940ef5c" alt="img"></p><p>64.我越来越相信，创造美好的代价是：努力、失望以及毅力。首先是疼痛，然后才是欢乐。                                                                ——梵高</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-68ba64961d024971e95cea470cf94210_720w.jpg?source=1940ef5c" alt="img"></p><p>65.世事你不经它，你就摸不准它。世事就俩字：福祸。俩字半边一样，半边不一样，就是说，俩字相互牵连着。就好比箩面的箩筐，咣当摇过去是福，咣当摇过来就是祸。所以说你么得明白，凡遇到好事的时光甭张狂，张狂过头了后边就有祸事。                 ——陈忠实《白鹿原》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic3.zhimg.com/80/v2-eb0449a413b86be931397bf2b0fac2b0_720w.jpg?source=1940ef5c" alt="img"></p><p>66.总之岁月漫长，然而值得等待。           —— 村上春树 《如果我们的语言是威士忌》</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic4.zhimg.com/80/v2-647afdecc251a50c3ee0ad6db40861c9_720w.jpg?source=1940ef5c" alt="img"></p><h2 id="写在最后，没有事是不可能实现的，难的是踏出那一步，以及之后的坚持，与诸君共勉，愿大家都有好的前程，乾坤未定，你我皆是黑马。"><a href="#写在最后，没有事是不可能实现的，难的是踏出那一步，以及之后的坚持，与诸君共勉，愿大家都有好的前程，乾坤未定，你我皆是黑马。" class="headerlink" title="写在最后，没有事是不可能实现的，难的是踏出那一步，以及之后的坚持，与诸君共勉，愿大家都有好的前程，乾坤未定，你我皆是黑马。"></a><strong>写在最后，没有事是不可能实现的，难的是踏出那一步，以及之后的坚持，与诸君共勉，愿大家都有好的前程，乾坤未定，你我皆是黑马。</strong></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;骚话合集（-）&quot;&gt;&lt;a href=&quot;#骚话合集（-）&quot; class=&quot;headerlink&quot; title=&quot;骚话合集（=-=）&quot;&gt;&lt;/a&gt;骚话合集（=-=）&lt;/h3&gt;&lt;p&gt;作者：言予&lt;br&gt;链接：&lt;a href=&quot;https://www.zhihu.com/que</summary>
      
    
    
    
    <category term="日常" scheme="https://cddorz.github.io/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="励志" scheme="https://cddorz.github.io/tags/%E5%8A%B1%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="https://cddorz.github.io/2020/11/16/Redis/"/>
    <id>https://cddorz.github.io/2020/11/16/Redis/</id>
    <published>2020-11-16T06:23:13.000Z</published>
    <updated>2020-11-17T08:31:07.719Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Nosql概述"><a href="#一、Nosql概述" class="headerlink" title="一、Nosql概述"></a>一、Nosql概述</h1><h2 id="1、单机Mysql时代"><a href="#1、单机Mysql时代" class="headerlink" title="1、单机Mysql时代"></a>1、单机Mysql时代</h2><p>90年代,一个网站的访问量一般不会太大，单个数据库完全够用。随着用户增多，网站出现以下问题：</p><ol><li>数据量增加到一定程度，单机数据库就放不下了</li><li>数据的索引（B+ Tree）,一个机器内存也存放不下</li><li>访问量变大后（读写混合），一台服务器承受不住。</li></ol><p><a href="https://img-blog.csdnimg.cn/2020082010365930.png#pic_center"><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020082010365930.png#pic_center" alt="img"></a></p><h2 id="2、Memcached-缓存-Mysql-垂直拆分（读写分离）"><a href="#2、Memcached-缓存-Mysql-垂直拆分（读写分离）" class="headerlink" title="2、Memcached(缓存) + Mysql + 垂直拆分（读写分离）"></a>2、Memcached(缓存) + Mysql + 垂直拆分（读写分离）</h2><p>网站80%的情况都是在读，每次都要去查询数据库的话就十分的麻烦！所以说我们希望减轻数据库的压力，我们可以使用缓存来保证效率！</p><p><a href="https://img-blog.csdnimg.cn/20200820103713734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center"><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200820103713734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="img"></a></p><p>优化过程经历了以下几个过程：</p><ol><li>优化数据库的数据结构和索引(难度大)</li><li>文件缓存，通过IO流获取比每次都访问数据库效率略高，但是流量爆炸式增长时候，IO流也承受不了</li><li>MemCache,当时最热门的技术，通过在数据库和数据库访问层之间加上一层缓存，第一次访问时查询数据库，将结果保存到缓存，后续的查询先检查缓存，若有直接拿去使用，效率显著提升。</li></ol><h2 id="3、分库分表-水平拆分-Mysql集群"><a href="#3、分库分表-水平拆分-Mysql集群" class="headerlink" title="3、分库分表 + 水平拆分 + Mysql集群"></a>3、分库分表 + 水平拆分 + Mysql集群</h2><p><a href="https://img-blog.csdnimg.cn/20200820103739584.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center"><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200820103739584.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="img"></a></p><h2 id="4、如今最近的年代"><a href="#4、如今最近的年代" class="headerlink" title="4、如今最近的年代"></a>4、如今最近的年代</h2><p>如今信息量井喷式增长，各种各样的数据出现（用户定位数据，图片数据等），大数据的背景下关系型数据库（RDBMS）无法满足大量数据要求。Nosql数据库就能轻松解决这些问题。目前一个基本的互联网项目：</p><p><a href="https://img-blog.csdnimg.cn/20200820103804572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center"><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200820103804572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="img"></a></p><h2 id="5、为什么要用NoSQL-？"><a href="#5、为什么要用NoSQL-？" class="headerlink" title="5、为什么要用NoSQL ？"></a>5、为什么要用NoSQL ？</h2><p>用户的个人信息，社交网络，地理位置。用户自己产生的数据，用户日志等等爆发式增长！这时候我们就需要使用NoSQL数据库的，Nosql可以很好的处理以上的情况！</p><h3 id="什么是Nosql"><a href="#什么是Nosql" class="headerlink" title="什么是Nosql"></a>什么是Nosql</h3><p>NoSQL = Not Only SQL（不仅仅是SQL）</p><p>Not Only Structured Query Language</p><p>关系型数据库：列+行，同一个表下数据的结构是一样的。</p><p>非关系型数据库：数据存储没有固定的格式，并且可以进行横向扩展。</p><p>NoSQL泛指非关系型数据库，随着web2.0互联网的诞生，传统的关系型数据库很难对付web2.0时代！尤其是超大规模的高并发的社区，暴露出来很多难以克服的问题，NoSQL在当今大数据环境下发展的十分迅速，Redis是发展最快的。</p><h3 id="Nosql特点"><a href="#Nosql特点" class="headerlink" title="Nosql特点"></a>Nosql特点</h3><p>1.方便扩展（数据之间没有关系，很好扩展！）</p><p>2.大数据量高性能（Redis一秒可以写8万次，读11万次，NoSQL的缓存记录级，是一种细粒度的缓存，性能会比较高！）</p><p>3.数据类型是多样型的！（不需要事先设计数据库，随取随用）</p><p>4.传统的 RDBMS 和 NoSQL</p><blockquote><p>传统的 RDBMS(关系型数据库)</p><blockquote><p>结构化组织<br>SQL<br>数据和关系都存在单独的表中 row col<br>操作，数据定义语言<br>严格的一致性<br>基础的事务<br>…</p></blockquote><p>Nosql</p><blockquote><p>不仅仅是数据<br>没有固定的查询语言<br>键值对存储，列存储，文档存储，图形数据库（社交关系）<br>最终一致性<br>CAP定理和BASE<br>高性能，高可用，高扩展<br>…</p></blockquote></blockquote><p>5.大数据时代的3V ：主要是描述问题的</p><p>海量Velume</p><p>多样Variety</p><p>实时Velocity</p><p>6.大数据时代的3高 ： 主要是对程序的要求</p><p>高并发</p><p>高可扩</p><p>高性能</p><p>真正在公司中的实践：NoSQL + RDBMS 一起使用才是最强的。</p><h1 id="二、Redis入门"><a href="#二、Redis入门" class="headerlink" title="二、Redis入门"></a>二、Redis入门</h1><h2 id="Redis是什么？"><a href="#Redis是什么？" class="headerlink" title="Redis是什么？"></a>Redis是什么？</h2><p>Redis（Remote Dictionary Server )，即远程字典服务。</p><p>是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><p>与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p><h2 id="Redis能干什么？"><a href="#Redis能干什么？" class="headerlink" title="Redis能干什么？"></a>Redis能干什么？</h2><ol><li>内存存储、持久化，内存是断电即失的，所以需要持久化（RDB、AOF）</li><li>高效率、用于高速缓冲</li><li>发布订阅系统</li><li>地图信息分析</li><li>计时器、计数器(eg：浏览量)</li><li>。。。</li></ol><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol><li>多样的数据类型</li><li>持久化</li><li>集群</li><li>事务</li><li>…</li></ol><h2 id="环境搭建（略）"><a href="#环境搭建（略）" class="headerlink" title="环境搭建（略）"></a>环境搭建（略）</h2><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p><strong>redis-benchmark：</strong>Redis官方提供的性能测试工具，参数选项如下：</p><p><a href="https://img-blog.csdnimg.cn/20200513214125892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70"><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513214125892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="img"></a></p><p>简单测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 测试：100个并发连接 100000请求</span><br><span class="line">redis-benchmark -h localhost -p 6379 -c 100 -n 100000</span><br></pre></td></tr></table></figure><p>结果：</p><p><a href="https://img-blog.csdnimg.cn/20200820104343472.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center"><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200820104343472.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="img"></a></p><h5 id="连接redis："><a href="#连接redis：" class="headerlink" title="连接redis："></a>连接redis：</h5><p><img src= "/img/loading.gif" data-lazy-src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20201117102815212.png" alt="image-20201117102815212"></p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>redis默认有16个数据库</p><p><a href="https://img-blog.csdnimg.cn/20200820104357466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center"><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200820104357466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="img"></a></p><p>默认使用的第0个;</p><p>16个数据库为：DB 0~DB 15 默认使用DB 0 ，可以使用<code>select n</code>切换到DB n，<code>dbsize</code>可以查看当前数据库的大小，与key数量相关。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get databases # 命令行查看数据库数量databases</span><br><span class="line">1) &quot;databases&quot;</span><br><span class="line">2) &quot;16&quot;</span><br><span class="line">127.0.0.1:6379&gt; select 8 # 切换数据库 DB 8</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[8]&gt; dbsize # 查看数据库大小</span><br><span class="line">(integer) 0</span><br><span class="line">不同数据库之间 数据是不能互通的，并且dbsize 是根据库中key的个数。</span><br><span class="line">127.0.0.1:6379&gt; set name sakura</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; SELECT 8</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[8]&gt; get name # db8中并不能获取db0中的键值对。</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379[8]&gt; DBSIZE</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379[8]&gt; SELECT 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line"></span><br><span class="line">&quot;counter:rand_int&quot;</span><br><span class="line">&quot;mylist&quot;</span><br><span class="line">&quot;name&quot;</span><br><span class="line">&quot;key:rand_int&quot;</span><br><span class="line">&quot;myset:rand_int&quot;</span><br><span class="line">127.0.0.1:6379&gt; DBSIZE # size和key个数相关</span><br><span class="line">(integer) 5</span><br></pre></td></tr></table></figure><p><code>keys *</code> ：查看当前数据库中所有的key。</p><p><code>flushdb</code>：清空当前数据库中的键值对。</p><p><code>flushall</code>：清空所有数据库的键值对。</p><blockquote><p>Redis是单线程的，Redis是基于内存操作的。</p></blockquote><p>所以Redis的性能瓶颈不是CPU,而是机器内存和网络带宽。</p><p>那么为什么Redis的速度如此快呢，性能这么高呢？QPS达到10W+</p><blockquote><p>Redis为什么单线程还这么快？</p></blockquote><ul><li>误区1：高性能的服务器一定是多线程的？</li><li>误区2：多线程（CPU上下文会切换！）一定比单线程效率高！</li></ul><p>核心：Redis是将所有的数据放在内存中的，所以说使用单线程去操作效率就是最高的，多线程（CPU上下文会切换：耗时的操作！），对于内存系统来说，如果没有上下文切换效率就是最高的，多次读写都是在一个CPU上的，在内存存储数据情况下，单线程就是最佳的方案。</p><h1 id="三、五大数据类型"><a href="#三、五大数据类型" class="headerlink" title="三、五大数据类型"></a>三、五大数据类型</h1><p> Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。它支持字符串、哈希表、列表、集合、有序集合，位图，hyperloglogs等数据类型。内置复制、Lua脚本、LRU收回、事务以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区。</p><h2 id="Redis-key"><a href="#Redis-key" class="headerlink" title="Redis-key"></a>Redis-key</h2><p>在redis中无论什么数据类型，在数据库中都是以key-value形式保存，通过进行对Redis-key的操作，来完成对数据库中数据的操作。</p><p>下面学习的命令：</p><ul><li><code>exists key</code>：判断键是否存在</li><li><code>del key</code>：删除键值对</li><li><code>move key db</code>：将键值对移动到指定数据库</li><li><code>expire key second</code>：设置键值对的过期时间</li><li><code>type key</code>：查看value的数据类型</li></ul><p>　　　</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys * # 查看当前数据库所有key</span><br><span class="line">(empty list or set)</span><br><span class="line">127.0.0.1:6379&gt; set name qinjiang # set key</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set age 20</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;age&quot;</span><br><span class="line">2) &quot;name&quot;</span><br><span class="line">127.0.0.1:6379&gt; move age 1 # 将键值对移动到指定数据库</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; EXISTS age # 判断键是否存在</span><br><span class="line">(integer) 0 # 不存在</span><br><span class="line">127.0.0.1:6379&gt; EXISTS name</span><br><span class="line">(integer) 1 # 存在</span><br><span class="line">127.0.0.1:6379&gt; SELECT 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[1]&gt; keys *</span><br><span class="line">1) &quot;age&quot;</span><br><span class="line">127.0.0.1:6379[1]&gt; del age # 删除键值对</span><br><span class="line">(integer) 1 # 删除个数</span><br><span class="line">127.0.0.1:6379&gt; set age 20</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; EXPIRE age 15 # 设置键值对的过期时间</span><br><span class="line">(integer) 1 # 设置成功 开始计数</span><br><span class="line">127.0.0.1:6379&gt; ttl age # 查看key的过期剩余时间</span><br><span class="line">(integer) 13</span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(integer) 11</span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(integer) 9</span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(integer) -2 # -2 表示key过期，-1表示key未设置过期时间</span><br><span class="line">127.0.0.1:6379&gt; get age # 过期的key 会被自动delete</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line"></span><br><span class="line">&quot;name&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; type name # 查看value的数据类型</span><br><span class="line">string</span><br></pre></td></tr></table></figure><p>关于TTL命令</p><p>Redis的key，通过TTL命令返回key的过期时间，一般来说有3种：</p><ol><li>当前key没有设置过期时间，所以会返回-1.</li><li>当前key有设置过期时间，而且key已经过期，所以会返回-2.</li><li>当前key有设置过期时间，且key还没有过期，故会返回key的正常剩余时间.</li></ol><p>关于重命名<code>RENAME</code>和<code>RENAMENX</code></p><ol><li><code>RENAME key newkey</code>修改 key 的名称</li><li><code>RENAMENX key newkey</code>仅当 newkey 不存在时，将 key 改名为 newkey 。</li></ol><h2 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String(字符串)"></a>String(字符串)</h2><p>普通的set、get直接略过。</p><p>常用命令及其示例：</p><p><code>APPEND key value</code>: 向指定的key的value后追加字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set msg hello </span><br><span class="line">OK </span><br><span class="line">127.0.0.1:6379&gt; append msg &quot; world&quot; </span><br><span class="line">(integer) 11 </span><br><span class="line">127.0.0.1:6379&gt; get msg </span><br><span class="line">“hello world”</span><br></pre></td></tr></table></figure><p><code>DECR/INCR key</code>: 将指定key的value数值进行+1/-1(仅对于数字)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set age 20 </span><br><span class="line">OK </span><br><span class="line">127.0.0.1:6379&gt; incr age </span><br><span class="line">(integer) 21 </span><br><span class="line">127.0.0.1:6379&gt; decr age </span><br><span class="line">(integer) 20</span><br></pre></td></tr></table></figure><p><code>INCRBY/DECRBY key n</code>: 按指定的步长对数值进行加减</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; INCRBY age 5</span><br><span class="line">(integer) 25 </span><br><span class="line">127.0.0.1:6379&gt; DECRBY age 10 </span><br><span class="line">(integer) 15</span><br></pre></td></tr></table></figure><p><code>INCRBYFLOAT key n</code>: 为数值加上浮点型数值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; INCRBYFLOAT age 5.2 </span><br><span class="line">“20.2”</span><br></pre></td></tr></table></figure><p><code>STRLEN key</code>: 获取key保存值的字符串长度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get msg </span><br><span class="line">“hello world” </span><br><span class="line">127.0.0.1:6379&gt; STRLEN msg </span><br><span class="line">(integer) 11</span><br></pre></td></tr></table></figure><p><code>GETRANGE key start end</code>: 按起止位置获取字符串（闭区间，起止位置都取）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get msg </span><br><span class="line">“hello world” </span><br><span class="line">127.0.0.1:6379&gt; GETRANGE msg 3 9 </span><br><span class="line">“lo worl”</span><br></pre></td></tr></table></figure><p><code>SETRANGE key offset value</code>:用指定的value 替换key中 offset开始的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set msg hello</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; setrange msg 2 hello</span><br><span class="line">(integer) 7</span><br><span class="line">127.0.0.1:6379&gt; get msg</span><br><span class="line">&quot;hehello&quot;</span><br><span class="line">127.0.0.1:6379&gt; set msg2 world</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; setrange msg2 2 ww</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; get msg2</span><br><span class="line">&quot;wowwd&quot;</span><br></pre></td></tr></table></figure><p><code>GETSET key value</code>: 将给定 key 的值设为 value ，并返回 key 的旧值(old value)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GETSET msg test </span><br><span class="line">“hello world”</span><br></pre></td></tr></table></figure><p><code>SETNX key value</code>: 仅当key不存在时进行set</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SETNX msg test </span><br><span class="line">(integer) 0 </span><br><span class="line">127.0.0.1:6379&gt; SETNX name sakura </span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p><code>SETEX key seconds value</code>: set 键值对并设置过期时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setex name 10 root </span><br><span class="line">OK </span><br><span class="line">127.0.0.1:6379&gt; get name </span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p><code>MSET key1 value1 [key2 value2..]</code>: 批量set键值对</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MSET k1 v1 k2 v2 k3 v3 </span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p><code>MSETNX key1 value1 [key2 value2..]</code>: 批量设置键值对，仅当参数中所有的key都不存在时执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MSETNX k1 v1 k4 v4 </span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><p><code>MGET key1 [key2..]</code>: 批量获取多个key保存的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MGET k1 k2 k3 </span><br><span class="line">1) “v1” </span><br><span class="line">2) “v2” </span><br><span class="line">3) “v3”</span><br></pre></td></tr></table></figure><p><code>PSETEX key milliseconds value</code>: 和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间</p><p>String类似的使用场景：value除了是字符串还可以是数字，用途举例：</p><ul><li>计数器</li><li>统计多单位的数量：uid:123666：follow 0</li><li>粉丝数</li><li>对象存储缓存</li></ul><h2 id="List-列表"><a href="#List-列表" class="headerlink" title="List(列表)"></a>List(列表)</h2><p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）</p><p>一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。</p><p>首先我们列表，可以经过规则定义将其变为队列、栈、双端队列等。</p><p><a href="https://img-blog.csdnimg.cn/20200820104440398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center"><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200820104440398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="img"></a></p><p>正如图Redis中List是可以进行双端操作的，所以命令也就分为了LXXX和RLLL两类，有时候L也表示List例如LLEN</p><ul><li><code>LPUSH/RPUSH key value1[value2..]</code>从左边/右边向列表中PUSH值(一个或者多个)。</li><li><code>LRANGE key start end</code> 获取list 起止元素==（索引从左往右 递增）==</li><li><code>LPUSHX/RPUSHX key value</code> 向已存在的列名中push值（一个或者多个）</li><li><code>LINSERT key BEFORE|AFTER pivot value</code> 在指定列表元素的前/后 插入value</li><li><code>LLEN key</code> 查看列表长度</li><li><code>LINDEX key index</code> 通过索引获取列表元素</li><li><code>LSET key index value</code> 通过索引为元素设值</li><li><code>LPOP/RPOP key</code> 从最左边/最右边移除值 并返回</li><li><code>RPOPLPUSH source destination</code> 将列表的尾部(右)最后一个值弹出，并返回，然后加到另一个列表的头部</li><li><code>LTRIM key start end</code> 通过下标截取指定范围内的列表</li><li><code>LREM key count value</code> List中是允许value重复的 count &gt; 0：从头部开始搜索 然后删除指定的value 至多删除count个 count &lt; 0：从尾部开始搜索… count = 0：删除列表中所有的指定value。</li><li><code>BLPOP/BRPOP key1[key2] timout</code> 移出并获取列表的第一个/最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</li><li><code>BRPOPLPUSH source destination timeout</code> 和RPOPLPUSH功能相同，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</li></ul><p>代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">---------------------------LPUSH---RPUSH---LRANGE--------------------------------</span><br><span class="line">127.0.0.1:6379&gt; LPUSH mylist k1 # LPUSH mylist&#x3D;&gt;&#123;1&#125;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; LPUSH mylist k2 # LPUSH mylist&#x3D;&gt;&#123;2,1&#125;</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; RPUSH mylist k3 # RPUSH mylist&#x3D;&gt;&#123;2,1,3&#125;</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; get mylist # 普通的get是无法获取list值的</span><br><span class="line">(error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 4 # LRANGE 获取起止位置范围内的元素</span><br><span class="line"></span><br><span class="line">&quot;k2&quot;</span><br><span class="line">&quot;k1&quot;</span><br><span class="line">&quot;k3&quot;</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 2</span><br><span class="line">&quot;k2&quot;</span><br><span class="line">&quot;k1&quot;</span><br><span class="line">&quot;k3&quot;</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 1</span><br><span class="line">&quot;k2&quot;</span><br><span class="line">&quot;k1&quot;</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1 # 获取全部元素</span><br><span class="line">&quot;k2&quot;</span><br><span class="line">&quot;k1&quot;</span><br><span class="line">&quot;k3&quot;</span><br><span class="line"></span><br><span class="line">---------------------------LPUSHX---RPUSHX-----------------------------------</span><br><span class="line">127.0.0.1:6379&gt; LPUSHX list v1 # list不存在 LPUSHX失败</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; LPUSHX list v1 v2</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; LPUSHX mylist k4 k5 # 向mylist中 左边 PUSH k4 k5</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line"></span><br><span class="line">&quot;k5&quot;</span><br><span class="line">&quot;k4&quot;</span><br><span class="line">&quot;k2&quot;</span><br><span class="line">&quot;k1&quot;</span><br><span class="line">&quot;k3&quot;</span><br><span class="line"></span><br><span class="line">---------------------------LINSERT--LLEN--LINDEX--LSET----------------------------</span><br><span class="line">127.0.0.1:6379&gt; LINSERT mylist after k2 ins_key1 # 在k2元素后 插入ins_key1</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line"></span><br><span class="line">&quot;k5&quot;</span><br><span class="line">&quot;k4&quot;</span><br><span class="line">&quot;k2&quot;</span><br><span class="line">&quot;ins_key1&quot;</span><br><span class="line">&quot;k1&quot;</span><br><span class="line">&quot;k3&quot;</span><br><span class="line">127.0.0.1:6379&gt; LLEN mylist # 查看mylist的长度</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; LINDEX mylist 3 # 获取下标为3的元素</span><br><span class="line">&quot;ins_key1&quot;</span><br><span class="line">127.0.0.1:6379&gt; LINDEX mylist 0</span><br><span class="line">&quot;k5&quot;</span><br><span class="line">127.0.0.1:6379&gt; LSET mylist 3 k6 # 将下标3的元素 set值为k6</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">&quot;k5&quot;</span><br><span class="line">&quot;k4&quot;</span><br><span class="line">&quot;k2&quot;</span><br><span class="line">&quot;k6&quot;</span><br><span class="line">&quot;k1&quot;</span><br><span class="line">&quot;k3&quot;</span><br><span class="line"></span><br><span class="line">---------------------------LPOP--RPOP--------------------------</span><br><span class="line">127.0.0.1:6379&gt; LPOP mylist # 左侧(头部)弹出</span><br><span class="line">&quot;k5&quot;</span><br><span class="line">127.0.0.1:6379&gt; RPOP mylist # 右侧(尾部)弹出</span><br><span class="line">&quot;k3&quot;</span><br><span class="line">---------------------------RPOPLPUSH--------------------------</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line"></span><br><span class="line">&quot;k4&quot;</span><br><span class="line">&quot;k2&quot;</span><br><span class="line">&quot;k6&quot;</span><br><span class="line">&quot;k1&quot;</span><br><span class="line">127.0.0.1:6379&gt; RPOPLPUSH mylist newlist # 将mylist的最后一个值(k1)弹出，加入到newlist的头部</span><br><span class="line">&quot;k1&quot;</span><br><span class="line">127.0.0.1:6379&gt; LRANGE newlist 0 -1</span><br><span class="line">&quot;k1&quot;</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">&quot;k4&quot;</span><br><span class="line">&quot;k2&quot;</span><br><span class="line">&quot;k6&quot;</span><br><span class="line"></span><br><span class="line">---------------------------LTRIM--------------------------</span><br><span class="line">127.0.0.1:6379&gt; LTRIM mylist 0 1 # 截取mylist中的 0~1部分</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line"></span><br><span class="line">&quot;k4&quot;</span><br><span class="line">&quot;k2&quot;</span><br><span class="line"></span><br><span class="line">初始 mylist: k2,k2,k2,k2,k2,k2,k4,k2,k2,k2,k2</span><br><span class="line">---------------------------LREM--------------------------</span><br><span class="line">127.0.0.1:6379&gt; LREM mylist 3 k2 # 从头部开始搜索 至多删除3个 k2</span><br><span class="line">(integer) 3</span><br><span class="line">删除后：mylist: k2,k2,k2,k4,k2,k2,k2,k2</span><br><span class="line">127.0.0.1:6379&gt; LREM mylist -2 k2 #从尾部开始搜索 至多删除2个 k2</span><br><span class="line">(integer) 2</span><br><span class="line">删除后：mylist: k2,k2,k2,k4,k2,k2</span><br><span class="line">---------------------------BLPOP--BRPOP--------------------------</span><br><span class="line">mylist: k2,k2,k2,k4,k2,k2</span><br><span class="line">newlist: k1</span><br><span class="line">127.0.0.1:6379&gt; BLPOP newlist mylist 30 # 从newlist中弹出第一个值，mylist作为候选</span><br><span class="line"></span><br><span class="line">&quot;newlist&quot; # 弹出</span><br><span class="line">&quot;k1&quot;</span><br><span class="line">127.0.0.1:6379&gt; BLPOP newlist mylist 30</span><br><span class="line">&quot;mylist&quot; # 由于newlist空了 从mylist中弹出</span><br><span class="line">&quot;k2&quot;</span><br><span class="line">127.0.0.1:6379&gt; BLPOP newlist 30</span><br><span class="line">(30.10s) # 超时了</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; BLPOP newlist 30 # 我们连接另一个客户端向newlist中push了test, 阻塞被解决。</span><br><span class="line"></span><br><span class="line">&quot;newlist&quot;</span><br><span class="line">&quot;test&quot;</span><br><span class="line">(12.54s)</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>list实际上是一个链表，before Node after , left, right 都可以插入值</li><li>如果key不存在，则创建新的链表</li><li>如果key存在，新增内容</li><li>如果移除了所有值，空链表，也代表不存在</li><li>在两边插入或者改动值，效率最高！修改中间元素，效率相对较低</li></ul><p>应用：</p><p>消息排队！消息队列（Lpush Rpop）,栈（Lpush Lpop）</p><h2 id="Set-集合）"><a href="#Set-集合）" class="headerlink" title="Set(集合）"></a>Set(集合）</h2><p>Redis的Set是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p><p>Redis中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p><p>集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p><ul><li><code>SADD key member1[member2..]</code> 向集合中无序增加一个/多个成员</li><li><code>SCARD key</code> 获取集合的成员数</li><li><code>SMEMBERS key</code> 返回集合中所有的成员</li><li><code>SISMEMBER key member</code> 查询member元素是否是集合的成员,结果是无序的</li><li><code>SRANDMEMBER key [count]</code> 随机返回集合中count个成员，count缺省值为1</li><li><code>SPOP key [count]</code> 随机移除并返回集合中count个成员，count缺省值为1</li><li><code>SMOVE source destination member</code> 将source集合的成员member移动到destination集合</li><li><code>SREM key member1[member2..]</code> 移除集合中一个/多个成员</li><li><code>SDIFF key1[key2..]</code> 返回所有集合的差集 key1- key2 - …</li><li><code>SDIFFSTORE destination key1[key2..]</code> 在SDIFF的基础上，将结果保存到集合中==(覆盖)==。不能保存到其他类型key噢！</li><li><code>SINTER key1 [key2..]</code> 返回所有集合的交集</li><li><code>SINTERSTORE destination key1[key2..]</code> 在SINTER的基础上，存储结果到集合中。覆盖</li><li><code>SUNION key1 [key2..]</code> 返回所有集合的并集</li><li><code>SUNIONSTORE destination key1 [key2..]</code> 在SUNION的基础上，存储结果到及和张。覆盖</li><li><code>SSCAN KEY [MATCH pattern] [COUNT count]</code> 在大量数据环境下，使用此命令遍历集合中元素，每次遍历部分</li></ul><p>代码示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">---------------SADD--SCARD--SMEMBERS--SISMEMBER--------------------</span><br><span class="line">127.0.0.1:6379&gt; SADD myset m1 m2 m3 m4 # 向myset中增加成员 m1~m4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; SCARD myset # 获取集合的成员数目</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; smembers myset # 获取集合中所有成员</span><br><span class="line"></span><br><span class="line">&quot;m4&quot;</span><br><span class="line">&quot;m3&quot;</span><br><span class="line">&quot;m2&quot;</span><br><span class="line">&quot;m1&quot;</span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset m5 # 查询m5是否是myset的成员</span><br><span class="line">(integer) 0 # 不是，返回0</span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset m2</span><br><span class="line">(integer) 1 # 是，返回1</span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset m3</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">---------------------SRANDMEMBER--SPOP----------------------------------</span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset 3 # 随机返回3个成员</span><br><span class="line"></span><br><span class="line">&quot;m2&quot;</span><br><span class="line">&quot;m3&quot;</span><br><span class="line">&quot;m4&quot;</span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset # 随机返回1个成员</span><br><span class="line">&quot;m3&quot;</span><br><span class="line">127.0.0.1:6379&gt; SPOP myset 2 # 随机移除并返回2个成员</span><br><span class="line">&quot;m1&quot;</span><br><span class="line">&quot;m4&quot;</span><br><span class="line"></span><br><span class="line">将set还原到&#123;m1,m2,m3,m4&#125;</span><br><span class="line">---------------------SMOVE--SREM----------------------------------------</span><br><span class="line">127.0.0.1:6379&gt; SMOVE myset newset m3 # 将myset中m3成员移动到newset集合</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line"></span><br><span class="line">&quot;m4&quot;</span><br><span class="line">&quot;m2&quot;</span><br><span class="line">&quot;m1&quot;</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS newset</span><br><span class="line">&quot;m3&quot;</span><br><span class="line">127.0.0.1:6379&gt; SREM newset m3 # 从newset中移除m3元素</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS newset</span><br><span class="line">(empty list or set)</span><br><span class="line"></span><br><span class="line">下面开始是多集合操作,多集合操作中若只有一个参数默认和自身进行运算</span><br><span class="line">setx&#x3D;&gt;&#123;m1,m2,m4,m6&#125;, sety&#x3D;&gt;&#123;m2,m5,m6&#125;, setz&#x3D;&gt;&#123;m1,m3,m6&#125;</span><br><span class="line">-----------------------------SDIFF------------------------------------</span><br><span class="line">127.0.0.1:6379&gt; SDIFF setx sety setz # 等价于setx-sety-setz</span><br><span class="line"></span><br><span class="line">&quot;m4&quot;</span><br><span class="line">127.0.0.1:6379&gt; SDIFF setx sety # setx - sety</span><br><span class="line">&quot;m4&quot;</span><br><span class="line">&quot;m1&quot;</span><br><span class="line">127.0.0.1:6379&gt; SDIFF sety setx # sety - setx</span><br><span class="line">&quot;m5&quot;</span><br><span class="line"></span><br><span class="line">-------------------------SINTER---------------------------------------</span><br><span class="line">共同关注（交集）</span><br><span class="line">127.0.0.1:6379&gt; SINTER setx sety setz # 求 setx、sety、setx的交集</span><br><span class="line"></span><br><span class="line">&quot;m6&quot;</span><br><span class="line">127.0.0.1:6379&gt; SINTER setx sety # 求setx sety的交集</span><br><span class="line">&quot;m2&quot;</span><br><span class="line">&quot;m6&quot;</span><br><span class="line"></span><br><span class="line">-------------------------SUNION---------------------------------------</span><br><span class="line">127.0.0.1:6379&gt; SUNION setx sety setz # setx sety setz的并集</span><br><span class="line"></span><br><span class="line">&quot;m4&quot;</span><br><span class="line">&quot;m6&quot;</span><br><span class="line">&quot;m3&quot;</span><br><span class="line">&quot;m2&quot;</span><br><span class="line">&quot;m1&quot;</span><br><span class="line">&quot;m5&quot;</span><br><span class="line">127.0.0.1:6379&gt; SUNION setx sety # setx sety 并集</span><br><span class="line">&quot;m4&quot;</span><br><span class="line">&quot;m6&quot;</span><br><span class="line">&quot;m2&quot;</span><br><span class="line">&quot;m1&quot;</span><br><span class="line">&quot;m5&quot;</span><br></pre></td></tr></table></figure><h2 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h2><p>Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p><p>Set就是一种简化的Hash,只变动key,而value使用默认值填充。可以将一个Hash表作为一个对象进行存储，表中存放对象的信息。</p><ul><li><code>HSET key field value</code> 将哈希表 key 中的字段 field 的值设为 value 。重复设置同一个field会覆盖,返回0</li><li><code>HMSET key field1 value1 [field2 value2..]</code> 同时将多个 field-value (域-值)对设置到哈希表 key 中。</li><li><code>HSETNX key field value</code> 只有在字段 field 不存在时，设置哈希表字段的值。</li><li><code>HEXISTS key field</code> 查看哈希表 key 中，指定的字段是否存在。</li><li><code>HGET key field value</code> 获取存储在哈希表中指定字段的值</li><li><code>HMGET key field1 [field2..]</code> 获取所有给定字段的值</li><li><code>HGETALL key</code> 获取在哈希表key 的所有字段和值</li><li><code>HKEYS key</code> 获取哈希表key中所有的字段</li><li><code>HLEN key</code> 获取哈希表中字段的数量</li><li><code>HVALS key</code> 获取哈希表中所有值</li><li><code>HDEL key field1 [field2..]</code> 删除哈希表key中一个/多个field字段</li><li><code>HINCRBY key field n</code> 为哈希表 key 中的指定字段的整数值加上增量n，并返回增量后结果 一样只适用于整数型字段</li><li><code>HINCRBYFLOAT key field n</code> 为哈希表 key 中的指定字段的浮点数值加上增量 n。</li><li><code>HSCAN key cursor [MATCH pattern] [COUNT count]</code> 迭代哈希表中的键值对。</li></ul><p>代码示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">------------------------HSET--HMSET--HSETNX----------------</span><br><span class="line">127.0.0.1:6379&gt; HSET studentx name sakura # 将studentx哈希表作为一个对象，设置name为sakura</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; HSET studentx name gyc # 重复设置field进行覆盖，并返回0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; HSET studentx age 20 # 设置studentx的age为20</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; HMSET studentx sex 1 tel 15623667886 # 设置sex为1，tel为15623667886</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; HSETNX studentx name gyc # HSETNX 设置已存在的field</span><br><span class="line">(integer) 0 # 失败</span><br><span class="line">127.0.0.1:6379&gt; HSETNX studentx email 12345@qq.com</span><br><span class="line">(integer) 1 # 成功</span><br><span class="line">----------------------HEXISTS--------------------------------</span><br><span class="line">127.0.0.1:6379&gt; HEXISTS studentx name # name字段在studentx中是否存在</span><br><span class="line">(integer) 1 # 存在</span><br><span class="line">127.0.0.1:6379&gt; HEXISTS studentx addr</span><br><span class="line">(integer) 0 # 不存在</span><br><span class="line">-------------------HGET--HMGET--HGETALL-----------</span><br><span class="line">127.0.0.1:6379&gt; HGET studentx name # 获取studentx中name字段的value</span><br><span class="line">&quot;gyc&quot;</span><br><span class="line">127.0.0.1:6379&gt; HMGET studentx name age tel # 获取studentx中name、age、tel字段的value</span><br><span class="line"></span><br><span class="line">&quot;gyc&quot;</span><br><span class="line">&quot;20&quot;</span><br><span class="line">&quot;15623667886&quot;</span><br><span class="line">127.0.0.1:6379&gt; HGETALL studentx # 获取studentx中所有的field及其value</span><br><span class="line">&quot;name&quot;</span><br><span class="line">&quot;gyc&quot;</span><br><span class="line">&quot;age&quot;</span><br><span class="line">&quot;20&quot;</span><br><span class="line">&quot;sex&quot;</span><br><span class="line">&quot;1&quot;</span><br><span class="line">&quot;tel&quot;</span><br><span class="line">&quot;15623667886&quot;</span><br><span class="line">&quot;email&quot;</span><br><span class="line">&quot;12345@qq.com&quot;</span><br><span class="line"></span><br><span class="line">--------------------HKEYS--HLEN--HVALS--------------</span><br><span class="line">127.0.0.1:6379&gt; HKEYS studentx # 查看studentx中所有的field</span><br><span class="line"></span><br><span class="line">&quot;name&quot;</span><br><span class="line">&quot;age&quot;</span><br><span class="line">&quot;sex&quot;</span><br><span class="line">&quot;tel&quot;</span><br><span class="line">&quot;email&quot;</span><br><span class="line">127.0.0.1:6379&gt; HLEN studentx # 查看studentx中的字段数量</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; HVALS studentx # 查看studentx中所有的value</span><br><span class="line">&quot;gyc&quot;</span><br><span class="line">&quot;20&quot;</span><br><span class="line">&quot;1&quot;</span><br><span class="line">&quot;15623667886&quot;</span><br><span class="line">&quot;12345@qq.com&quot;</span><br><span class="line"></span><br><span class="line">-------------------------HDEL--------------------------</span><br><span class="line">127.0.0.1:6379&gt; HDEL studentx sex tel # 删除studentx 中的sex、tel字段</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; HKEYS studentx</span><br><span class="line"></span><br><span class="line">&quot;name&quot;</span><br><span class="line">&quot;age&quot;</span><br><span class="line">&quot;email&quot;</span><br><span class="line"></span><br><span class="line">-------------HINCRBY--HINCRBYFLOAT------------------------</span><br><span class="line">127.0.0.1:6379&gt; HINCRBY studentx age 1 # studentx的age字段数值+1</span><br><span class="line">(integer) 21</span><br><span class="line">127.0.0.1:6379&gt; HINCRBY studentx name 1 # 非整数字型字段不可用</span><br><span class="line">(error) ERR hash value is not an integer</span><br><span class="line">127.0.0.1:6379&gt; HINCRBYFLOAT studentx weight 0.6 # weight字段增加0.6</span><br><span class="line">&quot;90.8&quot;</span><br></pre></td></tr></table></figure><p> Hash变更的数据user name age，尤其是用户信息之类的，经常变动的信息！Hash更适合于对象的存储，Sring更加适合字符串存储！</p><h2 id="Zset（有序集合）"><a href="#Zset（有序集合）" class="headerlink" title="Zset（有序集合）"></a>Zset（有序集合）</h2><p>不同的是每个元素都会关联一个double类型的分数（score）。redis正是通过分数来为集合中的成员进行从小到大的排序。</p><p>score相同：按字典顺序排序</p><p>有序集合的成员是唯一的,但分数(score)却可以重复。</p><ul><li><code>ZADD key score member1 [score2 member2]</code> 向有序集合添加一个或多个成员，或者更新已存在成员的分数</li><li><code>ZCARD key</code> 获取有序集合的成员数</li><li><code>ZCOUNT key min max</code> 计算在有序集合中指定区间score的成员数</li><li><code>ZINCRBY key n member</code> 有序集合中对指定成员的分数加上增量 n</li><li><code>ZSCORE key member</code> 返回有序集中，成员的分数值</li><li><code>ZRANK key member</code> 返回有序集合中指定成员的索引</li><li><code>ZRANGE key start end</code> 通过索引区间返回有序集合成指定区间内的成员</li><li><code>ZRANGEBYLEX key min max</code> 通过字典区间返回有序集合的成员</li><li><code>ZRANGEBYSCORE key min max</code> 通过分数返回有序集合指定区间内的成员==-inf 和 +inf分别表示最小最大值，只支持开区间()==</li><li><code>ZLEXCOUNT key min max</code> 在有序集合中计算指定字典区间内成员数量</li><li><code>ZREM key member1 [member2..]</code> 移除有序集合中一个/多个成员</li><li><code>ZREMRANGEBYLEX key min max</code> 移除有序集合中给定的字典区间的所有成员</li><li><code>ZREMRANGEBYRANK key start stop</code> 移除有序集合中给定的排名区间的所有成员</li><li><code>ZREMRANGEBYSCORE key min max</code> 移除有序集合中给定的分数区间的所有成员</li><li><code>ZREVRANGE key start end</code> 返回有序集中指定区间内的成员，通过索引，分数从高到底</li><li><code>ZREVRANGEBYSCORRE key max min</code> 返回有序集中指定分数区间内的成员，分数从高到低排序</li><li><code>ZREVRANGEBYLEX key max min</code> 返回有序集中指定字典区间内的成员，按字典顺序倒序</li><li><code>ZREVRANK key member</code> 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</li><li><code>ZINTERSTORE destination numkeys key1 [key2 ..]</code> 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中，numkeys：表示参与运算的集合数，将score相加作为结果的score</li><li><code>ZUNIONSTORE destination numkeys key1 [key2..]</code> 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中</li><li><code>ZSCAN key cursor [MATCH pattern\] [COUNT count]</code> 迭代有序集合中的元素（包括元素成员和元素分值）</li></ul><p>代码示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">-------------------ZADD--ZCARD--ZCOUNT--------------</span><br><span class="line">127.0.0.1:6379&gt; ZADD myzset 1 m1 2 m2 3 m3 # 向有序集合myzset中添加成员m1 score&#x3D;1 以及成员m2 score&#x3D;2..</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; ZCARD myzset # 获取有序集合的成员数</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; ZCOUNT myzset 0 1 # 获取score在 [0,1]区间的成员数量</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ZCOUNT myzset 0 2</span><br><span class="line">(integer) 2</span><br><span class="line">----------------ZINCRBY--ZSCORE--------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZINCRBY myzset 5 m2 # 将成员m2的score +5</span><br><span class="line">&quot;7&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZSCORE myzset m1 # 获取成员m1的score</span><br><span class="line">&quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZSCORE myzset m2</span><br><span class="line">&quot;7&quot;</span><br><span class="line">--------------ZRANK--ZRANGE-----------------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZRANK myzset m1 # 获取成员m1的索引，索引按照score排序，score相同索引值按字典顺序顺序增加</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; ZRANK myzset m2</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE myzset 0 1 # 获取索引在 0~1的成员</span><br><span class="line"></span><br><span class="line">&quot;m1&quot;</span><br><span class="line">&quot;m3&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE myzset 0 -1 # 获取全部成员</span><br><span class="line">&quot;m1&quot;</span><br><span class="line">&quot;m3&quot;</span><br><span class="line">&quot;m2&quot;</span><br><span class="line"></span><br><span class="line">testset&#x3D;&gt;&#123;abc,add,amaze,apple,back,java,redis&#125; score均为0</span><br><span class="line">------------------ZRANGEBYLEX---------------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYLEX testset - + # 返回所有成员</span><br><span class="line"></span><br><span class="line">&quot;abc&quot;</span><br><span class="line">&quot;add&quot;</span><br><span class="line">&quot;amaze&quot;</span><br><span class="line">&quot;apple&quot;</span><br><span class="line">&quot;back&quot;</span><br><span class="line">&quot;java&quot;</span><br><span class="line">&quot;redis&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYLEX testset - + LIMIT 0 3 # 分页 按索引显示查询结果的 0,1,2条记录</span><br><span class="line">&quot;abc&quot;</span><br><span class="line">&quot;add&quot;</span><br><span class="line">&quot;amaze&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYLEX testset - + LIMIT 3 3 # 显示 3,4,5条记录</span><br><span class="line">&quot;apple&quot;</span><br><span class="line">&quot;back&quot;</span><br><span class="line">&quot;java&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYLEX testset (- [apple # 显示 (-,apple] 区间内的成员</span><br><span class="line">&quot;abc&quot;</span><br><span class="line">&quot;add&quot;</span><br><span class="line">&quot;amaze&quot;</span><br><span class="line">&quot;apple&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYLEX testset [apple [java # 显示 [apple,java]字典区间的成员</span><br><span class="line">&quot;apple&quot;</span><br><span class="line">&quot;back&quot;</span><br><span class="line">&quot;java&quot;</span><br><span class="line"></span><br><span class="line">-----------------------ZRANGEBYSCORE---------------------</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE myzset 1 10 # 返回score在 [1,10]之间的的成员</span><br><span class="line"></span><br><span class="line">&quot;m1&quot;</span><br><span class="line">&quot;m3&quot;</span><br><span class="line">&quot;m2&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE myzset 1 5</span><br><span class="line">&quot;m1&quot;</span><br><span class="line">&quot;m3&quot;</span><br><span class="line"></span><br><span class="line">--------------------ZLEXCOUNT-----------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZLEXCOUNT testset - +</span><br><span class="line">(integer) 7</span><br><span class="line">127.0.0.1:6379&gt; ZLEXCOUNT testset [apple [java</span><br><span class="line">(integer) 3</span><br><span class="line">------------------ZREM--ZREMRANGEBYLEX--ZREMRANGBYRANK--ZREMRANGEBYSCORE--------------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZREM testset abc # 移除成员abc</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ZREMRANGEBYLEX testset [apple [java # 移除字典区间[apple,java]中的所有成员</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; ZREMRANGEBYRANK testset 0 1 # 移除排名0~1的所有成员</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; ZREMRANGEBYSCORE myzset 0 3 # 移除score在 [0,3]的成员</span><br><span class="line">(integer) 2</span><br><span class="line">testset&#x3D;&gt; &#123;abc,add,apple,amaze,back,java,redis&#125; score均为0</span><br><span class="line">myzset&#x3D;&gt; &#123;(m1,1),(m2,2),(m3,3),(m4,4),(m7,7),(m9,9)&#125;</span><br><span class="line">----------------ZREVRANGE--ZREVRANGEBYSCORE--ZREVRANGEBYLEX-----------</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGE myzset 0 3 # 按score递减排序，然后按索引，返回结果的 0~3</span><br><span class="line"></span><br><span class="line">&quot;m9&quot;</span><br><span class="line">&quot;m7&quot;</span><br><span class="line">&quot;m4&quot;</span><br><span class="line">&quot;m3&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGE myzset 2 4 # 返回排序结果的 索引的2~4</span><br><span class="line">&quot;m4&quot;</span><br><span class="line">&quot;m3&quot;</span><br><span class="line">&quot;m2&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGEBYSCORE myzset 6 2 # 按score递减顺序 返回集合中分数在[2,6]之间的成员</span><br><span class="line">&quot;m4&quot;</span><br><span class="line">&quot;m3&quot;</span><br><span class="line">&quot;m2&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGEBYLEX testset [java (add # 按字典倒序 返回集合中(add,java]字典区间的成员</span><br><span class="line">&quot;java&quot;</span><br><span class="line">&quot;back&quot;</span><br><span class="line">&quot;apple&quot;</span><br><span class="line">&quot;amaze&quot;</span><br><span class="line"></span><br><span class="line">-------------------------ZREVRANK------------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANK myzset m7 # 按score递减顺序，返回成员m7索引</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANK myzset m2</span><br><span class="line">(integer) 4</span><br><span class="line">mathscore&#x3D;&gt;&#123;(xm,90),(xh,95),(xg,87)&#125; 小明、小红、小刚的数学成绩</span><br><span class="line">enscore&#x3D;&gt;&#123;(xm,70),(xh,93),(xg,90)&#125; 小明、小红、小刚的英语成绩</span><br><span class="line">-------------------ZINTERSTORE--ZUNIONSTORE-----------------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZINTERSTORE sumscore 2 mathscore enscore # 将mathscore enscore进行合并 结果存放到sumscore</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE sumscore 0 -1 withscores # 合并后的score是之前集合中所有score的和</span><br><span class="line"></span><br><span class="line">&quot;xm&quot;</span><br><span class="line">&quot;160&quot;</span><br><span class="line">&quot;xg&quot;</span><br><span class="line">&quot;177&quot;</span><br><span class="line">&quot;xh&quot;</span><br><span class="line">&quot;188&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ZUNIONSTORE lowestscore 2 mathscore enscore AGGREGATE MIN # 取两个集合的成员score最小值作为结果的</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE lowestscore 0 -1 withscores</span><br><span class="line"></span><br><span class="line">&quot;xm&quot;</span><br><span class="line">&quot;70&quot;</span><br><span class="line">&quot;xg&quot;</span><br><span class="line">&quot;87&quot;</span><br><span class="line">&quot;xh&quot;</span><br><span class="line">&quot;93&quot;</span><br></pre></td></tr></table></figure><p>应用案例：</p><ol><li>set排序 存储班级成绩表 工资表排序！</li><li>普通消息，1.重要消息 2.带权重进行判断</li><li>排行榜应用实现，取Top N测试</li></ol><p>转载自：<a href="https://www.cnblogs.com/kylinxxx/p/13770063.html">https://www.cnblogs.com/kylinxxx/p/13770063.html</a></p><h2 id="四、三种特殊数据类型"><a href="#四、三种特殊数据类型" class="headerlink" title="四、三种特殊数据类型"></a>四、三种特殊数据类型</h2><h3 id="Geospatial-地理位置"><a href="#Geospatial-地理位置" class="headerlink" title="Geospatial(地理位置)"></a>Geospatial(地理位置)</h3><blockquote><p>使用经纬度定位地理坐标并用一个<strong>有序集合zset保存</strong>，所以zset命令也可以使用</p></blockquote><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>geoadd key longitud(经度) latitude(纬度) member [..]</code></td><td>将具体经纬度的坐标存入一个有序集合</td></tr><tr><td><code>geopos key member [member..]</code></td><td>获取集合中的一个/多个成员坐标</td></tr><tr><td><code>geodist key member1 member2 [unit]</code></td><td>返回两个给定位置之间的距离。默认以米作为单位。</td></tr><tr><td>`georadius key longitude latitude radius m</td><td>km</td></tr><tr><td><code>GEORADIUSBYMEMBER key member radius...</code></td><td>功能与GEORADIUS相同，只是中心位置不是具体的经纬度，而是使用结合中已有的成员作为中心点。</td></tr><tr><td><code>geohash key member1 [member2..]</code></td><td>返回一个或多个位置元素的Geohash表示。使用Geohash位置52点整数编码。</td></tr></tbody></table><p><strong>有效经纬度</strong></p><blockquote><ul><li>有效的经度从-180度到180度。</li><li>有效的纬度从-85.05112878度到85.05112878度。</li></ul></blockquote><p>指定单位的参数 <strong>unit</strong> 必须是以下单位的其中一个：</p><ul><li><strong>m</strong> 表示单位为米。</li><li><strong>km</strong> 表示单位为千米。</li><li><strong>mi</strong> 表示单位为英里。</li><li><strong>ft</strong> 表示单位为英尺。</li></ul><p><strong>关于GEORADIUS的参数</strong></p><blockquote><p>通过<code>georadius</code>就可以完成 <strong>附近的人</strong>功能</p><p>withcoord:带上坐标</p><p>withdist:带上距离，单位与半径单位相同</p><p>COUNT n : 只显示前n个(按距离递增排序)</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">----------------georadius---------------------</span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS china:city 120 30 500 km withcoord withdist <span class="comment"># 查询经纬度(120,30)坐标500km半径内的成员</span></span><br><span class="line">1) 1) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line">   2) <span class="string">&quot;29.4151&quot;</span></span><br><span class="line">   3) 1) <span class="string">&quot;120.20000249147415&quot;</span></span><br><span class="line">      2) <span class="string">&quot;30.199999888333501&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;shanghai&quot;</span></span><br><span class="line">   2) <span class="string">&quot;205.3611&quot;</span></span><br><span class="line">   3) 1) <span class="string">&quot;121.40000134706497&quot;</span></span><br><span class="line">      2) <span class="string">&quot;31.400000253193539&quot;</span></span><br><span class="line">     </span><br><span class="line">------------geohash---------------------------</span><br><span class="line">127.0.0.1:6379&gt; geohash china:city yichang shanghai <span class="comment"># 获取成员经纬坐标的geohash表示</span></span><br><span class="line">1) <span class="string">&quot;wmrjwbr5250&quot;</span></span><br><span class="line">2) <span class="string">&quot;wtw6ds0y300&quot;</span></span><br><span class="line">123456789101112131415</span><br></pre></td></tr></table></figure><h3 id="Hyperloglog-基数统计"><a href="#Hyperloglog-基数统计" class="headerlink" title="Hyperloglog(基数统计)"></a>Hyperloglog(基数统计)</h3><blockquote><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p><p>花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。</p><p>因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p><p>其底层使用string数据类型</p></blockquote><p><strong>什么是基数？</strong></p><blockquote><p>数据集中不重复的元素的个数。</p></blockquote><p><strong>应用场景：</strong></p><p>网页的访问量（UV）：一个用户多次访问，也只能算作一个人。</p><blockquote><p>传统实现，存储用户的id,然后每次进行比较。当用户变多之后这种方式及其浪费空间，而我们的目的只是<strong>计数</strong>，Hyperloglog就能帮助我们利用最小的空间完成。</p></blockquote><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>PFADD key element1 [elememt2..]</code></td><td>添加指定元素到 HyperLogLog 中</td></tr><tr><td><code>PFCOUNT key [key]</code></td><td>返回给定 HyperLogLog 的基数估算值。</td></tr><tr><td><code>PFMERGE destkey sourcekey [sourcekey..]</code></td><td>将多个 HyperLogLog 合并为一个 HyperLogLog</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">----------PFADD--PFCOUNT---------------------</span><br><span class="line">127.0.0.1:6379&gt; PFADD myelemx a b c d e f g h i j k <span class="comment"># 添加元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> myelemx <span class="comment"># hyperloglog底层使用String</span></span><br><span class="line">string</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT myelemx <span class="comment"># 估算myelemx的基数</span></span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br><span class="line">127.0.0.1:6379&gt; PFADD myelemy i j k z m c b v p q s</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT myelemy</span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br><span class="line"></span><br><span class="line">----------------PFMERGE-----------------------</span><br><span class="line">127.0.0.1:6379&gt; PFMERGE myelemz myelemx myelemy <span class="comment"># 合并myelemx和myelemy 成为myelemz</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT myelemz <span class="comment"># 估算基数</span></span><br><span class="line">(<span class="built_in">integer</span>) 17</span><br><span class="line">1234567891011121314151617</span><br></pre></td></tr></table></figure><p>如果允许容错，那么一定可以使用Hyperloglog !</p><p>如果不允许容错，就使用set或者自己的数据类型即可 ！</p><h3 id="BitMaps-位图"><a href="#BitMaps-位图" class="headerlink" title="BitMaps(位图)"></a>BitMaps(位图)</h3><blockquote><p>使用位存储，信息状态只有 0 和 1</p><p>Bitmap是一串连续的2进制数字（0或1），每一位所在的位置为偏移(offset)，在bitmap上可执行AND,OR,XOR,NOT以及其它位操作。</p></blockquote><p><strong>应用场景</strong></p><p>签到统计、状态统计</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>setbit key offset value</code></td><td>为指定key的offset位设置值</td></tr><tr><td><code>getbit key offset</code></td><td>获取offset位的值</td></tr><tr><td><code>bitcount key [start end]</code></td><td>统计字符串被设置为1的bit数，也可以指定统计范围按字节</td></tr><tr><td><code>bitop operration destkey key[key..]</code></td><td>对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。</td></tr><tr><td><code>BITPOS key bit [start] [end]</code></td><td>返回字符串里面第一个被设置为1或者0的bit位。start和end只能按字节,不能按位</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">------------setbit--getbit--------------</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 0 1 <span class="comment"># 设置sign的第0位为 1 </span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 2 1 <span class="comment"># 设置sign的第2位为 1  不设置默认 是0</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 3 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 5 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> sign</span><br><span class="line">string</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; getbit sign 2 <span class="comment"># 获取第2位的数值</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit sign 3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit sign 4 <span class="comment"># 未设置默认是0</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">-----------bitcount----------------------------</span><br><span class="line">127.0.0.1:6379&gt; BITCOUNT sign <span class="comment"># 统计sign中为1的位数</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">12345678910111213141516171819202122</span><br></pre></td></tr></table></figure><p><strong>bitmaps的底层</strong></p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-9PlszjhS-1597890996519)(D:\我\MyBlog\狂神说 Redis.assets\image-20200803234336175.png)]</p><p>这样设置以后你能get到的值是：<strong>\xA2\x80</strong>，所以bitmaps是一串从左到右的二进制串</p><h2 id="五、事务"><a href="#五、事务" class="headerlink" title="五、事务"></a>五、事务</h2><p>Redis的单条命令是保证原子性的，但是redis事务不能保证原子性</p><blockquote><p>Redis事务本质：一组命令的集合。</p><p>—————– 队列 set set set 执行 ——————-</p><p>事务中每条命令都会被序列化，执行过程中按顺序执行，不允许其他命令进行干扰。</p><ul><li>一次性</li><li>顺序性</li><li>排他性</li></ul><hr><ol><li>Redis事务没有隔离级别的概念</li><li>Redis单条命令是保证原子性的，但是事务不保证原子性！</li></ol></blockquote><h3 id="Redis事务操作过程"><a href="#Redis事务操作过程" class="headerlink" title="Redis事务操作过程"></a>Redis事务操作过程</h3><ul><li>开启事务（<code>multi</code>）</li><li>命令入队</li><li>执行事务（<code>exec</code>）</li></ul><p>所以事务中的命令在加入时都没有被执行，直到提交时才会开始执行(Exec)一次性完成。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi <span class="comment"># 开启事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1 <span class="comment"># 命令入队</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2 <span class="comment"># ..</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span> <span class="comment"># 事务执行</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) <span class="string">&quot;v1&quot;</span></span><br><span class="line">4) OK</span><br><span class="line">5) 1) <span class="string">&quot;k3&quot;</span></span><br><span class="line">   2) <span class="string">&quot;k2&quot;</span></span><br><span class="line">   3) <span class="string">&quot;k1&quot;</span></span><br><span class="line">1234567891011121314151617181920</span><br></pre></td></tr></table></figure><p><strong>取消事务(<code>discurd</code>)</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; DISCARD <span class="comment"># 放弃事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; EXEC </span><br><span class="line">(error) ERR EXEC without MULTI <span class="comment"># 当前未开启事务</span></span><br><span class="line">127.0.0.1:6379&gt; get k1 <span class="comment"># 被放弃事务中命令并未执行</span></span><br><span class="line">(nil)</span><br><span class="line">123456789101112</span><br></pre></td></tr></table></figure><h3 id="事务错误"><a href="#事务错误" class="headerlink" title="事务错误"></a>事务错误</h3><blockquote><p>代码语法错误（编译时异常）所有的命令都不执行</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; error k1 <span class="comment"># 这是一条语法错误命令</span></span><br><span class="line">(error) ERR unknown <span class="built_in">command</span> `error`, with args beginning with: `k1`, <span class="comment"># 会报错但是不影响后续命令入队 </span></span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; EXEC</span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors. <span class="comment"># 执行报错</span></span><br><span class="line">127.0.0.1:6379&gt; get k1 </span><br><span class="line">(nil) <span class="comment"># 其他命令并没有被执行</span></span><br><span class="line">1234567891011121314</span><br></pre></td></tr></table></figure><blockquote><p>代码逻辑错误 (运行时异常) **其他命令可以正常执行 ** &gt;&gt;&gt; 所以不保证事务原子性</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCR k1 <span class="comment"># 这条命令逻辑错误（对字符串进行增量）</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) (error) ERR value is not an <span class="built_in">integer</span> or out of range <span class="comment"># 运行时报错</span></span><br><span class="line">4) <span class="string">&quot;v2&quot;</span> <span class="comment"># 其他命令正常执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 虽然中间有一条命令报错了，但是后面的指令依旧正常执行成功了。</span></span><br><span class="line"><span class="comment"># 所以说Redis单条指令保证原子性，但是Redis事务不能保证原子性。</span></span><br><span class="line">123456789101112131415161718</span><br></pre></td></tr></table></figure><h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p><strong>悲观锁：</strong></p><ul><li>很悲观，认为什么时候都会出现问题，无论做什么都会加锁</li></ul><p><strong>乐观锁：</strong></p><ul><li>很乐观，认为什么时候都不会出现问题，所以不会上锁！更新数据的时候去判断一下，在此期间是否有人修改过这个数据</li><li>获取version</li><li>更新的时候比较version</li></ul><p>使用<code>watch key</code>监控指定数据，相当于乐观锁加锁。</p><blockquote><p>正常执行</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> money 100 <span class="comment"># 设置余额:100</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> use 0 <span class="comment"># 支出使用:0</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money <span class="comment"># 监视money (上锁)</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; DECRBY money 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCRBY use 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span> <span class="comment"># 监视值没有被中途修改，事务正常执行</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 80</span><br><span class="line">2) (<span class="built_in">integer</span>) 20</span><br><span class="line">123456789101112131415</span><br></pre></td></tr></table></figure><blockquote><p>测试多线程修改值，使用watch可以当做redis的乐观锁操作（相当于getversion）</p></blockquote><p>我们启动另外一个客户端模拟插队线程。</p><p>线程1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; watch money <span class="comment"># money上锁</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; DECRBY money 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCRBY use 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="comment"># 此时事务并没有执行</span></span><br><span class="line">123456789</span><br></pre></td></tr></table></figure><p>模拟线程插队，线程2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; INCRBY money 500 <span class="comment"># 修改了线程一中监视的money</span></span><br><span class="line">(<span class="built_in">integer</span>) 600</span><br><span class="line">12</span><br></pre></td></tr></table></figure><p>回到线程1，执行事务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; EXEC <span class="comment"># 执行之前，另一个线程修改了我们的值，这个时候就会导致事务执行失败</span></span><br><span class="line">(nil) <span class="comment"># 没有结果，说明事务执行失败</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; get money <span class="comment"># 线程2 修改生效</span></span><br><span class="line"><span class="string">&quot;600&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get use <span class="comment"># 线程1事务执行失败，数值没有被修改</span></span><br><span class="line"><span class="string">&quot;0&quot;</span></span><br><span class="line">1234567</span><br></pre></td></tr></table></figure><blockquote><p>解锁获取最新值，然后再加锁进行事务。</p><p><code>unwatch</code>进行解锁。</p></blockquote><p>注意：每次提交执行exec后都会自动释放锁，不管是否成功</p><h2 id="六、Jedis"><a href="#六、Jedis" class="headerlink" title="六、Jedis"></a>六、Jedis</h2><p>使用Java来操作Redis，Jedis是Redis官方推荐使用的Java连接redis的客户端。</p><ol><li><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入jredis的包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--fastjson--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.70<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">123456789101112</span><br></pre></td></tr></table></figure></li><li><p>编码测试</p><ul><li><p>连接数据库</p><ol><li><p>修改redis的配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/<span class="built_in">local</span>/bin/myconfig/redis.conf</span><br><span class="line">1</span><br></pre></td></tr></table></figure><ol><li><p>将只绑定本地注释</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-4IRUFJ95-1597890996520)(狂神说 Redis.assets/image-20200813161921480.png)]</p></li><li><p>保护模式改为 no</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-oKjIVapw-1597890996521)(狂神说 Redis.assets/image-20200813161939847.png)]</p></li><li><p>允许后台运行</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-c2IMvpZL-1597890996522)(狂神说 Redis.assets/image-20200813161954567.png)]</p></li></ol></li></ol></li></ul></li><li><p>开放端口6379</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=6379/tcp --permanet</span><br><span class="line"></span><br><span class="line">12</span><br></pre></td></tr></table></figure><p>重启防火墙服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart firewalld.service</span><br><span class="line"></span><br><span class="line">12</span><br></pre></td></tr></table></figure><ol><li><p>阿里云服务器控制台配置安全组</p></li><li><p>重启redis-server</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@AlibabaECS bin]<span class="comment"># redis-server myconfig/redis.conf </span></span><br><span class="line"></span><br><span class="line">12</span><br></pre></td></tr></table></figure></li></ol></li></ol><ul><li><p>操作命令</p><p><strong>TestPing.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.xx.xxx&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        String response = jedis.ping();</span><br><span class="line">        System.out.println(response); <span class="comment">// PONG</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure></li><li><p>断开连接</p></li></ul><ol><li><p><strong>事务</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTX</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;39.99.xxx.xx&quot;</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">        JSONObject jsonObject = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        jsonObject.put(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">        jsonObject.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;kuangshen&quot;</span>);</span><br><span class="line">        <span class="comment">// 开启事务</span></span><br><span class="line">        Transaction multi = jedis.multi();</span><br><span class="line">        String result = jsonObject.toJSONString();</span><br><span class="line">        <span class="comment">// jedis.watch(result)</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            multi.set(<span class="string">&quot;user1&quot;</span>, result);</span><br><span class="line">            multi.set(<span class="string">&quot;user2&quot;</span>, result);</span><br><span class="line">            <span class="comment">// 执行事务</span></span><br><span class="line">            multi.exec();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="comment">// 放弃事务</span></span><br><span class="line">            multi.discard();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭连接</span></span><br><span class="line">            System.out.println(jedis.get(<span class="string">&quot;user1&quot;</span>));</span><br><span class="line">            System.out.println(jedis.get(<span class="string">&quot;user2&quot;</span>));</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="七、SpringBoot整合"><a href="#七、SpringBoot整合" class="headerlink" title="七、SpringBoot整合"></a>七、SpringBoot整合</h2><ol><li>导入依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">1234</span><br></pre></td></tr></table></figure><p>springboot 2.x后 ，原来使用的 Jedis 被 lettuce 替换。</p><blockquote><p>jedis：采用的直连，多个线程操作的话，是不安全的。如果要避免不安全，使用jedis pool连接池！更像BIO模式</p><p>lettuce：采用netty，实例可以在多个线程中共享，不存在线程不安全的情况！可以减少线程数据了，更像NIO模式</p></blockquote><p>我们在学习SpringBoot自动配置的原理时，整合一个组件并进行配置一定会有一个自动配置类xxxAutoConfiguration,并且在spring.factories中也一定能找到这个类的完全限定名。Redis也不例外。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513214531573.png" alt="在这里插入图片描述"></p><p>那么就一定还存在一个RedisProperties类</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513214554661.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>之前我们说SpringBoot2.x后默认使用Lettuce来替换Jedis，现在我们就能来验证了。</p><p>先看Jedis:</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513214607475.png" alt="在这里插入图片描述"></p><p>@ConditionalOnClass注解中有两个类是默认不存在的，所以Jedis是无法生效的</p><p>然后再看Lettuce：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513214618179.png" alt="在这里插入图片描述"></p><p>完美生效。</p><p>现在我们回到RedisAutoConfiguratio</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020051321462777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="img"></p><p>只有两个简单的Bean</p><ul><li><strong>RedisTemplate</strong></li><li><strong>StringRedisTemplate</strong></li></ul><p>当看到xxTemplate时可以对比RestTemplat、SqlSessionTemplate,通过使用这些Template来间接操作组件。那么这俩也不会例外。分别用于操作Redis和Redis中的String数据类型。</p><p>在RedisTemplate上也有一个条件注解，说明我们是可以对其进行定制化的</p><p>说完这些，我们需要知道如何编写配置文件然后连接Redis，就需要阅读RedisProperties</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513214638238.png" alt="在这里插入图片描述"></p><p>这是一些基本的配置属性。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513214649380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>还有一些连接池相关的配置。注意使用时一定使用Lettuce的连接池。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513214700372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol><li><p>编写配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置redis</span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">39.99.xxx.xx</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="attr">123</span></span><br><span class="line"><span class="attr">1234</span></span><br></pre></td></tr></table></figure></li><li><p>使用RedisTemplate</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Redis02SpringbootApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// redisTemplate 操作不同的数据类型，api和我们的指令是一样的</span></span><br><span class="line">        <span class="comment">// opsForValue 操作字符串 类似String</span></span><br><span class="line">        <span class="comment">// opsForList 操作List 类似List</span></span><br><span class="line">        <span class="comment">// opsForHah</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 除了基本的操作，我们常用的方法都可以直接通过redisTemplate操作，比如事务和基本的CRUD</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取连接对象</span></span><br><span class="line">        <span class="comment">//RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();</span></span><br><span class="line">        <span class="comment">//connection.flushDb();</span></span><br><span class="line">        <span class="comment">//connection.flushAll();</span></span><br><span class="line"></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;mykey&quot;</span>,<span class="string">&quot;kuangshen&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;mykey&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425</span></span><br></pre></td></tr></table></figure></li><li><p>测试结果</p><p><strong>此时我们回到Redis查看数据时候，惊奇发现全是乱码，可是程序中可以正常输出：</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513214734520.png" alt="在这里插入图片描述"></p><p> 这时候就关系到存储对象的序列化问题，在网络中传输的对象也是一样需要序列化，否者就全是乱码。</p><p>我们转到看那个默认的RedisTemplate内部什么样子：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513214746506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>在最开始就能看到几个关于序列化的参数。</p><p>默认的序列化器是采用JDK序列化器</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513214757247.png" alt="在这里插入图片描述"></p><p>而默认的RedisTemplate中的所有序列化器都是使用这个序列化器：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513214809494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>后续我们定制RedisTemplate就可以对其进行修改。</p><p><code>RedisSerializer</code>提供了多种序列化方案：</p><ul><li><p>直接调用RedisSerializer的静态方法来返回序列化器，然后set</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513214818682.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>自己new 相应的实现类，然后set</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513214827233.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul></li><li><p><strong>定制RedisTemplate的模板：</strong></p><p>我们创建一个Bean加入容器，就会触发RedisTemplate上的条件注解使默认的RedisTemplate失效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">        <span class="comment">// 将template 泛型设置为 &lt;String, Object&gt;</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate();</span><br><span class="line">        <span class="comment">// 连接工厂，不必修改</span></span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 序列化设置</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// key、hash的key 采用 String序列化方式</span></span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// value、hash的value 采用 Jackson 序列化方式</span></span><br><span class="line">        template.setValueSerializer(RedisSerializer.json());</span><br><span class="line">        template.setHashValueSerializer(RedisSerializer.json());</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223</span></span><br></pre></td></tr></table></figure><p>这样一来，只要实体类进行了序列化，我们存什么都不会有乱码的担忧了。</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-oc8kJP08-1597890996523)(狂神说 Redis.assets/image-20200817175638086.png)]</p></li></ol><h2 id="八、自定义Redis工具类"><a href="#八、自定义Redis工具类" class="headerlink" title="八、自定义Redis工具类"></a>八、自定义Redis工具类</h2><p>使用RedisTemplate需要频繁调用<code>.opForxxx</code>然后才能进行对应的操作，这样使用起来代码效率低下，工作中一般不会这样使用，而是将这些常用的公共API抽取出来封装成为一个工具类，然后直接使用工具类来间接操作Redis,不但效率高并且易用。</p><p>工具类参考博客：</p><p><a href="https://www.cnblogs.com/zeng1994/p/03303c805731afc9aa9c60dbbd32a323.html">https://www.cnblogs.com/zeng1994/p/03303c805731afc9aa9c60dbbd32a323.html</a></p><p><a href="https://www.cnblogs.com/zhzhlong/p/11434284.html">https://www.cnblogs.com/zhzhlong/p/11434284.html</a></p><h2 id="九、Redis-conf"><a href="#九、Redis-conf" class="headerlink" title="九、Redis.conf"></a>九、Redis.conf</h2><blockquote><p>容量单位不区分大小写，G和GB有区别</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020051321485460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="img"></p><blockquote><p>可以使用 include 组合多个配置问题</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513214902552.png" alt="在这里插入图片描述"></p><blockquote><p>网络配置</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513214912813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>日志输出级别</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513214923678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="img"></p><blockquote><p>日志输出文件</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513214933713.png" alt="在这里插入图片描述"></p><blockquote><p>持久化规则</p></blockquote><p>由于Redis是基于内存的数据库，需要将数据由内存持久化到文件中</p><p>持久化方式：</p><ul><li>RDB</li><li>AOF</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513214944964.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>RDB文件相关</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513214955679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513215006207.png" alt="在这里插入图片描述"></p><blockquote><p>主从复制</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513215016371.png" alt="在这里插入图片描述"></p><blockquote><p>Security模块中进行密码设置</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513215026143.png" alt="在这里插入图片描述"></p><blockquote><p>客户端连接相关</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">maxclients 10000  最大客户端数量</span><br><span class="line">maxmemory &lt;bytes&gt; 最大内存限制</span><br><span class="line">maxmemory-policy noeviction <span class="comment"># 内存达到限制值的处理策略</span></span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>redis 中的<strong>默认</strong>的过期策略是 <strong>volatile-lru</strong> 。</p><p><strong>设置方式</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">config <span class="built_in">set</span> maxmemory-policy volatile-lru </span><br><span class="line">1</span><br></pre></td></tr></table></figure><h4 id="maxmemory-policy-六种方式"><a href="#maxmemory-policy-六种方式" class="headerlink" title="maxmemory-policy 六种方式"></a><strong>maxmemory-policy 六种方式</strong></h4><p><strong>1、volatile-lru：</strong>只对设置了过期时间的key进行LRU（默认值）</p><p><strong>2、allkeys-lru ：</strong> 删除lru算法的key</p><p><strong>3、volatile-random：</strong>随机删除即将过期key</p><p><strong>4、allkeys-random：</strong>随机删除</p><p><strong>5、volatile-ttl ：</strong> 删除即将过期的</p><p><strong>6、noeviction ：</strong> 永不过期，返回错误</p><blockquote><p>AOF相关部分</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513215037918.png" alt="在这里插入图片描述"></p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513215047999.png" alt="在这里插入图片描述"></p><h2 id="十、持久化—RDB"><a href="#十、持久化—RDB" class="headerlink" title="十、持久化—RDB"></a>十、持久化—RDB</h2><p>RDB：Redis Databases</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-C0mm1D4A-1597890996524)(狂神说 Redis.assets/image-20200818122236614.png)]</p><h3 id="什么是RDB"><a href="#什么是RDB" class="headerlink" title="什么是RDB"></a>什么是RDB</h3><hr><p>在指定时间间隔后，将内存中的数据集快照写入数据库 ；在恢复时候，直接读取快照文件，进行数据的恢复 ；</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513215126515.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>默认情况下， Redis 将数据库快照保存在名字为 dump.rdb的二进制文件中。文件名可以在配置文件中进行自定义。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><hr><p>在进行 <strong><code>RDB</code></strong> 的时候，**<code>redis</code>** 的主线程是不会做 <strong><code>io</code></strong> 操作的，主线程会 <strong><code>fork</code></strong> 一个子线程来完成该操作；</p><ol><li>Redis 调用forks。同时拥有父进程和子进程。</li><li>子进程将数据集写入到一个临时 RDB 文件中。</li><li>当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。</li></ol><p>这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益(因为是使用子进程进行写操作，而父进程依然可以接收来自客户端的请求。)</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513215141519.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h3><hr><ol><li>save的规则满足的情况下，会自动触发rdb原则</li><li>执行flushall命令，也会触发我们的rdb原则</li><li>退出redis，也会自动产生rdb文件</li></ol><h4 id="save"><a href="#save" class="headerlink" title="save"></a>save</h4><p>使用 <code>save</code> 命令，会立刻对当前内存中的数据进行持久化 ,但是会阻塞，也就是不接受其他操作了；</p><blockquote><p>由于 <code>save</code> 命令是同步命令，会占用Redis的主进程。若Redis数据非常多时，<code>save</code>命令执行速度会非常慢，阻塞所有客户端的请求。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513215150892.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="flushall命令"><a href="#flushall命令" class="headerlink" title="flushall命令"></a>flushall命令</h4><p><code>flushall</code> 命令也会触发持久化 ；</p><h4 id="触发持久化规则"><a href="#触发持久化规则" class="headerlink" title="触发持久化规则"></a>触发持久化规则</h4><p>满足配置条件中的触发条件 ；</p><blockquote><p>可以通过配置文件对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动进行数据集保存操作。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513215205970.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513215220858.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="bgsave"><a href="#bgsave" class="headerlink" title="bgsave"></a>bgsave</h4><p><code>bgsave</code> 是异步进行，进行持久化的时候，<code>redis</code> 还可以将继续响应客户端请求 ；</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020051321523151.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>bgsave和save对比</strong></p><table><thead><tr><th>命令</th><th>save</th><th>bgsave</th></tr></thead><tbody><tr><td>IO类型</td><td>同步</td><td>异步</td></tr><tr><td>阻塞？</td><td>是</td><td>是（阻塞发生在fock()，通常非常快）</td></tr><tr><td>复杂度</td><td>O(n)</td><td>O(n)</td></tr><tr><td>优点</td><td>不会消耗额外的内存</td><td>不阻塞客户端命令</td></tr><tr><td>缺点</td><td>阻塞客户端命令</td><td>需要fock子进程，消耗内存</td></tr></tbody></table><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点：</strong></p><ol><li>适合大规模的数据恢复</li><li>对数据的完整性要求不高</li></ol><p><strong>缺点：</strong></p><ol><li>需要一定的时间间隔进行操作，如果redis意外宕机了，这个最后一次修改的数据就没有了。</li><li>fork进程的时候，会占用一定的内容空间。</li></ol><h2 id="十一、持久化AOF"><a href="#十一、持久化AOF" class="headerlink" title="十一、持久化AOF"></a>十一、持久化AOF</h2><p><strong>Append Only File</strong></p><p>将我们所有的命令都记录下来，history，恢复的时候就把这个文件全部再执行一遍</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Z8wr9lBW-1597890996525)(狂神说 Redis.assets/image-20200818123711375.png)]</p><blockquote><p>以日志的形式来记录每个写的操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p></blockquote><h3 id="什么是AOF"><a href="#什么是AOF" class="headerlink" title="什么是AOF"></a>什么是AOF</h3><p> 快照功能（RDB）并不是非常耐久（durable）： 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、以及未保存到快照中的那些数据。 从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化。</p><p>如果要使用AOF，需要修改配置文件：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513215247113.png" alt="在这里插入图片描述"></p><p><code>appendonly no yes</code>则表示启用AOF</p><p>默认是不开启的，我们需要手动配置，然后重启redis，就可以生效了！</p><p>如果这个aof文件有错位，这时候redis是启动不起来的，我需要修改这个aof文件</p><p>redis给我们提供了一个工具<code>redis-check-aof --fix</code></p><blockquote><p>优点和缺点</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes  <span class="comment"># 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分的情况下，rdb完全够用</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># appendfsync always # 每次修改都会sync 消耗性能</span></span><br><span class="line">appendfsync everysec <span class="comment"># 每秒执行一次 sync 可能会丢失这一秒的数据</span></span><br><span class="line"><span class="comment"># appendfsync no # 不执行 sync ,这时候操作系统自己同步数据，速度最快</span></span><br><span class="line">123456</span><br></pre></td></tr></table></figure><p><strong>优点</strong></p><ol><li>每一次修改都会同步，文件的完整性会更加好</li><li>没秒同步一次，可能会丢失一秒的数据</li><li>从不同步，效率最高</li></ol><p><strong>缺点</strong></p><ol><li>相对于数据文件来说，aof远远大于rdb，修复速度比rdb慢！</li><li>Aof运行效率也要比rdb慢，所以我们redis默认的配置就是rdb持久化</li></ol><h2 id="十二、RDB和AOP选择"><a href="#十二、RDB和AOP选择" class="headerlink" title="十二、RDB和AOP选择"></a>十二、RDB和AOP选择</h2><h3 id="RDB-和-AOF-对比"><a href="#RDB-和-AOF-对比" class="headerlink" title="RDB 和 AOF 对比"></a>RDB 和 AOF 对比</h3><table><thead><tr><th>RDB</th><th>AOF</th><th></th></tr></thead><tbody><tr><td>启动优先级</td><td>低</td><td>高</td></tr><tr><td>体积</td><td>小</td><td>大</td></tr><tr><td>恢复速度</td><td>快</td><td>慢</td></tr><tr><td>数据安全性</td><td>丢数据</td><td>根据策略决定</td></tr></tbody></table><h3 id="如何选择使用哪种持久化方式？"><a href="#如何选择使用哪种持久化方式？" class="headerlink" title="如何选择使用哪种持久化方式？"></a>如何选择使用哪种持久化方式？</h3><p>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。</p><p>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。</p><p>有很多用户都只使用 AOF 持久化， 但并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快。</p><h2 id="十三、Redis发布与订阅"><a href="#十三、Redis发布与订阅" class="headerlink" title="十三、Redis发布与订阅"></a>十三、Redis发布与订阅</h2><p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-IBT2pjCa-1597890996526)(狂神说 Redis.assets/image-20200818162849693.png)]</p><p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513215523258.png" alt="在这里插入图片描述"></p><p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020051321553483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>PSUBSCRIBE pattern [pattern..]</code></td><td>订阅一个或多个符合给定模式的频道。</td></tr><tr><td><code>PUNSUBSCRIBE pattern [pattern..]</code></td><td>退订一个或多个符合给定模式的频道。</td></tr><tr><td><code>PUBSUB subcommand [argument[argument]]</code></td><td>查看订阅与发布系统状态。</td></tr><tr><td><code>PUBLISH channel message</code></td><td>向指定频道发布消息</td></tr><tr><td><code>SUBSCRIBE channel [channel..]</code></td><td>订阅给定的一个或多个频道。</td></tr><tr><td><code>SUBSCRIBE channel [channel..]</code></td><td>退订一个或多个频道</td></tr></tbody></table><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">------------订阅端----------------------</span><br><span class="line">127.0.0.1:6379&gt; SUBSCRIBE sakura <span class="comment"># 订阅sakura频道</span></span><br><span class="line">Reading messages... (press Ctrl-C to quit) <span class="comment"># 等待接收消息</span></span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span> <span class="comment"># 订阅成功的消息</span></span><br><span class="line">2) <span class="string">&quot;sakura&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line">1) <span class="string">&quot;message&quot;</span> <span class="comment"># 接收到来自sakura频道的消息 &quot;hello world&quot;</span></span><br><span class="line">2) <span class="string">&quot;sakura&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello world&quot;</span></span><br><span class="line">1) <span class="string">&quot;message&quot;</span> <span class="comment"># 接收到来自sakura频道的消息 &quot;hello i am sakura&quot;</span></span><br><span class="line">2) <span class="string">&quot;sakura&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello i am sakura&quot;</span></span><br><span class="line"></span><br><span class="line">--------------消息发布端-------------------</span><br><span class="line">127.0.0.1:6379&gt; PUBLISH sakura <span class="string">&quot;hello world&quot;</span> <span class="comment"># 发布消息到sakura频道</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; PUBLISH sakura <span class="string">&quot;hello i am sakura&quot;</span> <span class="comment"># 发布消息</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">-----------------查看活跃的频道------------</span><br><span class="line">127.0.0.1:6379&gt; PUBSUB channels</span><br><span class="line">1) <span class="string">&quot;sakura&quot;</span></span><br><span class="line">12345678910111213141516171819202122</span><br></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>每个 Redis 服务器进程都维持着一个表示服务器状态的 redis.h/redisServer 结构， 结构的 pubsub_channels 属性是一个字典， 这个字典就用于保存订阅频道的信息，其中，字典的键为正在被订阅的频道， 而字典的值则是一个链表， 链表中保存了所有订阅这个频道的客户端。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020051321554964.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>客户端订阅，就被链接到对应频道的链表的尾部，退订则就是将客户端节点从链表中移除。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>如果一个客户端订阅了频道，但自己读取消息的速度却不够快的话，那么不断积压的消息会使redis输出缓冲区的体积变得越来越大，这可能使得redis本身的速度变慢，甚至直接崩溃。</li><li>这和数据传输可靠性有关，如果在订阅方断线，那么他将会丢失所有在短线期间发布者发布的消息。</li></ol><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ol><li>消息订阅：公众号订阅，微博关注等等（起始更多是使用消息队列来进行实现）</li><li>多人在线聊天室。</li></ol><p>稍微复杂的场景，我们就会使用消息中间件MQ处理。</p><h2 id="十四、Redis主从复制"><a href="#十四、Redis主从复制" class="headerlink" title="十四、Redis主从复制"></a>十四、Redis主从复制</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p> 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点（Master/Leader）,后者称为从节点（Slave/Follower）， 数据的复制是单向的！只能由主节点复制到从节点（主节点以写为主、从节点以读为主）。</p><p>默认情况下，每台Redis服务器都是主节点，一个主节点可以有0个或者多个从节点，但每个从节点只能由一个主节点。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余的方式。</li><li>故障恢复：当主节点故障时，从节点可以暂时替代主节点提供服务，是一种服务冗余的方式</li><li>负载均衡：在主从复制的基础上，配合读写分离，由主节点进行写操作，从节点进行读操作，分担服务器的负载；尤其是在多读少写的场景下，通过多个从节点分担负载，提高并发量。</li><li>高可用基石：主从复制还是哨兵和集群能够实施的基础。</li></ol><h3 id="为什么使用集群"><a href="#为什么使用集群" class="headerlink" title="为什么使用集群"></a>为什么使用集群</h3><ol><li>单台服务器难以负载大量的请求</li><li>单台服务器故障率高，系统崩坏概率大</li><li>单台服务器内存容量有限。</li></ol><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>我们在讲解配置文件的时候，注意到有一个<code>replication</code>模块 (见Redis.conf中第8条)</p><p>查看当前库的信息：<code>info replication</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master <span class="comment"># 角色</span></span><br><span class="line">connected_slaves:0 <span class="comment"># 从机数量</span></span><br><span class="line">master_replid:3b54deef5b7b7b7f7dd8acefa23be48879b4fcff</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br><span class="line">123456789101112</span><br></pre></td></tr></table></figure><p>既然需要启动多个服务，就需要多个配置文件。每个配置文件对应修改以下信息：</p><ul><li>端口号</li><li>pid文件名</li><li>日志文件名</li><li>rdb文件名</li></ul><p>启动单机多服务集群：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513215610163.png" alt="在这里插入图片描述"></p><h3 id="一主二从配置"><a href="#一主二从配置" class="headerlink" title="一主二从配置"></a>一主二从配置</h3><p>==默认情况下，每台Redis服务器都是主节点；==我们一般情况下只用配置从机就好了！</p><p>认老大！一主（79）二从（80，81）</p><p>使用<code>SLAVEOF host port</code>就可以为从机配置主机了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513215637483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>然后主机上也能看到从机的状态：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513215645778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>我们这里是使用命令搭建，是暂时的，==真实开发中应该在从机的配置文件中进行配置，==这样的话是永久的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513215654634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h3><ol><li><p>从机只能读，不能写，主机可读可写但是多用于写。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> 127.0.0.1:6381&gt; <span class="built_in">set</span> name sakura <span class="comment"># 从机6381写入失败</span></span><br><span class="line">(error) READONLY You can<span class="string">&#x27;t write against a read only replica.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">127.0.0.1:6380&gt; set name sakura # 从机6380写入失败</span></span><br><span class="line"><span class="string">(error) READONLY You can&#x27;</span>t write against a <span class="built_in">read</span> only replica.</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name sakura</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">&quot;sakura&quot;</span></span><br><span class="line">12345678910</span><br></pre></td></tr></table></figure></li><li><p>当主机断电宕机后，默认情况下从机的角色不会发生变化 ，集群中只是失去了写操作，当主机恢复以后，又会连接上从机恢复原状。</p></li><li><p>当从机断电宕机后，若不是使用配置文件配置的从机，再次启动后作为主机是无法获取之前主机的数据的，若此时重新配置称为从机，又可以获取到主机的所有数据。这里就要提到一个同步原理。</p></li><li><p>第二条中提到，默认情况下，主机故障后，不会出现新的主机，有两种方式可以产生新的主机：</p><ul><li>从机手动执行命令<code>slaveof no one</code>,这样执行以后从机会独立出来成为一个主机</li><li>使用哨兵模式（自动选举）</li></ul></li></ol><blockquote><p>如果没有老大了，这个时候能不能选择出来一个老大呢？手动！</p></blockquote><p>如果主机断开了连接，我们可以使用<code>SLAVEOF no one</code>让自己变成主机！其他的节点就可以手动连接到最新的主节点（手动）！如果这个时候老大修复了，那么久重新连接！</p><h2 id="十五、哨兵模式"><a href="#十五、哨兵模式" class="headerlink" title="十五、哨兵模式"></a>十五、哨兵模式</h2><p>更多信息参考博客：<a href="https://www.jianshu.com/p/06ab9daf921d">https://www.jianshu.com/p/06ab9daf921d</a></p><p><strong>主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。\</strong>这不是一种推荐的方式，更多时候，我们优先考虑**哨兵模式**。</p><p>单机单个哨兵</p><p><img src= "/img/loading.gif" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMTMyMDAzOS01N2E3N2NhMjc1N2QwOTI0LnBuZw?x-oss-process=image/format,png" alt="img"></p><p>哨兵的作用：</p><ul><li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。</li><li>当哨兵监测到master宕机，会自动将slave切换成master，然后通过<strong>发布订阅模式</strong>通知其他的从服务器，修改配置文件，让它们切换主机。</li></ul><p>多哨兵模式</p><p><img src= "/img/loading.gif" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMTMyMDAzOS0zZjQwYjE3YzA0MTIxMTZjLnBuZw?x-oss-process=image/format,png" alt="img"></p><p>哨兵的核心配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster 127.0.0.1 6379</span><br><span class="line">1</span><br></pre></td></tr></table></figure><ul><li>数字1表示 ：当一个哨兵主观认为主机断开，就可以客观认为主机故障，然后开始选举新的主机。</li></ul><blockquote><p>测试</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel xxx&#x2F;sentinel.conf</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>成功启动哨兵模式</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513215752444.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>此时哨兵监视着我们的主机6379，当我们断开主机后：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513215806972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>哨兵模式优缺点</p></blockquote><p><strong>优点：</strong></p><ol><li>哨兵集群，基于主从复制模式，所有主从复制的优点，它都有</li><li>主从可以切换，故障可以转移，系统的可用性更好</li><li>哨兵模式是主从模式的升级，手动到自动，更加健壮</li></ol><p><strong>缺点：</strong></p><ol><li>Redis不好在线扩容，集群容量一旦达到上限，在线扩容就十分麻烦</li><li>实现哨兵模式的配置其实是很麻烦的，里面有很多配置项</li></ol><blockquote><p>哨兵模式的全部配置</p></blockquote><p>完整的哨兵模式配置文件 sentinel.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example sentinel.conf</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 哨兵sentinel实例运行的端口 默认26379</span></span><br><span class="line">port 26379</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 哨兵sentinel的工作目录</span></span><br><span class="line">dir /tmp</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 哨兵sentinel监控的redis主节点的 ip port </span></span><br><span class="line"><span class="comment"># master-name  可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。</span></span><br><span class="line"><span class="comment"># quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了</span></span><br><span class="line"><span class="comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 1</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</span></span><br><span class="line"><span class="comment"># 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span></span><br><span class="line"><span class="comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br><span class="line">sentinel auth-pass mymaster MySUPER--secret-0123passw0rd</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span></span><br><span class="line"><span class="comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，</span></span><br><span class="line">这个数字越小，完成failover所需的时间就越长，</span><br><span class="line">但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。</span><br><span class="line">可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span><br><span class="line"><span class="comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 故障转移的超时时间 failover-timeout 可以用在以下这些方面： </span></span><br><span class="line"><span class="comment">#1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span></span><br><span class="line"><span class="comment">#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</span></span><br><span class="line"><span class="comment">#3.当想要取消一个正在进行的failover所需要的时间。  </span></span><br><span class="line"><span class="comment">#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span></span><br><span class="line"><span class="comment"># 默认三分钟</span></span><br><span class="line"><span class="comment"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"> </span><br><span class="line"><span class="comment"># SCRIPTS EXECUTION</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。</span></span><br><span class="line"><span class="comment">#对于脚本的运行结果有以下规则：</span></span><br><span class="line"><span class="comment">#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span></span><br><span class="line"><span class="comment">#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span></span><br><span class="line"><span class="comment">#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span></span><br><span class="line"><span class="comment">#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，</span></span><br><span class="line"><span class="comment">#这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，</span></span><br><span class="line"><span class="comment">#一个是事件的类型，</span></span><br><span class="line"><span class="comment">#一个是事件的描述。</span></span><br><span class="line"><span class="comment">#如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span></span><br><span class="line"><span class="comment">#通知脚本</span></span><br><span class="line"><span class="comment"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">  sentinel notification-script mymaster /var/redis/notify.sh</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 客户端重新配置主节点参数脚本</span></span><br><span class="line"><span class="comment"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span></span><br><span class="line"><span class="comment"># 以下参数将会在调用脚本时传给脚本:</span></span><br><span class="line"><span class="comment"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span></span><br><span class="line"><span class="comment"># 目前&lt;state&gt;总是“failover”,</span></span><br><span class="line"><span class="comment"># &lt;role&gt;是“leader”或者“observer”中的一个。 </span></span><br><span class="line"><span class="comment"># 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的</span></span><br><span class="line"><span class="comment"># 这个脚本应该是通用的，能被多次调用，不是针对性的。</span></span><br><span class="line"><span class="comment"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</span><br><span class="line"></span><br><span class="line">1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071</span><br></pre></td></tr></table></figure><h2 id="十六、缓存穿透与雪崩"><a href="#十六、缓存穿透与雪崩" class="headerlink" title="十六、缓存穿透与雪崩"></a>十六、缓存穿透与雪崩</h2><h3 id="缓存穿透（查不到）"><a href="#缓存穿透（查不到）" class="headerlink" title="缓存穿透（查不到）"></a>缓存穿透（查不到）</h3><blockquote><p>概念</p></blockquote><p>在默认情况下，用户请求数据时，会先在缓存(Redis)中查找，若没找到即缓存未命中，再在数据库中进行查找，数量少可能问题不大，可是一旦大量的请求数据（例如秒杀场景）缓存都没有命中的话，就会全部转移到数据库上，造成数据库极大的压力，就有可能导致数据库崩溃。网络安全中也有人恶意使用这种手段进行攻击被称为洪水攻击。</p><blockquote><p>解决方案</p></blockquote><p><strong>布隆过滤器</strong></p><p>对所有可能查询的参数以Hash的形式存储，以便快速确定是否存在这个值，在控制层先进行拦截校验，校验不通过直接打回，减轻了存储系统的压力。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513215824722.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>缓存空对象</strong></p><p>一次请求若在缓存和数据库中都没找到，就在缓存中方一个空对象用于处理后续这个请求。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513215836317.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p> 这样做有一个缺陷：存储空对象也需要空间，大量的空对象会耗费一定的空间，存储效率并不高。解决这个缺陷的方式就是设置较短过期时间</p><p>即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</p><h3 id="缓存击穿（量太大，缓存过期）"><a href="#缓存击穿（量太大，缓存过期）" class="headerlink" title="缓存击穿（量太大，缓存过期）"></a>缓存击穿（量太大，缓存过期）</h3><blockquote><p>概念</p></blockquote><p> 相较于缓存穿透，缓存击穿的目的性更强，一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。这就是缓存被击穿，只是针对其中某个key的缓存不可用而导致击穿，但是其他的key依然可以使用缓存响应。</p><p> 比如热搜排行上，一个热点新闻被同时大量访问就可能导致缓存击穿。</p><blockquote><p>解决方案</p></blockquote><ol><li><p><strong>设置热点数据永不过期</strong></p><p>这样就不会出现热点数据过期的情况，但是当Redis内存空间满的时候也会清理部分数据，而且此种方案会占用空间，一旦热点数据多了起来，就会占用部分空间。</p></li><li><p><strong>加互斥锁(分布式锁)</strong></p><p>在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。保证同时刻只有一个线程访问。这样对锁的要求就十分高。</p></li></ol><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><blockquote><p>概念</p></blockquote><p>大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200513215850428.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>解决方案</p></blockquote><ul><li><p>redis高可用</p><p>这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群</p></li><li><p>限流降级</p><p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p></li><li><p>数据预热</p><p>数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p></li></ul><p>出处：<a href="https://blog.csdn.net/weixin_43873227/article/details/106107270">https://blog.csdn.net/weixin_43873227/article/details/106107270</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Nosql概述&quot;&gt;&lt;a href=&quot;#一、Nosql概述&quot; class=&quot;headerlink&quot; title=&quot;一、Nosql概述&quot;&gt;&lt;/a&gt;一、Nosql概述&lt;/h1&gt;&lt;h2 id=&quot;1、单机Mysql时代&quot;&gt;&lt;a href=&quot;#1、单机Mysql时代&quot; c</summary>
      
    
    
    
    <category term="Redis" scheme="https://cddorz.github.io/categories/Redis/"/>
    
    
    <category term="数据库" scheme="https://cddorz.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Linux相关</title>
    <link href="https://cddorz.github.io/2020/11/14/Linux%E7%9B%B8%E5%85%B3/"/>
    <id>https://cddorz.github.io/2020/11/14/Linux%E7%9B%B8%E5%85%B3/</id>
    <published>2020-11-14T15:46:13.000Z</published>
    <updated>2020-11-26T04:57:36.569Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>系统目录结构</p></blockquote><p>登录系统后，在当前命令窗口下输入命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls &#x2F;</span><br></pre></td></tr></table></figure><p>你会看到如下图所示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LDkhrDl4H9TqZhwyeNSeaNSvqpApZkrQNCQFhVhyPoPdtFTibRBEssIj6EmiapgETvK2brVhfliaRRg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>树状目录结构：（Linux的一切资源都挂载在这个 / 根节点下）</p><p><img src= "/img/loading.gif" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LDkhrDl4H9TqZhwyeNSeaNibQYW2xbQIL38lrCCSPEzFKJhCiau0FvQMFSa37NQxTTbbo3PrpjJic5g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p><strong>以下是对这些目录的解释：</strong></p><ul><li><strong>/bin</strong>：bin是Binary的缩写, 这个目录存放着最经常使用的命令。</li><li><strong>/boot：</strong> 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</li><li><strong>/dev ：</strong> dev是Device(设备)的缩写, 存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。</li><li><strong>/etc：</strong> 这个目录用来存放所有的系统管理所需要的配置文件和子目录。</li><li><strong>/home</strong>：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</li><li><strong>/lib</strong>：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。</li><li><strong>/lost+found</strong>：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</li><li><strong>/media</strong>：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</li><li><strong>/mnt</strong>：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。</li><li><strong>/opt</strong>：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</li><li><strong>/proc</strong>：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。</li><li><strong>/root</strong>：该目录为系统管理员，也称作超级权限者的用户主目录。</li><li><strong>/sbin</strong>：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</li><li><strong>/srv</strong>：该目录存放一些服务启动之后需要提取的数据。</li><li><strong>/sys</strong>：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。</li><li><strong>/tmp</strong>：这个目录是用来存放一些临时文件的。</li><li><strong>/usr</strong>：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。</li><li><strong>/usr/bin：</strong> 系统用户使用的应用程序。</li><li><strong>/usr/sbin：</strong> 超级用户使用的比较高级的管理程序和系统守护程序。</li><li><strong>/usr/src：</strong> 内核源代码默认的放置目录。</li><li><strong>/var</strong>：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</li><li><strong>/run</strong>：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。</li></ul><h3 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h3><blockquote><p>绝对路径和相对路径</p></blockquote><p>我们知道Linux的目录结构为树状结构，最顶级的目录为根目录 /。</p><p>其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。</p><p>在开始本教程前我们需要先知道什么是绝对路径与相对路径。</p><p><strong>绝对路径：</strong></p><p>路径的写法，由根目录 / 写起，例如：/usr/share/doc 这个目录。</p><p><strong>相对路径：</strong></p><p>路径的写法，不是由 / 写起，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成：cd ../man 这就是相对路径的写法啦！</p><blockquote><p>处理目录的常用命令</p></blockquote><p>接下来我们就来看几个常见的处理目录的命令吧：</p><ul><li>ls: 列出目录</li><li>cd：切换目录</li><li>pwd：显示目前的目录</li><li>mkdir：创建一个新的目录</li><li>rmdir：删除一个空的目录</li><li>cp: 复制文件或目录</li><li>rm: 移除文件或目录</li><li>mv: 移动文件与目录，或修改文件与目录的名称</li></ul><p>你可以使用 <em>man [命令]</em> 来查看各个命令的使用文档，如 ：man cp。</p><blockquote><p>ls （列出目录）</p></blockquote><p>在Linux系统当中， ls 命令可能是最常被运行的。</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# ls [-aAdfFhilnrRSt] 目录名称</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)</li><li>-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)</li></ul><p>将目录下的所有文件列出来(含属性与隐藏档)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# ls -al ~</span><br></pre></td></tr></table></figure><blockquote><p>cd （切换目录）</p></blockquote><p>cd是Change Directory的缩写，这是用来变换工作目录的命令。</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd [相对路径或绝对路径]</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 切换到用户目录下</span><br><span class="line">[root@kuangshen &#x2F;]# cd home  </span><br><span class="line"></span><br><span class="line"># 使用 mkdir 命令创建 kuangstudy 目录</span><br><span class="line">[root@kuangshen home]# mkdir kuangstudy</span><br><span class="line"></span><br><span class="line"># 进入 kuangstudy 目录</span><br><span class="line">[root@kuangshen home]# cd kuangstudy</span><br><span class="line"></span><br><span class="line"># 回到上一级</span><br><span class="line">[root@kuangshen kuangstudy]# cd ..</span><br><span class="line"></span><br><span class="line"># 回到根目录</span><br><span class="line">[root@kuangshen kuangstudy]# cd &#x2F;</span><br><span class="line"></span><br><span class="line"># 表示回到自己的家目录，亦即是 &#x2F;root 这个目录</span><br><span class="line">[root@kuangshen kuangstudy]# cd ~</span><br></pre></td></tr></table></figure><p>接下来大家多操作几次应该就可以很好的理解 cd 命令的。</p><blockquote><p>pwd ( 显示目前所在的目录 )</p></blockquote><p>pwd 是 <strong>Print Working Directory</strong> 的缩写，也就是显示目前所在目录的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@kuangshen kuangstudy]#pwd [-P]</span><br></pre></td></tr></table></figure><p>选项与参数：**-P** ：显示出确实的路径，而非使用连接(link) 路径。</p><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 单纯显示出目前的工作目录</span><br><span class="line">[root@kuangshen ~]# pwd</span><br><span class="line">&#x2F;root</span><br><span class="line"></span><br><span class="line"># 如果是链接，要显示真实地址，可以使用 -P参数</span><br><span class="line">[root@kuangshen &#x2F;]# cd bin</span><br><span class="line">[root@kuangshen bin]# pwd -P</span><br><span class="line">&#x2F;usr&#x2F;bin</span><br></pre></td></tr></table></figure><blockquote><p>mkdir （创建新目录）</p></blockquote><p>如果想要创建新的目录的话，那么就使用mkdir (make directory)吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir [-mp] 目录名称</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～</li><li>-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！</li></ul><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 进入我们用户目录下</span><br><span class="line">[root@kuangshen &#x2F;]# cd &#x2F;home</span><br><span class="line"></span><br><span class="line"># 创建一个 test 文件夹</span><br><span class="line">[root@kuangshen home]# mkdir test</span><br><span class="line"></span><br><span class="line"># 创建多层级目录</span><br><span class="line">[root@kuangshen home]# mkdir test1&#x2F;test2&#x2F;test3&#x2F;test4</span><br><span class="line">mkdir: cannot create directory ‘test1&#x2F;test2&#x2F;test3&#x2F;test4’:</span><br><span class="line">No such file or directory  # &lt;&#x3D;&#x3D; 没办法直接创建此目录啊！</span><br><span class="line"></span><br><span class="line"># 加了这个 -p 的选项，可以自行帮你创建多层目录！</span><br><span class="line">[root@kuangshen home]# mkdir -p test1&#x2F;test2&#x2F;test3&#x2F;test4</span><br><span class="line"></span><br><span class="line"># 创建权限为 rwx--x--x 的目录。</span><br><span class="line">[root@kuangshen home]# mkdir -m 711 test2</span><br><span class="line">[root@kuangshen home]# ls -l</span><br><span class="line">drwxr-xr-x 2 root root  4096 Mar 12 21:55 test</span><br><span class="line">drwxr-xr-x 3 root root  4096 Mar 12 21:56 test1</span><br><span class="line">drwx--x--x 2 root root  4096 Mar 12 21:58 test2</span><br></pre></td></tr></table></figure><blockquote><p>rmdir ( 删除空的目录 )</p></blockquote><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir [-p] 目录名称</span><br></pre></td></tr></table></figure><p>选项与参数：**-p ：**连同上一级『空的』目录也一起删除</p><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 看看有多少目录存在？</span><br><span class="line">[root@kuangshen home]# ls -l</span><br><span class="line">drwxr-xr-x 2 root root  4096 Mar 12 21:55 test</span><br><span class="line">drwxr-xr-x 3 root root  4096 Mar 12 21:56 test1</span><br><span class="line">drwx--x--x 2 root root  4096 Mar 12 21:58 test2</span><br><span class="line"></span><br><span class="line"># 可直接删除掉，没问题</span><br><span class="line">[root@kuangshen home]# rmdir test</span><br><span class="line"></span><br><span class="line"># 因为尚有内容，所以无法删除！</span><br><span class="line">[root@kuangshen home]# rmdir test1</span><br><span class="line">rmdir: failed to remove ‘test1’: Directory not empty</span><br><span class="line"></span><br><span class="line"># 利用 -p 这个选项，立刻就可以将 test1&#x2F;test2&#x2F;test3&#x2F;test4 依次删除。</span><br><span class="line">[root@kuangshen home]# rmdir -p test1&#x2F;test2&#x2F;test3&#x2F;test4</span><br></pre></td></tr></table></figure><p>注意：这个 rmdir 仅能删除空的目录，你可以使用 rm 命令来删除非空目录，后面我们会将！</p><blockquote><p>cp ( 复制文件或目录 )</p></blockquote><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination)</span><br><span class="line">[root@www ~]# cp [options] source1 source2 source3 .... directory</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li><strong>-a：</strong>相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)</li><li><strong>-p：</strong>连同文件的属性一起复制过去，而非使用默认属性(备份常用)；</li><li><strong>-d：</strong>若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；</li><li><strong>-r：</strong>递归持续复制，用於目录的复制行为；(常用)</li><li><strong>-f：</strong>为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；</li><li><strong>-i：</strong>若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</li><li><strong>-l：</strong>进行硬式连结(hard link)的连结档创建，而非复制文件本身。</li><li><strong>-s：</strong>复制成为符号连结档 (symbolic link)，亦即『捷径』文件；</li><li><strong>-u：</strong>若 destination 比 source 旧才升级 destination ！</li></ul><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 找一个有文件的目录，我这里找到 root目录</span><br><span class="line">[root@kuangshen home]# cd &#x2F;root</span><br><span class="line">[root@kuangshen ~]# ls</span><br><span class="line">install.sh</span><br><span class="line">[root@kuangshen ~]# cd &#x2F;home</span><br><span class="line"></span><br><span class="line"># 复制 root目录下的install.sh 到 home目录下</span><br><span class="line">[root@kuangshen home]# cp &#x2F;root&#x2F;install.sh &#x2F;home</span><br><span class="line">[root@kuangshen home]# ls</span><br><span class="line">install.sh</span><br><span class="line"></span><br><span class="line"># 再次复制，加上-i参数，增加覆盖询问？</span><br><span class="line">[root@kuangshen home]# cp -i &#x2F;root&#x2F;install.sh &#x2F;home</span><br><span class="line">cp: overwrite ‘&#x2F;home&#x2F;install.sh’? y # n不覆盖，y为覆盖</span><br></pre></td></tr></table></figure><blockquote><p>rm ( 移除文件或目录 )</p></blockquote><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm [-fir] 文件或目录</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；</li><li>-i ：互动模式，在删除前会询问使用者是否动作</li><li>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！</li></ul><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 将刚刚在 cp 的实例中创建的 install.sh删除掉！</span><br><span class="line">[root@kuangshen home]# rm -i install.sh</span><br><span class="line">rm: remove regular file ‘install.sh’? y</span><br><span class="line"># 如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！</span><br><span class="line"></span><br><span class="line"># 尽量不要在服务器上使用 rm -rf &#x2F;</span><br></pre></td></tr></table></figure><blockquote><p>mv  ( 移动文件与目录，或修改名称 )</p></blockquote><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# mv [-fiu] source destination</span><br><span class="line">[root@www ~]# mv [options] source1 source2 source3 .... directory</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li><li>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！</li><li>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</li></ul><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 复制一个文件到当前目录</span><br><span class="line">[root@kuangshen home]# cp &#x2F;root&#x2F;install.sh &#x2F;home</span><br><span class="line"></span><br><span class="line"># 创建一个文件夹 test</span><br><span class="line">[root@kuangshen home]# mkdir test</span><br><span class="line"></span><br><span class="line"># 将复制过来的文件移动到我们创建的目录，并查看</span><br><span class="line">[root@kuangshen home]# mv install.sh test</span><br><span class="line">[root@kuangshen home]# ls</span><br><span class="line">test</span><br><span class="line">[root@kuangshen home]# cd test</span><br><span class="line">[root@kuangshen test]# ls</span><br><span class="line">install.sh</span><br><span class="line"></span><br><span class="line"># 将文件夹重命名，然后再次查看！</span><br><span class="line">[root@kuangshen test]# cd ..</span><br><span class="line">[root@kuangshen home]# mv test mvtest</span><br><span class="line">[root@kuangshen home]# ls</span><br><span class="line">mvtest</span><br></pre></td></tr></table></figure><h3 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h3><blockquote><p>看懂文件属性</p></blockquote><p>Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。</p><p>在Linux中我们可以使用<code>ll</code>或者<code>ls –l</code>命令来显示一个文件的属性以及文件所属的用户和组，如：</p><p><img src= "/img/loading.gif" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JGpeIS4j9q3B4LQhsQkFiauXAQN0qOnVCYvj7Cm1oQbvexVDFqPhUIeTe83BdAHlXCJhGoNabSFKQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>实例中，boot文件的第一个属性用”d”表示。”d”在Linux中代表该文件是一个目录文件。</p><p>在Linux中第一个字符代表这个文件是目录、文件或链接文件等等：</p><ul><li>当为[ <strong>d</strong> ]则是目录</li><li>当为[ <strong>-</strong> ]则是文件；</li><li>若是[ <strong>l</strong> ]则表示为链接文档 ( link file )；</li><li>若是[ <strong>b</strong> ]则表示为装置文件里面的可供储存的接口设备 ( 可随机存取装置 )；</li><li>若是[ <strong>c</strong> ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )。</li></ul><p>接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。</p><p>其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。</p><p>要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。</p><p>每个文件的属性由左边第一部分的10个字符来确定（如下图）：</p><p><img src= "/img/loading.gif" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JGpeIS4j9q3B4LQhsQkFiauEybzG2XIdlOMLyO13lMfPKUWRpGJGgyxCAJ9mics9dTZ1qrWDIvleYQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>从左至右用0-9这些数字来表示。</p><p>第0位确定文件类型，第1-3位确定属主（该文件的所有者）拥有该文件的权限。第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。</p><p>其中：</p><p>第1、4、7位表示读权限，如果用”r”字符表示，则有读权限，如果用”-“字符表示，则没有读权限；</p><p>第2、5、8位表示写权限，如果用”w”字符表示，则有写权限，如果用”-“字符表示没有写权限；</p><p>第3、6、9位表示可执行权限，如果用”x”字符表示，则有执行权限，如果用”-“字符表示，则没有执行权限。</p><p>对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。</p><p>同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。</p><p>文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。</p><p>因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。</p><p>在以上实例中，boot 文件是一个目录文件，属主和属组都为 root。</p><blockquote><p>修改文件属性</p></blockquote><p><strong>1、chgrp：更改文件属组</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp [-R] 属组名 文件名</span><br></pre></td></tr></table></figure><p>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</p><p><strong>2、chown：更改文件属主，也可以同时更改文件属组</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown [–R] 属主名 文件名</span><br><span class="line">chown [-R] 属主名：属组名 文件名</span><br></pre></td></tr></table></figure><p><strong>3、chmod：更改文件9个属性</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [-R] xyz 文件或目录</span><br></pre></td></tr></table></figure><p>Linux文件属性有两种设置方法，一种是数字，一种是符号。</p><p>Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。</p><p>先复习一下刚刚上面提到的数据：文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r:4     w:2         x:1</span><br></pre></td></tr></table></figure><p>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为：[-rwxrwx—] 分数则是：</p><ul><li>owner = rwx = 4+2+1 = 7</li><li>group = rwx = 4+2+1 = 7</li><li>others= — = 0+0+0 = 0</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 770 filename</span><br></pre></td></tr></table></figure><p>可以自己下去多进行测试！</p><h3 id="文件内容查看"><a href="#文件内容查看" class="headerlink" title="文件内容查看"></a>文件内容查看</h3><blockquote><p>概述</p></blockquote><p>Linux系统中使用以下命令来查看文件的内容：</p><ul><li>cat 由第一行开始显示文件内容</li><li>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</li><li>nl  显示的时候，顺道输出行号！</li><li>more 一页一页的显示文件内容</li><li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！</li><li>head 只看头几行</li><li>tail 只看尾巴几行</li></ul><p>你可以使用 *man [命令]*来查看各个命令的使用文档，如 ：man cp。</p><blockquote><p>cat 由第一行开始显示文件内容</p></blockquote><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat [-AbEnTv]</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</li><li>-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！</li><li>-E ：将结尾的断行字节 $ 显示出来；</li><li>-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；</li><li>-T ：将 [tab] 按键以 ^I 显示出来；</li><li>-v ：列出一些看不出来的特殊字符</li></ul><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查看网络配置: 文件地址 &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;</span><br><span class="line">[root@kuangshen ~]# cat &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth0</span><br><span class="line">DEVICE&#x3D;eth0</span><br><span class="line">BOOTPROTO&#x3D;dhcp</span><br><span class="line">ONBOOT&#x3D;yes</span><br></pre></td></tr></table></figure><blockquote><p>tac</p></blockquote><p>tac与cat命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@kuangshen ~]# tac &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth0</span><br><span class="line">ONBOOT&#x3D;yes</span><br><span class="line">BOOTPROTO&#x3D;dhcp</span><br><span class="line">DEVICE&#x3D;eth0</span><br></pre></td></tr></table></figure><blockquote><p>nl  显示行号</p></blockquote><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nl [-bnw] 文件</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-b ：指定行号指定的方式，主要有两种：-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；-b t ：如果有空行，空的那一行不要列出行号(默认值)；</li><li>-n ：列出行号表示的方法，主要有三种：-n ln ：行号在荧幕的最左方显示；-n rn ：行号在自己栏位的最右方显示，且不加 0 ；-n rz ：行号在自己栏位的最右方显示，且加 0 ；</li><li>-w ：行号栏位的占用的位数。</li></ul><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@kuangshen ~]# nl &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth0</span><br><span class="line">1DEVICE&#x3D;eth0</span><br><span class="line">2BOOTPROTO&#x3D;dhcp</span><br><span class="line">3ONBOOT&#x3D;yes</span><br></pre></td></tr></table></figure><blockquote><p>more  一页一页翻动</p></blockquote><p>在 more 这个程序的运行过程中，你有几个按键可以按的：</p><ul><li>空白键 (space)：代表向下翻一页；</li><li>Enter   ：代表向下翻『一行』；</li><li>/字串   ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；</li><li>:f    ：立刻显示出档名以及目前显示的行数；</li><li>q    ：代表立刻离开 more ，不再显示该文件内容。</li><li>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@kuangshen etc]# more &#x2F;etc&#x2F;csh.login</span><br><span class="line">....(中间省略)....</span><br><span class="line">--More--(28%) # 重点在这一行喔！你的光标也会在这里等待你的命令</span><br></pre></td></tr></table></figure><blockquote><p>less  一页一页翻动，以下实例输出/etc/man.config文件的内容：</p></blockquote><p>less运行时可以输入的命令有：</p><ul><li>空白键  ：向下翻动一页；</li><li>[pagedown]：向下翻动一页；</li><li>[pageup] ：向上翻动一页；</li><li>/字串  ：向下搜寻『字串』的功能；</li><li>?字串  ：向上搜寻『字串』的功能；</li><li>n   ：重复前一个搜寻 (与 / 或 ? 有关！)</li><li>N   ：反向的重复前一个搜寻 (与 / 或 ? 有关！)</li><li>q   ：离开 less 这个程序；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@kuangshen etc]# more &#x2F;etc&#x2F;csh.login</span><br><span class="line">....(中间省略)....</span><br><span class="line">:   # 这里可以等待你输入命令！</span><br></pre></td></tr></table></figure><blockquote><p>head  取出文件前面几行</p></blockquote><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head [-n number] 文件</span><br></pre></td></tr></table></figure><p>选项与参数：**-n** 后面接数字，代表显示几行的意思！</p><p>默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@kuangshen etc]# head -n 20 &#x2F;etc&#x2F;csh.login</span><br></pre></td></tr></table></figure><blockquote><p>tail  取出文件后面几行</p></blockquote><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail [-n number] 文件</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-n ：后面接数字，代表显示几行的意思</li></ul><p>默认的情况中，显示最后 10 行！若要显示最后 20 行，就得要这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@kuangshen etc]# tail -n 20 &#x2F;etc&#x2F;csh.login</span><br></pre></td></tr></table></figure><blockquote><p>拓展：Linux 链接概念</p></blockquote><p>Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。</p><p>情况下，<strong>ln</strong> 命令产生硬链接。</p><p><strong>硬连接</strong></p><p>硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。</p><p>硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</p><p><strong>软连接</strong></p><p>另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。</p><p><strong>测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@kuangshen &#x2F;]# cd &#x2F;home</span><br><span class="line">[root@kuangshen home]# touch f1 # 创建一个测试文件f1</span><br><span class="line">[root@kuangshen home]# ls</span><br><span class="line">f1</span><br><span class="line">[root@kuangshen home]# ln f1 f2     # 创建f1的一个硬连接文件f2</span><br><span class="line">[root@kuangshen home]# ln -s f1 f3   # 创建f1的一个符号连接文件f3</span><br><span class="line">[root@kuangshen home]# ls -li       # -i参数显示文件的inode节点信息</span><br><span class="line">397247 -rw-r--r-- 2 root root     0 Mar 13 00:50 f1</span><br><span class="line">397247 -rw-r--r-- 2 root root     0 Mar 13 00:50 f2</span><br><span class="line">397248 lrwxrwxrwx 1 root root     2 Mar 13 00:50 f3 -&gt; f1</span><br></pre></td></tr></table></figure><p>从上面的结果中可以看出，硬连接文件 f2 与原文件 f1 的 inode 节点相同，均为 397247，然而符号连接文件的 inode 节点不同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># echo 字符串输出 &gt;&gt; f1 输出到 f1文件</span><br><span class="line">[root@kuangshen home]# echo &quot;I am f1 file&quot; &gt;&gt;f1</span><br><span class="line">[root@kuangshen home]# cat f1</span><br><span class="line">I am f1 file</span><br><span class="line">[root@kuangshen home]# cat f2</span><br><span class="line">I am f1 file</span><br><span class="line">[root@kuangshen home]# cat f3</span><br><span class="line">I am f1 file</span><br><span class="line">[root@kuangshen home]# rm -f f1</span><br><span class="line">[root@kuangshen home]# cat f2</span><br><span class="line">I am f1 file</span><br><span class="line">[root@kuangshen home]# cat f3</span><br><span class="line">cat: f3: No such file or directory</span><br></pre></td></tr></table></figure><p>通过上面的测试可以看出：当删除原始文件 f1 后，硬连接 f2 不受影响，但是符号连接 f1 文件无效；</p><p>依此您可以做一些相关的测试，可以得到以下全部结论：</p><ul><li>删除符号连接f3,对f1,f2无影响；</li><li>删除硬连接f2，对f1,f3也无影响；</li><li>删除原文件f1，对硬连接f2没有影响，导致符号连接f3失效；</li><li>同时删除原文件f1,硬连接f2，整个文件会真正的被删除。</li></ul><h4 id="vim相关知识"><a href="#vim相关知识" class="headerlink" title="vim相关知识"></a><a href="https://mp.weixin.qq.com/s/AndIwanhZ3Tlg0iQe8a4lQ">vim相关知识</a></h4><h4 id="以上笔记均来自狂神说公众号。"><a href="#以上笔记均来自狂神说公众号。" class="headerlink" title="以上笔记均来自狂神说公众号。"></a>以上笔记均来自狂神说公众号。</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;系统目录结构&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;登录系统后，在当前命令窗口下输入命令&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span </summary>
      
    
    
    
    <category term="系统" scheme="https://cddorz.github.io/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Linux" scheme="https://cddorz.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis（一）</title>
    <link href="https://cddorz.github.io/2020/11/11/Mybatis/"/>
    <id>https://cddorz.github.io/2020/11/11/Mybatis/</id>
    <published>2020-11-11T11:14:59.000Z</published>
    <updated>2020-11-12T06:13:18.760Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>持久化</p></blockquote><p><strong>持久化是将程序数据在持久状态和瞬时状态间转换的机制。</strong></p><ul><li>即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的对象存储在数据库中，或者存储在磁盘文件中、XML数据文件中等等。</li><li>JDBC就是一种持久化机制。文件IO也是一种持久化机制。</li><li>在生活中 : 将鲜肉冷藏，吃的时候再解冻的方法也是。将水果做成罐头的方法也是。</li></ul><p><strong>为什么需要持久化服务呢？那是由于内存本身的缺陷引起的</strong></p><ul><li>内存断电后数据会丢失，但有一些对象是无论如何都不能丢失的，比如银行账号等，遗憾的是，人们还无法保证内存永不掉电。</li><li>内存过于昂贵，与硬盘、光盘等外存相比，内存的价格要高2~3个数量级，而且维持成本也高，至少需要一直供电吧。所以即使对象不需要永久保存，也会因为内存的容量限制不能一直呆在内存中，需要持久化来缓存到外存。</li></ul><blockquote><p>持久层</p></blockquote><p><strong>什么是持久层？</strong></p><ul><li>完成持久化工作的代码块 .  —-&gt;  dao层 【DAO (Data Access Object)  数据访问对象】</li><li>大多数情况下特别是企业级应用，数据持久化往往也就意味着将内存中的数据保存到磁盘上加以固化，而持久化的实现过程则大多通过各种<strong>关系数据库</strong>来完成。</li><li>不过这里有一个字需要特别强调，也就是所谓的“层”。对于应用系统而言，数据持久功能大多是必不可少的组成部分。也就是说，我们的系统中，已经天然的具备了“持久层”概念？也许是，但也许实际情况并非如此。之所以要独立出一个“持久层”的概念,而不是“持久模块”，“持久单元”，也就意味着，我们的系统架构中，应该有一个相对独立的逻辑层面，专注于数据持久化逻辑的实现.</li><li>与系统其他部分相对而言，这个层面应该具有一个较为清晰和严格的逻辑边界。【说白了就是用来操作数据库存在的！】</li></ul><blockquote><p>为什么需要Mybatis</p></blockquote><ul><li><p>Mybatis就是帮助程序猿将数据存入数据库中 , 和从数据库中取数据 .</p></li><li><p>传统的jdbc操作 , 有很多重复代码块 .比如 : 数据取出时的封装 , 数据库的建立连接等等… , 通过框架可以减少重复代码,提高开发效率 .</p></li><li><p>MyBatis 是一个半自动化的<strong>ORM框架 (Object Relationship Mapping) –&gt;对象关系映射</strong></p></li><li><p>所有的事情，不用Mybatis依旧可以做到，只是用了它，所有实现会更加简单！<strong>技术没有高低之分，只有使用这个技术的人有高低之别</strong></p></li><li><p>MyBatis的优点</p></li><li><ul><li>简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件就可以了，易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。</li><li>灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。sql写在xml里，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。</li><li>解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。</li><li>提供xml标签，支持编写动态sql。</li><li>…….</li></ul></li><li><p><strong>思路流程：搭建环境–&gt;导入Mybatis—&gt;编写代码—&gt;测试</strong></p></li><li><blockquote><p>代码演示</p></blockquote></li><li><p>1、搭建实验数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE &#96;mybatis&#96;;</span><br><span class="line"></span><br><span class="line">USE &#96;mybatis&#96;;</span><br><span class="line"></span><br><span class="line">DROP TABLE IF EXISTS &#96;user&#96;;</span><br><span class="line"></span><br><span class="line">CREATE TABLE &#96;user&#96; (</span><br><span class="line">&#96;id&#96; int(20) NOT NULL,</span><br><span class="line">&#96;name&#96; varchar(30) DEFAULT NULL,</span><br><span class="line">&#96;pwd&#96; varchar(30) DEFAULT NULL,</span><br><span class="line">PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line"></span><br><span class="line">insert  into &#96;user&#96;(&#96;id&#96;,&#96;name&#96;,&#96;pwd&#96;) values (1,&#39;狂神&#39;,&#39;123456&#39;),(2,&#39;张三&#39;,&#39;abcdef&#39;),(3,&#39;李四&#39;,&#39;987654&#39;);</span><br></pre></td></tr></table></figure></li><li><p>2、导入MyBatis相关 jar 包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>3、编写MyBatis核心配置文件</p><p>查看帮助文档</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">       <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">       <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span>/&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/kuang/dao/userMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>4、编写MyBatis工具类</p><p>查看帮助文档</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           String resource = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">           InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">           sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取SqlSession连接</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSession</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> sqlSessionFactory.openSession();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>5、创建实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> id;  <span class="comment">//id</span></span><br><span class="line">   <span class="keyword">private</span> String name;   <span class="comment">//姓名</span></span><br><span class="line">   <span class="keyword">private</span> String pwd;   <span class="comment">//密码</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">//构造,有参,无参</span></span><br><span class="line">   <span class="comment">//set/get</span></span><br><span class="line">   <span class="comment">//toString()</span></span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>6、编写Mapper接口类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.kuang.pojo.User;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">   <span class="function">List&lt;User&gt; <span class="title">selectUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>7、编写Mapper.xml配置文件</p><p>namespace 十分重要，不能写错！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">       <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">       <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.kuang.dao.UserMapper&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span>&gt;</span></span><br><span class="line">  select * from user</span><br><span class="line"> <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><blockquote><p>问题说明</p></blockquote></li><li><p><strong>可能出现问题说明：Maven静态资源过滤问题</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line">   &lt;resource&gt;</span><br><span class="line">       &lt;directory&gt;src&#x2F;main&#x2F;java&lt;&#x2F;directory&gt;</span><br><span class="line">       &lt;includes&gt;</span><br><span class="line">           &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;</span><br><span class="line">           &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;</span><br><span class="line">       &lt;&#x2F;includes&gt;</span><br><span class="line">       &lt;filtering&gt;false&lt;&#x2F;filtering&gt;</span><br><span class="line">   &lt;&#x2F;resource&gt;</span><br><span class="line">   &lt;resource&gt;</span><br><span class="line">       &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;</span><br><span class="line">       &lt;includes&gt;</span><br><span class="line">           &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;</span><br><span class="line">           &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;</span><br><span class="line">       &lt;&#x2F;includes&gt;</span><br><span class="line">       &lt;filtering&gt;false&lt;&#x2F;filtering&gt;</span><br><span class="line">   &lt;&#x2F;resource&gt;</span><br><span class="line">&lt;&#x2F;resources&gt;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;持久化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;持久化是将程序数据在持久状态和瞬时状态间转换的机制。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是</summary>
      
    
    
    
    <category term="mybatis" scheme="https://cddorz.github.io/categories/mybatis/"/>
    
    
    <category term="mybatis" scheme="https://cddorz.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>少年二字，应与平庸相斥</title>
    <link href="https://cddorz.github.io/2020/11/10/%E5%B0%91%E5%B9%B4%E4%BA%8C%E5%AD%97%EF%BC%8C%E5%BA%94%E4%B8%8E%E5%B9%B3%E5%BA%B8%E7%9B%B8%E6%96%A5/"/>
    <id>https://cddorz.github.io/2020/11/10/%E5%B0%91%E5%B9%B4%E4%BA%8C%E5%AD%97%EF%BC%8C%E5%BA%94%E4%B8%8E%E5%B9%B3%E5%BA%B8%E7%9B%B8%E6%96%A5/</id>
    <published>2020-11-10T08:49:30.000Z</published>
    <updated>2021-01-12T05:08:23.317Z</updated>
    
    <content type="html"><![CDATA[<h2 id="听闻少年二字，应与平庸相斥。"><a href="#听闻少年二字，应与平庸相斥。" class="headerlink" title="听闻少年二字，应与平庸相斥。"></a>听闻少年二字，应与平庸相斥。</h2><p>​        以后会走上怎样的道路尚不确定，只知年少的我们，生活中有诗歌和远方，脚下有坚实的土地，头顶有浩瀚的星空。宁欺白须公，莫欺少年穷，我们有着无限的可能性。</p><p>​        在高中，总有人在你身后催促着你前进，奔跑途中，身边也是与你一起冲向梦想的同学，但到了大学，似乎一切都变了。一个人在外，没有人在你身后看着你，身边的人也有了各自的目标和方向，大一的我迷茫了……</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-585af38a5f78e8a4fb027f998ac84df2_720w.jpg?source=1940ef5c" alt="img"></p><p>​        大一上，我上课玩手机，回寝室也是玩手机。点外卖，瘫坐在吊椅上无所事事，成了常态，看着室友自律的样子，也曾想做出过改变，但还是挡不住外在的诱惑（也许还幼稚），就这样浑浑噩噩的过了半年，最终成绩也只是中等。大一下，疫情爆发了，不得不在家里上网课，这导致我更加肆无忌惮的放松自己，慢性死亡，上网课没精神，看小说，几乎不出屋子，时时刻刻都在床上。这就是我的大一。</p><p>​        大二上，惊讶的发现室友有了惊天的变化，在我慢性死亡的时候，他有了自己的目标，并且为此做出了巨大的改变和努力，coding能力变得很强（发量可以看出），自己去加了学校的工作室，做了很多的业务，也得了很多的奖，那时，我才懂，他已经站在了只有少部分人站的高处，所以我也做出了改变，想清自己想要什么。现在的我，也算是刚刚起步，跳出了自己的舒适圈，<strong>希望自己能越来越好，上进且不平庸，不白来世间一趟</strong>，谨以此文激励自己。</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic3.zhimg.com/80/v2-65bedd063f12030d068046b72e425e08_720w.jpg?source=1940ef5c" alt="img"></p><p><strong>你本来就是太阳，无需凭借谁的光。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;听闻少年二字，应与平庸相斥。&quot;&gt;&lt;a href=&quot;#听闻少年二字，应与平庸相斥。&quot; class=&quot;headerlink&quot; title=&quot;听闻少年二字，应与平庸相斥。&quot;&gt;&lt;/a&gt;听闻少年二字，应与平庸相斥。&lt;/h2&gt;&lt;p&gt;​        以后会走上怎样的道路尚不确</summary>
      
    
    
    
    <category term="日常" scheme="https://cddorz.github.io/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="少年" scheme="https://cddorz.github.io/tags/%E5%B0%91%E5%B9%B4/"/>
    
  </entry>
  
  <entry>
    <title>Java集合框架</title>
    <link href="https://cddorz.github.io/2020/11/06/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    <id>https://cddorz.github.io/2020/11/06/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</id>
    <published>2020-11-06T07:33:44.000Z</published>
    <updated>2020-11-12T03:46:54.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-集合框架"><a href="#Java-集合框架" class="headerlink" title="Java 集合框架"></a>Java 集合框架</h1><p><img src= "/img/loading.gif" data-lazy-src="https://www.runoob.com/wp-content/uploads/2014/01/2243690-9cd9c896e0d512ed.gif" alt="img"></p><ul><li><strong>接口：</strong>是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象</li><li><strong>实现（类）：</strong>是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。</li><li><strong>算法：</strong>是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。</li></ul><h4 id="一、Set和List的区别："><a href="#一、Set和List的区别：" class="headerlink" title="一、Set和List的区别："></a>一、Set和List的区别：</h4><ul><li>Set 接口实例存储的是无序的，不重复的数据。List 接口实例存储的是有序的，可以重复的元素</li><li> Set检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 <strong>&lt;实现类有HashSet,TreeSet&gt;</strong></li><li>List和数组类似，可以动态增长，根据实际存储的数据的长度自动增长List的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变 <strong>&lt;实现类有ArrayList,LinkedList,Vector&gt;</strong> </li></ul><h4 id="二、如何使用迭代器："><a href="#二、如何使用迭代器：" class="headerlink" title="二、如何使用迭代器："></a>二、如何使用迭代器：</h4><h5 id="遍历-ArrayList"><a href="#遍历-ArrayList" class="headerlink" title="遍历 ArrayList"></a>遍历 ArrayList</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">     list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">     list.add(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">     list.add(<span class="string">&quot;HAHAHAHA&quot;</span>);</span><br><span class="line">     <span class="comment">//第一种遍历方法使用 For-Each 遍历 List</span></span><br><span class="line">     <span class="keyword">for</span> (String str : list) &#123;            <span class="comment">//也可以改写 for(int i=0;i&lt;list.size();i++) 这种形式</span></span><br><span class="line">        System.out.println(str);</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//第二种遍历，把链表变为数组相关的内容进行遍历</span></span><br><span class="line">     String[] strArray=<span class="keyword">new</span> String[list.size()];</span><br><span class="line">     list.toArray(strArray);</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strArray.length;i++) <span class="comment">//这里也可以改写为  for(String str:strArray) 这种形式</span></span><br><span class="line">     &#123;</span><br><span class="line">        System.out.println(strArray[i]);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//第三种遍历 使用迭代器进行相关遍历,该方法可以不用担心在遍历的过程中会超出集合的长度。</span></span><br><span class="line">     </span><br><span class="line">     Iterator&lt;String&gt; ite=list.iterator();</span><br><span class="line">     <span class="keyword">while</span>(ite.hasNext())<span class="comment">//判断下一个元素之后有值</span></span><br><span class="line">     &#123;</span><br><span class="line">         System.out.println(ite.next());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="遍历-Map"><a href="#遍历-Map" class="headerlink" title="遍历 Map"></a>遍历 Map</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">      map.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">      map.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">      map.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;value3&quot;</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//第一种：普遍使用，二次取值</span></span><br><span class="line">      System.out.println(<span class="string">&quot;通过Map.keySet遍历key和value：&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;key= &quot;</span>+ key + <span class="string">&quot; and value= &quot;</span> + map.get(key));</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//第二种</span></span><br><span class="line">      System.out.println(<span class="string">&quot;通过Map.entrySet使用iterator遍历key和value：&quot;</span>);</span><br><span class="line">      Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line">      <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">       Map.Entry&lt;String, String&gt; entry = it.next();</span><br><span class="line">       System.out.println(<span class="string">&quot;key= &quot;</span> + entry.getKey() + <span class="string">&quot; and value= &quot;</span> + entry.getValue());</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//第三种：推荐，尤其是容量大时</span></span><br><span class="line">      System.out.println(<span class="string">&quot;通过Map.entrySet遍历key和value&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;key= &quot;</span> + entry.getKey() + <span class="string">&quot; and value= &quot;</span> + entry.getValue());</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">//第四种</span></span><br><span class="line">      System.out.println(<span class="string">&quot;通过Map.values()遍历所有的value，但不能遍历key&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (String v : map.values()) &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;value= &quot;</span> + v);</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、ArrayList"><a href="#三、ArrayList" class="headerlink" title="三、ArrayList"></a>三、ArrayList</h4><p>ArrayList类是一个可以动态修改的副本，与普通副本的区别就是它是没有固定大小的限制，我们可以添加或删除元素。</p><h6 id="1、基本实现"><a href="#1、基本实现" class="headerlink" title="1、基本实现"></a>1、基本实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunoobTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; sites = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        sites.add(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Weibo&quot;</span>);</span><br><span class="line">        System.out.println(sites);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="2、常用方法"><a href="#2、常用方法" class="headerlink" title="2、常用方法"></a>2、常用方法</h6><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/java/java-arraylist-add.html">add()</a></td><td>将元素插入到指定位置的 arraylist 中</td></tr><tr><td><a href="https://www.runoob.com/java/java-arraylist-get.html">get()</a></td><td>通过索引值获取 arraylist 中的元素</td></tr><tr><td><a href="https://www.runoob.com/java/java-arraylist-remove.html">remove()</a></td><td>删除 arraylist 里的单个元素</td></tr><tr><td><a href="https://www.runoob.com/java/java-arraylist-size.html">size()</a></td><td>返回 arraylist 里元素数量</td></tr><tr><td><a href="https://www.runoob.com/java/java-arraylist-set.html">set()</a></td><td>替换 arraylist 中指定索引的元素</td></tr><tr><td><a href="https://www.runoob.com/java/java-arraylist-tostring.html">toString()</a></td><td>将 arraylist 转换为字符串</td></tr></tbody></table><h4 id="四、LinkedList"><a href="#四、LinkedList" class="headerlink" title="四、LinkedList"></a>四、LinkedList</h4><p>链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的地址。</p><p>链表可分为单向链表和双向链表。</p><p>一个单向链表包含两个值: 当前节点的值和一个指向下一个节点的链接。</p><p><img src= "/img/loading.gif" data-lazy-src="https://www.runoob.com/wp-content/uploads/2020/06/408px-Singly-linked-list.svg_.png" alt="img"></p><p>一个双向链表有三个整数值: 数值、向后的节点链接、向前的节点链接。</p><p><img src= "/img/loading.gif" data-lazy-src="https://www.runoob.com/wp-content/uploads/2020/06/610px-Doubly-linked-list.svg_.png" alt="img"></p><p>Java LinkedList（链表） 类似于 ArrayList，是一种常用的数据容器。</p><p>与 ArrayList 相比，LinkedList 的增加和删除对操作效率更高，而查找和修改的操作效率较低。</p><p><strong>以下情况使用 ArrayList :</strong></p><ul><li>频繁访问列表中的某一个元素。</li><li>只需要在列表末尾进行添加和删除元素操作。</li></ul><p><strong>以下情况使用 LinkedList :</strong></p><ul><li>你需要通过循环迭代来访问列表中的某些元素。</li><li>需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作。</li></ul><h6 id="1、创建一个简单的链表实例"><a href="#1、创建一个简单的链表实例" class="headerlink" title="1、创建一个简单的链表实例"></a>1、创建一个简单的链表实例</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunoobTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; sites = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        sites.add(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Weibo&quot;</span>);</span><br><span class="line">        System.out.println(sites);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="2、常用方法-1"><a href="#2、常用方法-1" class="headerlink" title="2、常用方法"></a>2、常用方法</h6><table><thead><tr><th align="left">方法</th><th>描述</th></tr></thead><tbody><tr><td align="left">public int size()</td><td>返回链表元素个数。</td></tr><tr><td align="left">public E set(int index, E element)</td><td>设置指定位置的元素。</td></tr><tr><td align="left">public Object clone()</td><td>克隆该列表。</td></tr><tr><td align="left">public boolean add(E e)</td><td>链表末尾添加元素，返回是否成功，成功为 true，失败为 false。</td></tr><tr><td align="left">public void add(int index, E element)</td><td>向指定位置插入元素。</td></tr><tr><td align="left">public void addFirst(E e)</td><td>元素添加到头部</td></tr><tr><td align="left">public boolean offer(E e)</td><td>向链表末尾添加元素，返回是否成功，成功为 true，失败为 false。</td></tr><tr><td align="left">public void clear()</td><td>清空链表。</td></tr><tr><td align="left">public boolean remove(Object o)</td><td>删除某一元素，返回是否成功，成功为 true，失败为 false。</td></tr><tr><td align="left">public E remove(int index)</td><td>删除指定位置的元素。</td></tr><tr><td align="left">public E remove()</td><td>删除并返回第一个元素。</td></tr><tr><td align="left">public E get(int index)</td><td>返回指定位置的元素。</td></tr></tbody></table><h4 id="五、HashMap"><a href="#五、HashMap" class="headerlink" title="五、HashMap"></a>五、HashMap</h4><h6 id="1、基本内容："><a href="#1、基本内容：" class="headerlink" title="1、基本内容："></a>1、基本内容：</h6><p>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。</p><p>HashMap 实现了 Map 接口，根据键的 HashCode 值存储数据，具有很快的访问速度，最多允许一条记录的键为 null，不支持线程同步。</p><p>HashMap 是无序的，即不会记录插入的顺序。</p><p>HashMap 继承于AbstractMap，实现了 Map、Cloneable、java.io.Serializable 接口。</p><h6 id="2、HashMap-的-key-与-value-类型可以相同也可以不同，可以是字符串（String）类型的-key-和-value，也可以是整型（Integer）的-key-和字符串（String）类型的-value。"><a href="#2、HashMap-的-key-与-value-类型可以相同也可以不同，可以是字符串（String）类型的-key-和-value，也可以是整型（Integer）的-key-和字符串（String）类型的-value。" class="headerlink" title="2、HashMap 的 key 与 value 类型可以相同也可以不同，可以是字符串（String）类型的 key 和 value，也可以是整型（Integer）的 key 和字符串（String）类型的 value。"></a>2、HashMap 的 key 与 value 类型可以相同也可以不同，可以是字符串（String）类型的 key 和 value，也可以是整型（Integer）的 key 和字符串（String）类型的 value。</h6><h6 id="3、HashMap-中的元素实际上是对象，一些常见的基本类型可以使用它的包装类。"><a href="#3、HashMap-中的元素实际上是对象，一些常见的基本类型可以使用它的包装类。" class="headerlink" title="3、HashMap 中的元素实际上是对象，一些常见的基本类型可以使用它的包装类。"></a>3、HashMap 中的元素实际上是对象，一些常见的基本类型可以使用它的包装类。</h6><table><thead><tr><th>基本类型</th><th>引用类型</th></tr></thead><tbody><tr><td>boolean</td><td>Boolean</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character</td></tr></tbody></table><h6 id="4、例："><a href="#4、例：" class="headerlink" title="4、例："></a>4、例：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 HashMap 类      </span></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunoobTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 HashMap 对象 Sites</span></span><br><span class="line">        HashMap&lt;Integer, String&gt; Sites = <span class="keyword">new</span> HashMap&lt;Integer, String&gt;();</span><br><span class="line">        <span class="comment">// 添加键值对</span></span><br><span class="line">        Sites.put(<span class="number">1</span>, <span class="string">&quot;Google&quot;</span>);</span><br><span class="line">        Sites.put(<span class="number">2</span>, <span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">        Sites.put(<span class="number">3</span>, <span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">        Sites.put(<span class="number">4</span>, <span class="string">&quot;Zhihu&quot;</span>);</span><br><span class="line">        System.out.println(Sites);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：&#123;1=Google, 2=Runoob, 3=Taobao, 4=Zhihu&#125;</span></span><br></pre></td></tr></table></figure><h6 id="5、常用方法："><a href="#5、常用方法：" class="headerlink" title="5、常用方法："></a>5、常用方法：</h6><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/java/java-hashmap-clear.html">clear()</a></td><td>删除 hashMap 中的所有键/值对</td></tr><tr><td><a href="https://www.runoob.com/java/java-hashmap-clone.html">clone()</a></td><td>复制一份 hashMap</td></tr><tr><td><a href="https://www.runoob.com/java/java-hashmap-isempty.html">isEmpty()</a></td><td>判断 hashMap 是否为空</td></tr><tr><td><a href="https://www.runoob.com/java/java-hashmap-size.html">size()</a></td><td>计算 hashMap 中键/值对的数量</td></tr><tr><td><a href="https://www.runoob.com/java/java-hashmap-put.html">put()</a></td><td>将键/值对添加到 hashMap 中</td></tr><tr><td><a href="https://www.runoob.com/java/java-hashmap-remove.html">remove()</a></td><td>删除 hashMap 中指定键 key 的映射关系</td></tr><tr><td><a href="https://www.runoob.com/java/java-hashmap-replace.html">replace()</a></td><td>替换 hashMap 中是指定的 key 对应的 value。</td></tr><tr><td><a href="https://www.runoob.com/java/java-hashmap-get.html">get()</a></td><td>获取指定 key 对应对 value</td></tr><tr><td><a href="https://www.runoob.com/java/java-hashmap-entryset.html">entrySet()</a></td><td>返回 hashMap 中所有映射项的集合集合视图。</td></tr><tr><td><a href="https://www.runoob.com/java/java-hashmap-keyset.html">keySet</a>()</td><td>返回 hashMap 中所有 key 组成的集合视图。</td></tr><tr><td><a href="https://www.runoob.com/java/java-hashmap-values.html">values()</a></td><td>返回 hashMap 中存在的所有 value 值。</td></tr></tbody></table><p><a href="https://www.runoob.com/java/java-hashmap.html">参考文章</a></p><h4 id="六、Hashcode方法与equals方法"><a href="#六、Hashcode方法与equals方法" class="headerlink" title="六、Hashcode方法与equals方法"></a>六、Hashcode方法与equals方法</h4><h5 id="（一）、hashcode是什么？"><a href="#（一）、hashcode是什么？" class="headerlink" title="（一）、hashcode是什么？"></a>（一）、hashcode是什么？</h5><h6 id="1、hash和hash表是什么"><a href="#1、hash和hash表是什么" class="headerlink" title="1、hash和hash表是什么"></a>1、hash和hash表是什么</h6><p>hash是一个函数，该函数中的实现就是一种算法，就是通过一系列的算法来得到一个hash值。这个时候，我们就需要知道另一个东西，hash表，通过hash算法得到的hash值就在这张hash表中，也就是说，hash表就是所有的hash值组成的，有很多种hash函数，也就代表着有很多种算法得到hash值</p><h6 id="2、hashcode"><a href="#2、hashcode" class="headerlink" title="2、hashcode"></a>2、hashcode</h6><p>hashcode就是通过hash函数得来的，通俗的说，就是通过某一种算法得到的，hashcode就是在hash表中有对应的位置。</p><p><strong>每个对象都有hashcode，对象的hashcode怎么得来的呢？</strong></p><p>首先一个对象肯定有物理地址，对象的物理地址跟这个hashcode地址不一样，<strong>hashcode代表对象的地址说的是对象在hash表中的位置，物理地址说的对象存放在内存中的地址</strong></p><p>通过对象的内部地址(也就是物理地址)转换成一个整数，然后该整数通过hash函数的算法就得到了hashcode。<strong>所以，hashcode就是在hash表中对应的位置。</strong></p><p>举个例子，hash表中有 hashcode为1、hashcode为2、(…)3、4、5、6、7、8这样八个位置，有一个对象A，A的物理地址转换为一个整数17(这是假如)，就通过直接取余算法，17%8=1，那么A的hashcode就为1，且A就在hash表中1的位置。</p><h5 id="（二）、hashcode有什么作用"><a href="#（二）、hashcode有什么作用" class="headerlink" title="（二）、hashcode有什么作用"></a>（二）、hashcode有什么作用</h5><p><strong>HashCode的存在主要是为了查找的快捷性，HashCode是用来在散列存储结构中确定对象的存储地址的(后半句说的用hashcode来代表对象就是在hash表中的位置)</strong></p><p>比如：我们有一个能存放1000个数这样大的内存中，在其中要存放1000个不一样的数字，用最笨的方法，就是存一个数字，就遍历一遍，看有没有相同得数，当存了900个数字，开始存901个数字的时候，就需要跟900个数字进行对比，这样就很麻烦，很是消耗时间，用hashcode来记录对象的位置，来看一下。</p><p>hash表中有1、2、3、4、5、6、7、8个位置，存第一个数，hashcode为1，该数就放在hash表中1的位置，存到100个数字，hash表中8个位置会有很多数字了，1中可能有20个数字，存101个数字时，他先查hashcode值对应的位置，假设为1，那么就有20个数字和他的hashcode相同，他只需要跟这20个数字相比较(equals)，如果每一个相同，那么就放在1这个位置，这样比较的次数就少了很多，实际上hash表中有很多位置，这里只是举例只有8个，实际上，如果hash表很大，那么比较的次数就很少很少了。</p><p><strong><em>！！！值如果相等那么hashcode一定相等，所以先比较hashcode再用equals方法比较</em></strong></p><h5 id="（三）、equals方法和hashcode的关系"><a href="#（三）、equals方法和hashcode的关系" class="headerlink" title="（三）、equals方法和hashcode的关系"></a>（三）、equals方法和hashcode的关系</h5><p>通过前面这个例子，大概可以知道，先通过hashcode来比较，如果hashcode相等，那么就用equals方法来比较两个对象是否相等。</p><p>用个例子说明：上面说的hash表中的8个位置，就好比8个桶，每个桶里能装很多的对象，对象A通过hash函数算法得到将它放到1号桶中，当然肯定有别的对象也会放到1号桶中，如果对象B也通过算法分到了1号桶，那么它如何识别桶中其他对象是否和它一样呢，这时候就需要equals方法来进行筛选了。</p><p>1、如果两个对象equals相等，那么这两个对象的HashCode一定也相同</p><p>2、如果两个对象的HashCode相同，不代表两个对象就相同，只能说明这两个对象在散列存储结构中，存放于同一个位置</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-集合框架&quot;&gt;&lt;a href=&quot;#Java-集合框架&quot; class=&quot;headerlink&quot; title=&quot;Java 集合框架&quot;&gt;&lt;/a&gt;Java 集合框架&lt;/h1&gt;&lt;p&gt;&lt;img src= &quot;/img/loading.gif&quot; data-lazy-src</summary>
      
    
    
    
    <category term="Java" scheme="https://cddorz.github.io/categories/Java/"/>
    
    
    <category term="总结" scheme="https://cddorz.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>青鸢面基大会</title>
    <link href="https://cddorz.github.io/2020/10/31/%E9%9D%92%E9%B8%A2%E9%9D%A2%E5%9F%BA%E5%A4%A7%E4%BC%9A/"/>
    <id>https://cddorz.github.io/2020/10/31/%E9%9D%92%E9%B8%A2%E9%9D%A2%E5%9F%BA%E5%A4%A7%E4%BC%9A/</id>
    <published>2020-10-31T13:32:30.000Z</published>
    <updated>2020-11-13T11:40:20.137Z</updated>
    
    <content type="html"><![CDATA[<h2 id="青鸢面基大会"><a href="#青鸢面基大会" class="headerlink" title="青鸢面基大会"></a>青鸢面基大会</h2><h4 id="10-30青鸢工作室面基大会。西安电子科技大学青鸢工作室nb！"><a href="#10-30青鸢工作室面基大会。西安电子科技大学青鸢工作室nb！" class="headerlink" title="10.30青鸢工作室面基大会。西安电子科技大学青鸢工作室nb！"></a>10.30青鸢工作室面基大会。西安电子科技大学青鸢工作室nb！</h4><p>18：30——19：00是学长树总给大家说一下工作室的代码规范。</p><p>​    之后的聚餐才是真正的重点！因为有美团大四工作学长和字节大三实习学长来和我们一起聊天。</p><p>虽然一开始大家都不是很熟悉的时候，没聊啥，但随着学长们分享去大场工作的经验，大家的兴趣也都提了起来，对大厂有抑制不住的幻想hhhhh，也了解到很多的神。</p><p>​    感觉这次聚餐之后，对字节有了更多的期望，一人一导师的制度真的感觉很好，然后在知乎上看到在字节成长度会真的很高，所有现阶段目标就是为了字节而努力，那个大三学长也是十月份才开始觉醒。</p><p>​    就感觉对未来充满了希望和有了目标吧。qwq。</p><hr><p><strong>2020.11.12更新</strong>：也算是对业务有了最基本的了解，也写了几个功能，回头看到了学长给的建议，还是想写下来: </p><p><strong>首先：面试的准备工作</strong></p><p>1、去字节招聘网站，搜索日常实习生，找java 岗位要求，多看几个岗位要求，大概就知道现在大厂要求你干嘛了，然后再根据你不会的 去针对学习。</p><p>2、背高频面试题</p><p><u><strong>其次，是坚持二字尤为重要！！</strong></u></p><p><strong>最后，学习的路</strong></p><p>工作室的业务，做一两个来练手，熟悉基本流程，更重要的是自己扎实基础，找找项目难点，寻找优化点，做的时候多想一点，不是单纯为了做功能而做，多思考为什么要这样做。</p><hr><p><a href="https://www.huxiu.com/article/267100.html">阿里云的这群疯子</a></p><p>希望大家看到的都能花一点时间去看看这篇文章。，文采不足就用其中的几句话来概括我的感受：</p><p><strong>创业维艰，唯有曾和死神擦肩而过的人，余生才会用十倍的速度奔跑。</strong></p><p><strong>认输，你才真的输了。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;青鸢面基大会&quot;&gt;&lt;a href=&quot;#青鸢面基大会&quot; class=&quot;headerlink&quot; title=&quot;青鸢面基大会&quot;&gt;&lt;/a&gt;青鸢面基大会&lt;/h2&gt;&lt;h4 id=&quot;10-30青鸢工作室面基大会。西安电子科技大学青鸢工作室nb！&quot;&gt;&lt;a href=&quot;#10-30青</summary>
      
    
    
    
    <category term="随笔" scheme="https://cddorz.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="总结" scheme="https://cddorz.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>一天的心得</title>
    <link href="https://cddorz.github.io/2020/10/29/%E4%B8%80%E5%A4%A9%E7%9A%84%E5%BF%83%E5%BE%97/"/>
    <id>https://cddorz.github.io/2020/10/29/%E4%B8%80%E5%A4%A9%E7%9A%84%E5%BF%83%E5%BE%97/</id>
    <published>2020-10-29T08:57:59.000Z</published>
    <updated>2021-01-12T05:08:12.622Z</updated>
    
    <content type="html"><![CDATA[<h3 id="First-step"><a href="#First-step" class="headerlink" title="First step"></a>First step</h3><p>​    一个晚上和一个白天的成果，初步搭建好了自己的博客，虽然挺累的，也算是走出舒适圈的第一步了，也第一次体验到了找bug的痛苦！！！</p><p>​    总结一下今天遇到的问题，希望可以帮助到同样有这些问题的人：</p><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>​        1)、如果遇到你改了某个地方之后，登录你部属的网站发现十个空网站，那么问题应该是你_config.yml文件某个部署错了，可以先本地运行一下然后看看报错（今天问的一个巨佬，orz）。</p><p>​        2)、部署新东西或之后：</p><p>​                    所在文件夹用git命令：hexo g   hexo d</p><p>​        3)、hexo clean万能的命令，有时候刷新不出来新内容可以等到或者hexo clean。可以先在本地看看效果，如果本地效果出来了，那么就只是时间问题啦。</p><p>呜呜呜，第一篇blog，markdown很多语法还不熟悉，所以就先这样吧，害，以后会变得更强的！</p><p><em>少年鲜衣怒马， 不负韶华！！！！</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;First-step&quot;&gt;&lt;a href=&quot;#First-step&quot; class=&quot;headerlink&quot; title=&quot;First step&quot;&gt;&lt;/a&gt;First step&lt;/h3&gt;&lt;p&gt;​    一个晚上和一个白天的成果，初步搭建好了自己的博客，虽然挺累的，也算</summary>
      
    
    
    
    <category term="日常" scheme="https://cddorz.github.io/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="总结" scheme="https://cddorz.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
</feed>

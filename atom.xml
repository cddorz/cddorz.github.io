<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HLY-Blog</title>
  
  <subtitle>少年应与平庸相斥</subtitle>
  <link href="https://cddorz.github.io/atom.xml" rel="self"/>
  
  <link href="https://cddorz.github.io/"/>
  <updated>2020-11-14T15:49:21.509Z</updated>
  <id>https://cddorz.github.io/</id>
  
  <author>
    <name>HLY</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux相关</title>
    <link href="https://cddorz.github.io/2020/11/14/Linux%E7%9B%B8%E5%85%B3/"/>
    <id>https://cddorz.github.io/2020/11/14/Linux%E7%9B%B8%E5%85%B3/</id>
    <published>2020-11-14T15:46:13.000Z</published>
    <updated>2020-11-14T15:49:21.509Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>系统目录结构</p></blockquote><p>登录系统后，在当前命令窗口下输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls &#x2F;</span><br></pre></td></tr></table></figure><p>你会看到如下图所示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LDkhrDl4H9TqZhwyeNSeaNSvqpApZkrQNCQFhVhyPoPdtFTibRBEssIj6EmiapgETvK2brVhfliaRRg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>树状目录结构：（Linux的一切资源都挂载在这个 / 根节点下）</p><p><img src= "/img/loading.gif" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LDkhrDl4H9TqZhwyeNSeaNibQYW2xbQIL38lrCCSPEzFKJhCiau0FvQMFSa37NQxTTbbo3PrpjJic5g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p><strong>以下是对这些目录的解释：</strong></p><ul><li><strong>/bin</strong>：bin是Binary的缩写, 这个目录存放着最经常使用的命令。</li><li><strong>/boot：</strong> 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</li><li><strong>/dev ：</strong> dev是Device(设备)的缩写, 存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。</li><li><strong>/etc：</strong> 这个目录用来存放所有的系统管理所需要的配置文件和子目录。</li><li><strong>/home</strong>：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</li><li><strong>/lib</strong>：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。</li><li><strong>/lost+found</strong>：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</li><li><strong>/media</strong>：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</li><li><strong>/mnt</strong>：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。</li><li><strong>/opt</strong>：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</li><li><strong>/proc</strong>：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。</li><li><strong>/root</strong>：该目录为系统管理员，也称作超级权限者的用户主目录。</li><li><strong>/sbin</strong>：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</li><li><strong>/srv</strong>：该目录存放一些服务启动之后需要提取的数据。</li><li><strong>/sys</strong>：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。</li><li><strong>/tmp</strong>：这个目录是用来存放一些临时文件的。</li><li><strong>/usr</strong>：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。</li><li><strong>/usr/bin：</strong> 系统用户使用的应用程序。</li><li><strong>/usr/sbin：</strong> 超级用户使用的比较高级的管理程序和系统守护程序。</li><li><strong>/usr/src：</strong> 内核源代码默认的放置目录。</li><li><strong>/var</strong>：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</li><li><strong>/run</strong>：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。</li></ul><h3 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h3><blockquote><p>绝对路径和相对路径</p></blockquote><p>我们知道Linux的目录结构为树状结构，最顶级的目录为根目录 /。</p><p>其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。</p><p>在开始本教程前我们需要先知道什么是绝对路径与相对路径。</p><p><strong>绝对路径：</strong></p><p>路径的写法，由根目录 / 写起，例如：/usr/share/doc 这个目录。</p><p><strong>相对路径：</strong></p><p>路径的写法，不是由 / 写起，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成：cd ../man 这就是相对路径的写法啦！</p><blockquote><p>处理目录的常用命令</p></blockquote><p>接下来我们就来看几个常见的处理目录的命令吧：</p><ul><li>ls: 列出目录</li><li>cd：切换目录</li><li>pwd：显示目前的目录</li><li>mkdir：创建一个新的目录</li><li>rmdir：删除一个空的目录</li><li>cp: 复制文件或目录</li><li>rm: 移除文件或目录</li><li>mv: 移动文件与目录，或修改文件与目录的名称</li></ul><p>你可以使用 <em>man [命令]</em> 来查看各个命令的使用文档，如 ：man cp。</p><blockquote><p>ls （列出目录）</p></blockquote><p>在Linux系统当中， ls 命令可能是最常被运行的。</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# ls [-aAdfFhilnrRSt] 目录名称</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)</li><li>-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)</li></ul><p>将目录下的所有文件列出来(含属性与隐藏档)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# ls -al ~</span><br></pre></td></tr></table></figure><blockquote><p>cd （切换目录）</p></blockquote><p>cd是Change Directory的缩写，这是用来变换工作目录的命令。</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd [相对路径或绝对路径]</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 切换到用户目录下</span><br><span class="line">[root@kuangshen &#x2F;]# cd home  </span><br><span class="line"></span><br><span class="line"># 使用 mkdir 命令创建 kuangstudy 目录</span><br><span class="line">[root@kuangshen home]# mkdir kuangstudy</span><br><span class="line"></span><br><span class="line"># 进入 kuangstudy 目录</span><br><span class="line">[root@kuangshen home]# cd kuangstudy</span><br><span class="line"></span><br><span class="line"># 回到上一级</span><br><span class="line">[root@kuangshen kuangstudy]# cd ..</span><br><span class="line"></span><br><span class="line"># 回到根目录</span><br><span class="line">[root@kuangshen kuangstudy]# cd &#x2F;</span><br><span class="line"></span><br><span class="line"># 表示回到自己的家目录，亦即是 &#x2F;root 这个目录</span><br><span class="line">[root@kuangshen kuangstudy]# cd ~</span><br></pre></td></tr></table></figure><p>接下来大家多操作几次应该就可以很好的理解 cd 命令的。</p><blockquote><p>pwd ( 显示目前所在的目录 )</p></blockquote><p>pwd 是 <strong>Print Working Directory</strong> 的缩写，也就是显示目前所在目录的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@kuangshen kuangstudy]#pwd [-P]</span><br></pre></td></tr></table></figure><p>选项与参数：**-P** ：显示出确实的路径，而非使用连接(link) 路径。</p><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 单纯显示出目前的工作目录</span><br><span class="line">[root@kuangshen ~]# pwd</span><br><span class="line">&#x2F;root</span><br><span class="line"></span><br><span class="line"># 如果是链接，要显示真实地址，可以使用 -P参数</span><br><span class="line">[root@kuangshen &#x2F;]# cd bin</span><br><span class="line">[root@kuangshen bin]# pwd -P</span><br><span class="line">&#x2F;usr&#x2F;bin</span><br></pre></td></tr></table></figure><blockquote><p>mkdir （创建新目录）</p></blockquote><p>如果想要创建新的目录的话，那么就使用mkdir (make directory)吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir [-mp] 目录名称</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～</li><li>-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！</li></ul><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 进入我们用户目录下</span><br><span class="line">[root@kuangshen &#x2F;]# cd &#x2F;home</span><br><span class="line"></span><br><span class="line"># 创建一个 test 文件夹</span><br><span class="line">[root@kuangshen home]# mkdir test</span><br><span class="line"></span><br><span class="line"># 创建多层级目录</span><br><span class="line">[root@kuangshen home]# mkdir test1&#x2F;test2&#x2F;test3&#x2F;test4</span><br><span class="line">mkdir: cannot create directory ‘test1&#x2F;test2&#x2F;test3&#x2F;test4’:</span><br><span class="line">No such file or directory  # &lt;&#x3D;&#x3D; 没办法直接创建此目录啊！</span><br><span class="line"></span><br><span class="line"># 加了这个 -p 的选项，可以自行帮你创建多层目录！</span><br><span class="line">[root@kuangshen home]# mkdir -p test1&#x2F;test2&#x2F;test3&#x2F;test4</span><br><span class="line"></span><br><span class="line"># 创建权限为 rwx--x--x 的目录。</span><br><span class="line">[root@kuangshen home]# mkdir -m 711 test2</span><br><span class="line">[root@kuangshen home]# ls -l</span><br><span class="line">drwxr-xr-x 2 root root  4096 Mar 12 21:55 test</span><br><span class="line">drwxr-xr-x 3 root root  4096 Mar 12 21:56 test1</span><br><span class="line">drwx--x--x 2 root root  4096 Mar 12 21:58 test2</span><br></pre></td></tr></table></figure><blockquote><p>rmdir ( 删除空的目录 )</p></blockquote><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir [-p] 目录名称</span><br></pre></td></tr></table></figure><p>选项与参数：**-p ：**连同上一级『空的』目录也一起删除</p><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 看看有多少目录存在？</span><br><span class="line">[root@kuangshen home]# ls -l</span><br><span class="line">drwxr-xr-x 2 root root  4096 Mar 12 21:55 test</span><br><span class="line">drwxr-xr-x 3 root root  4096 Mar 12 21:56 test1</span><br><span class="line">drwx--x--x 2 root root  4096 Mar 12 21:58 test2</span><br><span class="line"></span><br><span class="line"># 可直接删除掉，没问题</span><br><span class="line">[root@kuangshen home]# rmdir test</span><br><span class="line"></span><br><span class="line"># 因为尚有内容，所以无法删除！</span><br><span class="line">[root@kuangshen home]# rmdir test1</span><br><span class="line">rmdir: failed to remove ‘test1’: Directory not empty</span><br><span class="line"></span><br><span class="line"># 利用 -p 这个选项，立刻就可以将 test1&#x2F;test2&#x2F;test3&#x2F;test4 依次删除。</span><br><span class="line">[root@kuangshen home]# rmdir -p test1&#x2F;test2&#x2F;test3&#x2F;test4</span><br></pre></td></tr></table></figure><p>注意：这个 rmdir 仅能删除空的目录，你可以使用 rm 命令来删除非空目录，后面我们会将！</p><blockquote><p>cp ( 复制文件或目录 )</p></blockquote><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination)</span><br><span class="line">[root@www ~]# cp [options] source1 source2 source3 .... directory</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li><strong>-a：</strong>相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)</li><li><strong>-p：</strong>连同文件的属性一起复制过去，而非使用默认属性(备份常用)；</li><li><strong>-d：</strong>若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；</li><li><strong>-r：</strong>递归持续复制，用於目录的复制行为；(常用)</li><li><strong>-f：</strong>为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；</li><li><strong>-i：</strong>若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</li><li><strong>-l：</strong>进行硬式连结(hard link)的连结档创建，而非复制文件本身。</li><li><strong>-s：</strong>复制成为符号连结档 (symbolic link)，亦即『捷径』文件；</li><li><strong>-u：</strong>若 destination 比 source 旧才升级 destination ！</li></ul><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 找一个有文件的目录，我这里找到 root目录</span><br><span class="line">[root@kuangshen home]# cd &#x2F;root</span><br><span class="line">[root@kuangshen ~]# ls</span><br><span class="line">install.sh</span><br><span class="line">[root@kuangshen ~]# cd &#x2F;home</span><br><span class="line"></span><br><span class="line"># 复制 root目录下的install.sh 到 home目录下</span><br><span class="line">[root@kuangshen home]# cp &#x2F;root&#x2F;install.sh &#x2F;home</span><br><span class="line">[root@kuangshen home]# ls</span><br><span class="line">install.sh</span><br><span class="line"></span><br><span class="line"># 再次复制，加上-i参数，增加覆盖询问？</span><br><span class="line">[root@kuangshen home]# cp -i &#x2F;root&#x2F;install.sh &#x2F;home</span><br><span class="line">cp: overwrite ‘&#x2F;home&#x2F;install.sh’? y # n不覆盖，y为覆盖</span><br></pre></td></tr></table></figure><blockquote><p>rm ( 移除文件或目录 )</p></blockquote><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm [-fir] 文件或目录</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；</li><li>-i ：互动模式，在删除前会询问使用者是否动作</li><li>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！</li></ul><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 将刚刚在 cp 的实例中创建的 install.sh删除掉！</span><br><span class="line">[root@kuangshen home]# rm -i install.sh</span><br><span class="line">rm: remove regular file ‘install.sh’? y</span><br><span class="line"># 如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！</span><br><span class="line"></span><br><span class="line"># 尽量不要在服务器上使用 rm -rf &#x2F;</span><br></pre></td></tr></table></figure><blockquote><p>mv  ( 移动文件与目录，或修改名称 )</p></blockquote><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# mv [-fiu] source destination</span><br><span class="line">[root@www ~]# mv [options] source1 source2 source3 .... directory</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li><li>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！</li><li>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</li></ul><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 复制一个文件到当前目录</span><br><span class="line">[root@kuangshen home]# cp &#x2F;root&#x2F;install.sh &#x2F;home</span><br><span class="line"></span><br><span class="line"># 创建一个文件夹 test</span><br><span class="line">[root@kuangshen home]# mkdir test</span><br><span class="line"></span><br><span class="line"># 将复制过来的文件移动到我们创建的目录，并查看</span><br><span class="line">[root@kuangshen home]# mv install.sh test</span><br><span class="line">[root@kuangshen home]# ls</span><br><span class="line">test</span><br><span class="line">[root@kuangshen home]# cd test</span><br><span class="line">[root@kuangshen test]# ls</span><br><span class="line">install.sh</span><br><span class="line"></span><br><span class="line"># 将文件夹重命名，然后再次查看！</span><br><span class="line">[root@kuangshen test]# cd ..</span><br><span class="line">[root@kuangshen home]# mv test mvtest</span><br><span class="line">[root@kuangshen home]# ls</span><br><span class="line">mvtest</span><br></pre></td></tr></table></figure><h3 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h3><blockquote><p>看懂文件属性</p></blockquote><p>Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。</p><p>在Linux中我们可以使用<code>ll</code>或者<code>ls –l</code>命令来显示一个文件的属性以及文件所属的用户和组，如：</p><p><img src= "/img/loading.gif" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JGpeIS4j9q3B4LQhsQkFiauXAQN0qOnVCYvj7Cm1oQbvexVDFqPhUIeTe83BdAHlXCJhGoNabSFKQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>实例中，boot文件的第一个属性用”d”表示。”d”在Linux中代表该文件是一个目录文件。</p><p>在Linux中第一个字符代表这个文件是目录、文件或链接文件等等：</p><ul><li>当为[ <strong>d</strong> ]则是目录</li><li>当为[ <strong>-</strong> ]则是文件；</li><li>若是[ <strong>l</strong> ]则表示为链接文档 ( link file )；</li><li>若是[ <strong>b</strong> ]则表示为装置文件里面的可供储存的接口设备 ( 可随机存取装置 )；</li><li>若是[ <strong>c</strong> ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )。</li></ul><p>接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。</p><p>其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。</p><p>要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。</p><p>每个文件的属性由左边第一部分的10个字符来确定（如下图）：</p><p><img src= "/img/loading.gif" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JGpeIS4j9q3B4LQhsQkFiauEybzG2XIdlOMLyO13lMfPKUWRpGJGgyxCAJ9mics9dTZ1qrWDIvleYQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>从左至右用0-9这些数字来表示。</p><p>第0位确定文件类型，第1-3位确定属主（该文件的所有者）拥有该文件的权限。第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。</p><p>其中：</p><p>第1、4、7位表示读权限，如果用”r”字符表示，则有读权限，如果用”-“字符表示，则没有读权限；</p><p>第2、5、8位表示写权限，如果用”w”字符表示，则有写权限，如果用”-“字符表示没有写权限；</p><p>第3、6、9位表示可执行权限，如果用”x”字符表示，则有执行权限，如果用”-“字符表示，则没有执行权限。</p><p>对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。</p><p>同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。</p><p>文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。</p><p>因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。</p><p>在以上实例中，boot 文件是一个目录文件，属主和属组都为 root。</p><blockquote><p>修改文件属性</p></blockquote><p><strong>1、chgrp：更改文件属组</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp [-R] 属组名 文件名</span><br></pre></td></tr></table></figure><p>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</p><p><strong>2、chown：更改文件属主，也可以同时更改文件属组</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown [–R] 属主名 文件名</span><br><span class="line">chown [-R] 属主名：属组名 文件名</span><br></pre></td></tr></table></figure><p><strong>3、chmod：更改文件9个属性</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [-R] xyz 文件或目录</span><br></pre></td></tr></table></figure><p>Linux文件属性有两种设置方法，一种是数字，一种是符号。</p><p>Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。</p><p>先复习一下刚刚上面提到的数据：文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r:4     w:2         x:1</span><br></pre></td></tr></table></figure><p>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为：[-rwxrwx—] 分数则是：</p><ul><li>owner = rwx = 4+2+1 = 7</li><li>group = rwx = 4+2+1 = 7</li><li>others= — = 0+0+0 = 0</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 770 filename</span><br></pre></td></tr></table></figure><p>可以自己下去多进行测试！</p><h3 id="文件内容查看"><a href="#文件内容查看" class="headerlink" title="文件内容查看"></a>文件内容查看</h3><blockquote><p>概述</p></blockquote><p>Linux系统中使用以下命令来查看文件的内容：</p><ul><li>cat 由第一行开始显示文件内容</li><li>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</li><li>nl  显示的时候，顺道输出行号！</li><li>more 一页一页的显示文件内容</li><li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！</li><li>head 只看头几行</li><li>tail 只看尾巴几行</li></ul><p>你可以使用 *man [命令]*来查看各个命令的使用文档，如 ：man cp。</p><blockquote><p>cat 由第一行开始显示文件内容</p></blockquote><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat [-AbEnTv]</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</li><li>-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！</li><li>-E ：将结尾的断行字节 $ 显示出来；</li><li>-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；</li><li>-T ：将 [tab] 按键以 ^I 显示出来；</li><li>-v ：列出一些看不出来的特殊字符</li></ul><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查看网络配置: 文件地址 &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;</span><br><span class="line">[root@kuangshen ~]# cat &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth0</span><br><span class="line">DEVICE&#x3D;eth0</span><br><span class="line">BOOTPROTO&#x3D;dhcp</span><br><span class="line">ONBOOT&#x3D;yes</span><br></pre></td></tr></table></figure><blockquote><p>tac</p></blockquote><p>tac与cat命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@kuangshen ~]# tac &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth0</span><br><span class="line">ONBOOT&#x3D;yes</span><br><span class="line">BOOTPROTO&#x3D;dhcp</span><br><span class="line">DEVICE&#x3D;eth0</span><br></pre></td></tr></table></figure><blockquote><p>nl  显示行号</p></blockquote><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nl [-bnw] 文件</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-b ：指定行号指定的方式，主要有两种：-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；-b t ：如果有空行，空的那一行不要列出行号(默认值)；</li><li>-n ：列出行号表示的方法，主要有三种：-n ln ：行号在荧幕的最左方显示；-n rn ：行号在自己栏位的最右方显示，且不加 0 ；-n rz ：行号在自己栏位的最右方显示，且加 0 ；</li><li>-w ：行号栏位的占用的位数。</li></ul><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@kuangshen ~]# nl &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth0</span><br><span class="line">1DEVICE&#x3D;eth0</span><br><span class="line">2BOOTPROTO&#x3D;dhcp</span><br><span class="line">3ONBOOT&#x3D;yes</span><br></pre></td></tr></table></figure><blockquote><p>more  一页一页翻动</p></blockquote><p>在 more 这个程序的运行过程中，你有几个按键可以按的：</p><ul><li>空白键 (space)：代表向下翻一页；</li><li>Enter   ：代表向下翻『一行』；</li><li>/字串   ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；</li><li>:f    ：立刻显示出档名以及目前显示的行数；</li><li>q    ：代表立刻离开 more ，不再显示该文件内容。</li><li>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@kuangshen etc]# more &#x2F;etc&#x2F;csh.login</span><br><span class="line">....(中间省略)....</span><br><span class="line">--More--(28%) # 重点在这一行喔！你的光标也会在这里等待你的命令</span><br></pre></td></tr></table></figure><blockquote><p>less  一页一页翻动，以下实例输出/etc/man.config文件的内容：</p></blockquote><p>less运行时可以输入的命令有：</p><ul><li>空白键  ：向下翻动一页；</li><li>[pagedown]：向下翻动一页；</li><li>[pageup] ：向上翻动一页；</li><li>/字串  ：向下搜寻『字串』的功能；</li><li>?字串  ：向上搜寻『字串』的功能；</li><li>n   ：重复前一个搜寻 (与 / 或 ? 有关！)</li><li>N   ：反向的重复前一个搜寻 (与 / 或 ? 有关！)</li><li>q   ：离开 less 这个程序；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@kuangshen etc]# more &#x2F;etc&#x2F;csh.login</span><br><span class="line">....(中间省略)....</span><br><span class="line">:   # 这里可以等待你输入命令！</span><br></pre></td></tr></table></figure><blockquote><p>head  取出文件前面几行</p></blockquote><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head [-n number] 文件</span><br></pre></td></tr></table></figure><p>选项与参数：**-n** 后面接数字，代表显示几行的意思！</p><p>默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@kuangshen etc]# head -n 20 &#x2F;etc&#x2F;csh.login</span><br></pre></td></tr></table></figure><blockquote><p>tail  取出文件后面几行</p></blockquote><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail [-n number] 文件</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-n ：后面接数字，代表显示几行的意思</li></ul><p>默认的情况中，显示最后 10 行！若要显示最后 20 行，就得要这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@kuangshen etc]# tail -n 20 &#x2F;etc&#x2F;csh.login</span><br></pre></td></tr></table></figure><blockquote><p>拓展：Linux 链接概念</p></blockquote><p>Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。</p><p>情况下，<strong>ln</strong> 命令产生硬链接。</p><p><strong>硬连接</strong></p><p>硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。</p><p>硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</p><p><strong>软连接</strong></p><p>另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。</p><p><strong>测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@kuangshen &#x2F;]# cd &#x2F;home</span><br><span class="line">[root@kuangshen home]# touch f1 # 创建一个测试文件f1</span><br><span class="line">[root@kuangshen home]# ls</span><br><span class="line">f1</span><br><span class="line">[root@kuangshen home]# ln f1 f2     # 创建f1的一个硬连接文件f2</span><br><span class="line">[root@kuangshen home]# ln -s f1 f3   # 创建f1的一个符号连接文件f3</span><br><span class="line">[root@kuangshen home]# ls -li       # -i参数显示文件的inode节点信息</span><br><span class="line">397247 -rw-r--r-- 2 root root     0 Mar 13 00:50 f1</span><br><span class="line">397247 -rw-r--r-- 2 root root     0 Mar 13 00:50 f2</span><br><span class="line">397248 lrwxrwxrwx 1 root root     2 Mar 13 00:50 f3 -&gt; f1</span><br></pre></td></tr></table></figure><p>从上面的结果中可以看出，硬连接文件 f2 与原文件 f1 的 inode 节点相同，均为 397247，然而符号连接文件的 inode 节点不同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># echo 字符串输出 &gt;&gt; f1 输出到 f1文件</span><br><span class="line">[root@kuangshen home]# echo &quot;I am f1 file&quot; &gt;&gt;f1</span><br><span class="line">[root@kuangshen home]# cat f1</span><br><span class="line">I am f1 file</span><br><span class="line">[root@kuangshen home]# cat f2</span><br><span class="line">I am f1 file</span><br><span class="line">[root@kuangshen home]# cat f3</span><br><span class="line">I am f1 file</span><br><span class="line">[root@kuangshen home]# rm -f f1</span><br><span class="line">[root@kuangshen home]# cat f2</span><br><span class="line">I am f1 file</span><br><span class="line">[root@kuangshen home]# cat f3</span><br><span class="line">cat: f3: No such file or directory</span><br></pre></td></tr></table></figure><p>通过上面的测试可以看出：当删除原始文件 f1 后，硬连接 f2 不受影响，但是符号连接 f1 文件无效；</p><p>依此您可以做一些相关的测试，可以得到以下全部结论：</p><ul><li>删除符号连接f3,对f1,f2无影响；</li><li>删除硬连接f2，对f1,f3也无影响；</li><li>删除原文件f1，对硬连接f2没有影响，导致符号连接f3失效；</li><li>同时删除原文件f1,硬连接f2，整个文件会真正的被删除。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;系统目录结构&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;登录系统后，在当前命令窗口下输入命令：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span</summary>
      
    
    
    
    <category term="系统" scheme="https://cddorz.github.io/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Linux" scheme="https://cddorz.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis（二）</title>
    <link href="https://cddorz.github.io/2020/11/12/Mybatis%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://cddorz.github.io/2020/11/12/Mybatis%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2020-11-12T04:02:20.000Z</published>
    <updated>2020-11-13T06:56:16.941Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>select</p></blockquote><ul><li><p>select标签是mybatis中最常用的标签之一</p></li><li><p>select语句有很多属性可以详细配置每一条SQL语句</p></li><li><ul><li>SQL语句返回值类型。【完整的类名或者别名】</li><li>传入SQL语句的参数类型 。【万能的Map，可以多尝试使用】</li><li>命名空间中唯一的标识符</li><li>接口中的方法名与映射文件中的SQL语句ID 一一对应</li><li>id</li><li>parameterType</li><li>resultType</li></ul></li></ul><p><strong>需求：根据id查询用户</strong></p><p>1、在UserMapper中添加对应方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface UserMapper &#123;</span><br><span class="line">   &#x2F;&#x2F;查询全部用户</span><br><span class="line">   List&lt;User&gt; selectUser();</span><br><span class="line">   &#x2F;&#x2F;根据id查询用户</span><br><span class="line">   User selectUserById(int id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、在UserMapper.xml中添加Select语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id&#x3D;&quot;selectUserById&quot; resultType&#x3D;&quot;com.kuang.pojo.User&quot;&gt;</span><br><span class="line">select * from user where id &#x3D; #&#123;id&#125;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure><p>3、测试类中测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void tsetSelectUserById() &#123;</span><br><span class="line">   SqlSession session &#x3D; MybatisUtils.getSession();  &#x2F;&#x2F;获取SqlSession连接</span><br><span class="line">   UserMapper mapper &#x3D; session.getMapper(UserMapper.class);</span><br><span class="line">   User user &#x3D; mapper.selectUserById(1);</span><br><span class="line">   System.out.println(user);</span><br><span class="line">   session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>课堂练习</strong>：根据 密码 和 名字 查询用户</p><p>思路一：直接在方法中传递参数</p><p>1、在接口方法的参数前加 @Param属性</p><p>2、Sql语句编写的时候，直接取@Param中设置的值即可，不需要单独设置参数类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;通过密码和名字查询用户</span><br><span class="line">User selectUserByNP(@Param(&quot;username&quot;) String username,@Param(&quot;pwd&quot;) Stringpwd);</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">   &lt;select id&#x3D;&quot;selectUserByNP&quot; resultType&#x3D;&quot;com.kuang.pojo.User&quot;&gt;</span><br><span class="line">     select * from user where name &#x3D; #&#123;username&#125; and pwd &#x3D; #&#123;pwd&#125;</span><br><span class="line">   &lt;&#x2F;select&gt;</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><p>思路二：使用万能的Map</p><p>1、在接口方法中，参数直接传递Map；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User selectUserByNP2(Map&lt;String,Object&gt; map);</span><br></pre></td></tr></table></figure><p>2、编写sql语句的时候，需要传递参数类型，参数类型为map</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id&#x3D;&quot;selectUserByNP2&quot; parameterType&#x3D;&quot;map&quot;resultType&#x3D;&quot;com.kuang.pojo.User&quot;&gt;</span><br><span class="line">select * from user where name &#x3D; #&#123;username&#125; and pwd &#x3D; #&#123;pwd&#125;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure><p>3、在使用方法的时候，Map的 key 为 sql中取的值即可，没有顺序要求！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;String, Object&gt;();</span><br><span class="line">map.put(&quot;username&quot;,&quot;小明&quot;);</span><br><span class="line">map.put(&quot;pwd&quot;,&quot;123456&quot;);</span><br><span class="line">User user &#x3D; mapper.selectUserByNP2(map);</span><br></pre></td></tr></table></figure><p>总结：如果参数过多，我们可以考虑直接使用Map实现，如果参数比较少，直接传递参数即可</p><blockquote><p>insert</p></blockquote><p>我们一般使用insert标签进行插入操作，它的配置和select标签差不多！</p><p><strong>需求：给数据库增加一个用户</strong></p><p>1、在UserMapper接口中添加对应的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;添加一个用户</span><br><span class="line">int addUser(User user);</span><br></pre></td></tr></table></figure><p>2、在UserMapper.xml中添加insert语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id&#x3D;&quot;addUser&quot; parameterType&#x3D;&quot;com.kuang.pojo.User&quot;&gt;</span><br><span class="line">    insert into user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)</span><br><span class="line">&lt;&#x2F;insert&gt;</span><br></pre></td></tr></table></figure><p>3、测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testAddUser() &#123;</span><br><span class="line">   SqlSession session &#x3D; MybatisUtils.getSession();</span><br><span class="line">   UserMapper mapper &#x3D; session.getMapper(UserMapper.class);</span><br><span class="line">   User user &#x3D; new User(5,&quot;王五&quot;,&quot;zxcvbn&quot;);</span><br><span class="line">   int i &#x3D; mapper.addUser(user);</span><br><span class="line">   System.out.println(i);</span><br><span class="line">   session.commit(); &#x2F;&#x2F;提交事务,重点!不写的话不会提交到数据库</span><br><span class="line">   session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意点：增、删、改操作需要提交事务！</strong></p><blockquote><p>update</p></blockquote><p>我们一般使用update标签进行更新操作，它的配置和select标签差不多！</p><p><strong>需求：修改用户的信息</strong></p><p>1、同理，编写接口方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;修改一个用户</span><br><span class="line">int updateUser(User user);</span><br></pre></td></tr></table></figure><p>2、编写对应的配置文件SQL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;update id&#x3D;&quot;updateUser&quot; parameterType&#x3D;&quot;com.kuang.pojo.User&quot;&gt;</span><br><span class="line">  update user set name&#x3D;#&#123;name&#125;,pwd&#x3D;#&#123;pwd&#125; where id &#x3D; #&#123;id&#125;</span><br><span class="line">&lt;&#x2F;update&gt;</span><br></pre></td></tr></table></figure><p>3、测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testUpdateUser() &#123;</span><br><span class="line">   SqlSession session &#x3D; MybatisUtils.getSession();</span><br><span class="line">   UserMapper mapper &#x3D; session.getMapper(UserMapper.class);</span><br><span class="line">   User user &#x3D; mapper.selectUserById(1);</span><br><span class="line">   user.setPwd(&quot;asdfgh&quot;);</span><br><span class="line">   int i &#x3D; mapper.updateUser(user);</span><br><span class="line">   System.out.println(i);</span><br><span class="line">   session.commit(); &#x2F;&#x2F;提交事务,重点!不写的话不会提交到数据库</span><br><span class="line">   session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>delete</p></blockquote><p>我们一般使用delete标签进行删除操作，它的配置和select标签差不多！</p><p><strong>需求：根据id删除一个用户</strong></p><p>1、同理，编写接口方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;根据id删除用户</span><br><span class="line">int deleteUser(int id);</span><br></pre></td></tr></table></figure><p>2、编写对应的配置文件SQL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;delete id&#x3D;&quot;deleteUser&quot; parameterType&#x3D;&quot;int&quot;&gt;</span><br><span class="line">  delete from user where id &#x3D; #&#123;id&#125;</span><br><span class="line">&lt;&#x2F;delete&gt;</span><br></pre></td></tr></table></figure><p>3、测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testDeleteUser() &#123;</span><br><span class="line">   SqlSession session &#x3D; MybatisUtils.getSession();</span><br><span class="line">   UserMapper mapper &#x3D; session.getMapper(UserMapper.class);</span><br><span class="line">   int i &#x3D; mapper.deleteUser(5);</span><br><span class="line">   System.out.println(i);</span><br><span class="line">   session.commit(); &#x2F;&#x2F;提交事务,重点!不写的话不会提交到数据库</span><br><span class="line">   session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>小结：</strong></p><ul><li>所有的增删改操作都需要提交事务！</li><li>接口所有的普通参数，尽量都写上@Param参数，尤其是多个参数时，必须写上！</li><li>有时候根据业务的需求，可以考虑使用map传递参数！</li><li>为了规范操作，在SQL的配置文件中，我们尽量将Parameter参数和resultType都写上！</li></ul><blockquote><p>核心配置文件</p></blockquote><ul><li>mybatis-config.xml 系统核心配置文件</li><li>MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。</li><li>能配置的内容如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">configuration（配置）</span><br><span class="line">properties（属性）</span><br><span class="line">settings（设置）</span><br><span class="line">typeAliases（类型别名）</span><br><span class="line">typeHandlers（类型处理器）</span><br><span class="line">objectFactory（对象工厂）</span><br><span class="line">plugins（插件）</span><br><span class="line">environments（环境配置）</span><br><span class="line">environment（环境变量）</span><br><span class="line">transactionManager（事务管理器）</span><br><span class="line">dataSource（数据源）</span><br><span class="line">databaseIdProvider（数据库厂商标识）</span><br><span class="line">mappers（映射器）</span><br><span class="line">&lt;!-- 注意元素节点的顺序！顺序不对会报错 --&gt;</span><br></pre></td></tr></table></figure><p>我们可以阅读 mybatis-config.xml 上面的dtd的头文件！</p><blockquote><p>environments元素</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;environments default&#x3D;&quot;development&quot;&gt;</span><br><span class="line"> &lt;environment id&#x3D;&quot;development&quot;&gt;</span><br><span class="line">   &lt;transactionManager type&#x3D;&quot;JDBC&quot;&gt;</span><br><span class="line">     &lt;property name&#x3D;&quot;...&quot; value&#x3D;&quot;...&quot;&#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;transactionManager&gt;</span><br><span class="line">   &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;</span><br><span class="line">     &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;$&#123;driver&#125;&quot;&#x2F;&gt;</span><br><span class="line">     &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;url&#125;&quot;&#x2F;&gt;</span><br><span class="line">     &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;username&#125;&quot;&#x2F;&gt;</span><br><span class="line">     &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;password&#125;&quot;&#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;dataSource&gt;</span><br><span class="line"> &lt;&#x2F;environment&gt;</span><br><span class="line">&lt;&#x2F;environments&gt;</span><br></pre></td></tr></table></figure><ul><li><p>配置MyBatis的多套运行环境，将SQL映射到多个不同的数据库上，必须指定其中一个为默认运行环境（通过default指定）</p></li><li><p>子元素节点：<strong>environment</strong></p></li><li><ul><li><p>dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。</p></li><li><p>数据源是必须配置的。</p></li><li><p>有三种内建的数据源类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type&#x3D;&quot;[UNPOOLED|POOLED|JNDI]&quot;）</span><br></pre></td></tr></table></figure></li><li><p>unpooled：这个数据源的实现只是每次被请求时打开和关闭连接。</p></li><li><p><strong>pooled</strong>：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来 , 这是一种使得并发 Web 应用快速响应请求的流行处理方式。</p></li><li><p>jndi：这个数据源的实现是为了能在如 Spring 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。</p></li><li><p>数据源也有很多第三方的实现，比如dbcp，c3p0，druid等等….</p></li></ul></li></ul><ul><li><p>详情：点击查看官方文档</p></li><li><p>这两种事务管理器类型都不需要设置任何属性。</p></li><li><p>具体的一套环境，通过设置id进行区别，id保证唯一！</p></li><li><p>子元素节点：transactionManager - [ 事务管理器 ]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 语法 --&gt;</span><br><span class="line">&lt;transactionManager type&#x3D;&quot;[ JDBC | MANAGED ]&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure></li><li><p>子元素节点：<strong>数据源（dataSource）</strong></p></li></ul><blockquote><p>mappers元素</p></blockquote><p><strong>mappers</strong></p><ul><li>映射器 : 定义映射SQL语句文件</li><li>既然 MyBatis 的行为其他元素已经配置完了，我们现在就要定义 SQL 映射语句了。但是首先我们需要告诉 MyBatis 到哪里去找到这些语句。Java 在自动查找这方面没有提供一个很好的方法，所以最佳的方式是告诉 MyBatis 到哪里去找映射文件。你可以使用相对于类路径的资源引用， 或完全限定资源定位符（包括 <code>file:///</code> 的 URL），或类名和包名等。映射器是MyBatis中最核心的组件之一，在MyBatis 3之前，只支持xml映射器，即：所有的SQL语句都必须在xml文件中配置。而从MyBatis 3开始，还支持接口映射器，这种映射器方式允许以Java代码的方式注解定义SQL语句，非常简洁。</li></ul><p><strong>引入资源方式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用相对于类路径的资源引用 --&gt;</span><br><span class="line">&lt;mappers&gt;</span><br><span class="line"> &lt;mapper resource&#x3D;&quot;org&#x2F;mybatis&#x2F;builder&#x2F;PostMapper.xml&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;mappers&gt;</span><br><span class="line">&lt;!-- 使用完全限定资源定位符（URL） --&gt;</span><br><span class="line">&lt;mappers&gt;</span><br><span class="line"> &lt;mapper url&#x3D;&quot;file:&#x2F;&#x2F;&#x2F;var&#x2F;mappers&#x2F;AuthorMapper.xml&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;mappers&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">使用映射器接口实现类的完全限定类名</span><br><span class="line">需要配置文件名称和接口名称一致，并且位于同一目录下</span><br><span class="line">--&gt;</span><br><span class="line">&lt;mappers&gt;</span><br><span class="line"> &lt;mapper class&#x3D;&quot;org.mybatis.builder.AuthorMapper&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;mappers&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">将包内的映射器接口实现全部注册为映射器</span><br><span class="line">但是需要配置文件名称和接口名称一致，并且位于同一目录下</span><br><span class="line">--&gt;</span><br><span class="line">&lt;mappers&gt;</span><br><span class="line"> &lt;package name&#x3D;&quot;org.mybatis.builder&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;mappers&gt;</span><br></pre></td></tr></table></figure><p><strong>Mapper文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">       PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">       &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace&#x3D;&quot;com.kuang.mapper.UserMapper&quot;&gt;</span><br><span class="line">   </span><br><span class="line">&lt;&#x2F;mapper&gt;</span><br></pre></td></tr></table></figure><ul><li><p>namespace中文意思：命名空间，作用如下：</p></li><li><ul><li>namespace的命名必须跟某个接口同名</li><li>接口中的方法与映射文件中sql语句id应该一一对应</li></ul></li><li><ol><li>namespace和子元素的id联合保证唯一  , 区别不同的mapper</li><li>绑定DAO接口</li><li>namespace命名规则 : 包名+类名</li></ol></li></ul><p>MyBatis 的真正强大在于它的映射语句，这是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis 为聚焦于 SQL 而构建，以尽可能地为你减少麻烦。</p><blockquote><p>Properties优化</p></blockquote><p>数据库这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。具体的官方文档</p><p>我们来优化我们的配置文件</p><p>第一步 ; 在资源目录下新建一个db.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">driver&#x3D;com.mysql.jdbc.Driver</span><br><span class="line">url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis?useSSL&#x3D;true&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8</span><br><span class="line">username&#x3D;root</span><br><span class="line">password&#x3D;123456</span><br></pre></td></tr></table></figure><p>第二步 : 将文件导入properties 配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">   &lt;!--导入properties文件--&gt;</span><br><span class="line">   &lt;properties resource&#x3D;&quot;db.properties&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;environments default&#x3D;&quot;development&quot;&gt;</span><br><span class="line">       &lt;environment id&#x3D;&quot;development&quot;&gt;</span><br><span class="line">           &lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt;</span><br><span class="line">           &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;</span><br><span class="line">               &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;$&#123;driver&#125;&quot;&#x2F;&gt;</span><br><span class="line">               &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;url&#125;&quot;&#x2F;&gt;</span><br><span class="line">               &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;username&#125;&quot;&#x2F;&gt;</span><br><span class="line">               &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;password&#125;&quot;&#x2F;&gt;</span><br><span class="line">           &lt;&#x2F;dataSource&gt;</span><br><span class="line">       &lt;&#x2F;environment&gt;</span><br><span class="line">   &lt;&#x2F;environments&gt;</span><br><span class="line">   &lt;mappers&gt;</span><br><span class="line">       &lt;mapper resource&#x3D;&quot;mapper&#x2F;UserMapper.xml&quot;&#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;mappers&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure><p>更多操作，可以查看官方文档！【演示带领学习】</p><ul><li>配置文件优先级问题</li><li>新特性：使用占位符</li></ul><blockquote><p>typeAliases优化</p></blockquote><p>类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置别名,注意顺序--&gt;</span><br><span class="line">&lt;typeAliases&gt;</span><br><span class="line">   &lt;typeAlias type&#x3D;&quot;com.kuang.pojo.User&quot; alias&#x3D;&quot;User&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;typeAliases&gt;</span><br></pre></td></tr></table></figure><p>当这样配置时，<code>User</code>可以用在任何使用<code>com.kuang.pojo.User</code>的地方。</p><p>也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;typeAliases&gt;</span><br><span class="line">   &lt;package name&#x3D;&quot;com.kuang.pojo&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;typeAliases&gt;</span><br></pre></td></tr></table></figure><p>每一个在包 <code>com.kuang.pojo</code> 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。</p><p>若有注解，则别名为其注解值。见下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Alias(&quot;user&quot;)</span><br><span class="line">public class User &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>去官网查看一下Mybatis默认的一些类型别名！</p><blockquote><p>其他配置浏览</p></blockquote><p><strong>设置</strong></p><ul><li><p>设置（settings）相关 =&gt; 查看帮助文档</p></li><li><ul><li>懒加载</li><li>日志实现</li><li>缓存开启关闭</li></ul></li><li><p>一个配置完整的 settings 元素的示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line"> &lt;setting name&#x3D;&quot;cacheEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line"> &lt;setting name&#x3D;&quot;lazyLoadingEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line"> &lt;setting name&#x3D;&quot;multipleResultSetsEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line"> &lt;setting name&#x3D;&quot;useColumnLabel&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line"> &lt;setting name&#x3D;&quot;useGeneratedKeys&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;</span><br><span class="line"> &lt;setting name&#x3D;&quot;autoMappingBehavior&quot; value&#x3D;&quot;PARTIAL&quot;&#x2F;&gt;</span><br><span class="line"> &lt;setting name&#x3D;&quot;autoMappingUnknownColumnBehavior&quot; value&#x3D;&quot;WARNING&quot;&#x2F;&gt;</span><br><span class="line"> &lt;setting name&#x3D;&quot;defaultExecutorType&quot; value&#x3D;&quot;SIMPLE&quot;&#x2F;&gt;</span><br><span class="line"> &lt;setting name&#x3D;&quot;defaultStatementTimeout&quot; value&#x3D;&quot;25&quot;&#x2F;&gt;</span><br><span class="line"> &lt;setting name&#x3D;&quot;defaultFetchSize&quot; value&#x3D;&quot;100&quot;&#x2F;&gt;</span><br><span class="line"> &lt;setting name&#x3D;&quot;safeRowBoundsEnabled&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;</span><br><span class="line"> &lt;setting name&#x3D;&quot;mapUnderscoreToCamelCase&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;</span><br><span class="line"> &lt;setting name&#x3D;&quot;localCacheScope&quot; value&#x3D;&quot;SESSION&quot;&#x2F;&gt;</span><br><span class="line"> &lt;setting name&#x3D;&quot;jdbcTypeForNull&quot; value&#x3D;&quot;OTHER&quot;&#x2F;&gt;</span><br><span class="line"> &lt;setting name&#x3D;&quot;lazyLoadTriggerMethods&quot; value&#x3D;&quot;equals,clone,hashCode,toString&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;settings&gt;</span><br></pre></td></tr></table></figure></li></ul><p><strong>类型处理器</strong></p><ul><li>无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。</li><li>你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。【了解即可】</li></ul><p><strong>对象工厂</strong></p><ul><li>MyBatis 每次创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成。</li><li>默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通过有参构造方法来实例化。</li><li>如果想覆盖对象工厂的默认行为，则可以通过创建自己的对象工厂来实现。【了解即可】</li></ul><blockquote><p>生命周期和作用域</p></blockquote><p><strong>作用域（Scope）和生命周期</strong></p><p>理解我们目前已经讨论过的不同作用域和生命周期类是至关重要的，因为错误的使用会导致非常严重的并发问题。</p><p>我们可以先画一个流程图，分析一下Mybatis的执行过程！</p><p><img src= "/img/loading.gif" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JdnS939HH5TayIhQo5s0aJbReBExSQO1U23XeLAXlhTWUeL87mJZL0lDzPstpY3CSIwvW0dN9ccA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p><strong>作用域理解</strong></p><ul><li>SqlSessionFactoryBuilder 的作用在于创建 SqlSessionFactory，创建成功后，SqlSessionFactoryBuilder 就失去了作用，所以它只能存在于创建 SqlSessionFactory 的方法中，而不要让其长期存在。因此 <strong>SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域</strong>（也就是局部方法变量）。</li><li>SqlSessionFactory 可以被认为是一个数据库连接池，它的作用是创建 SqlSession 接口对象。因为 MyBatis 的本质就是 Java 对数据库的操作，所以 SqlSessionFactory 的生命周期存在于整个 MyBatis 的应用之中，所以一旦创建了 SqlSessionFactory，就要长期保存它，直至不再使用 MyBatis 应用，所以可以认为 SqlSessionFactory 的生命周期就等同于 MyBatis 的应用周期。</li><li>由于 SqlSessionFactory 是一个对数据库的连接池，所以它占据着数据库的连接资源。如果创建多个 SqlSessionFactory，那么就存在多个数据库连接池，这样不利于对数据库资源的控制，也会导致数据库连接资源被消耗光，出现系统宕机等情况，所以尽量避免发生这样的情况。</li><li>因此在一般的应用中我们往往希望 SqlSessionFactory 作为一个单例，让它在应用中被共享。所以说 <strong>SqlSessionFactory 的最佳作用域是应用作用域。</strong></li><li>如果说 SqlSessionFactory 相当于数据库连接池，那么 SqlSession 就相当于一个数据库连接（Connection 对象），你可以在一个事务里面执行多条 SQL，然后通过它的 commit、rollback 等方法，提交或者回滚事务。所以它应该存活在一个业务请求中，处理完整个请求后，应该关闭这条连接，让它归还给 SqlSessionFactory，否则数据库资源就很快被耗费精光，系统就会瘫痪，所以用 try…catch…finally… 语句来保证其正确关闭。</li><li><strong>所以 SqlSession 的最佳的作用域是请求或方法作用域。</strong></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JdnS939HH5TayIhQo5s0aJJq1YuJCr3e9PsTBpBgc1tbicoshHB3qLkwgn3Jp2q8qI1dY9vGhIia3w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><blockquote><p>ResultMap</p></blockquote><p><strong>自动映射</strong></p><ul><li><code>resultMap</code> 元素是 MyBatis 中最重要最强大的元素。它可以让你从 90% 的 JDBC <code>ResultSets</code> 数据提取代码中解放出来。</li><li>实际上，在为一些比如连接的复杂语句编写映射代码的时候，一份 <code>resultMap</code> 能够代替实现同等功能的长达数千行的代码。</li><li>ResultMap 的设计思想是，对于简单的语句根本不需要配置显式的结果映射，而对于复杂一点的语句只需要描述它们的关系就行了。</li></ul><p>你已经见过简单映射语句的示例了，但并没有显式指定 <code>resultMap</code>。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id&#x3D;&quot;selectUserById&quot; resultType&#x3D;&quot;map&quot;&gt;</span><br><span class="line">select id , name , pwd</span><br><span class="line">  from user</span><br><span class="line">  where id &#x3D; #&#123;id&#125;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure><p>上述语句只是简单地将所有的列映射到 <code>HashMap</code> 的键上，这由 <code>resultType</code> 属性指定。虽然在大部分情况下都够用，但是 HashMap 不是一个很好的模型。你的程序更可能会使用 JavaBean 或 POJO（Plain Old Java Objects，普通老式 Java 对象）作为模型。</p><p><code>ResultMap</code> 最优秀的地方在于，虽然你已经对它相当了解了，但是根本就不需要显式地用到他们。</p><p><strong>手动映射</strong></p><p>1、返回值类型为resultMap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id&#x3D;&quot;selectUserById&quot; resultMap&#x3D;&quot;UserMap&quot;&gt;</span><br><span class="line">  select id , name , pwd from user where id &#x3D; #&#123;id&#125;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure><p>2、编写resultMap，实现手动映射！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap id&#x3D;&quot;UserMap&quot; type&#x3D;&quot;User&quot;&gt;</span><br><span class="line">   &lt;!-- id为主键 --&gt;</span><br><span class="line">   &lt;id column&#x3D;&quot;id&quot; property&#x3D;&quot;id&quot;&#x2F;&gt;</span><br><span class="line">   &lt;!-- column是数据库表的列名 , property是对应实体类的属性名 --&gt;</span><br><span class="line">   &lt;result column&#x3D;&quot;name&quot; property&#x3D;&quot;name&quot;&#x2F;&gt;</span><br><span class="line">   &lt;result column&#x3D;&quot;pwd&quot; property&#x3D;&quot;password&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;resultMap&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;select&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;select标签是mybatis中最常用的标签之一&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;select语句有很多属性可以详细配置每一条SQL语句&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;u</summary>
      
    
    
    
    <category term="mybatis" scheme="https://cddorz.github.io/categories/mybatis/"/>
    
    
    <category term="mybatis" scheme="https://cddorz.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis（一）</title>
    <link href="https://cddorz.github.io/2020/11/11/Mybatis/"/>
    <id>https://cddorz.github.io/2020/11/11/Mybatis/</id>
    <published>2020-11-11T11:14:59.000Z</published>
    <updated>2020-11-12T06:13:18.760Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>持久化</p></blockquote><p><strong>持久化是将程序数据在持久状态和瞬时状态间转换的机制。</strong></p><ul><li>即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的对象存储在数据库中，或者存储在磁盘文件中、XML数据文件中等等。</li><li>JDBC就是一种持久化机制。文件IO也是一种持久化机制。</li><li>在生活中 : 将鲜肉冷藏，吃的时候再解冻的方法也是。将水果做成罐头的方法也是。</li></ul><p><strong>为什么需要持久化服务呢？那是由于内存本身的缺陷引起的</strong></p><ul><li>内存断电后数据会丢失，但有一些对象是无论如何都不能丢失的，比如银行账号等，遗憾的是，人们还无法保证内存永不掉电。</li><li>内存过于昂贵，与硬盘、光盘等外存相比，内存的价格要高2~3个数量级，而且维持成本也高，至少需要一直供电吧。所以即使对象不需要永久保存，也会因为内存的容量限制不能一直呆在内存中，需要持久化来缓存到外存。</li></ul><blockquote><p>持久层</p></blockquote><p><strong>什么是持久层？</strong></p><ul><li>完成持久化工作的代码块 .  —-&gt;  dao层 【DAO (Data Access Object)  数据访问对象】</li><li>大多数情况下特别是企业级应用，数据持久化往往也就意味着将内存中的数据保存到磁盘上加以固化，而持久化的实现过程则大多通过各种<strong>关系数据库</strong>来完成。</li><li>不过这里有一个字需要特别强调，也就是所谓的“层”。对于应用系统而言，数据持久功能大多是必不可少的组成部分。也就是说，我们的系统中，已经天然的具备了“持久层”概念？也许是，但也许实际情况并非如此。之所以要独立出一个“持久层”的概念,而不是“持久模块”，“持久单元”，也就意味着，我们的系统架构中，应该有一个相对独立的逻辑层面，专注于数据持久化逻辑的实现.</li><li>与系统其他部分相对而言，这个层面应该具有一个较为清晰和严格的逻辑边界。【说白了就是用来操作数据库存在的！】</li></ul><blockquote><p>为什么需要Mybatis</p></blockquote><ul><li><p>Mybatis就是帮助程序猿将数据存入数据库中 , 和从数据库中取数据 .</p></li><li><p>传统的jdbc操作 , 有很多重复代码块 .比如 : 数据取出时的封装 , 数据库的建立连接等等… , 通过框架可以减少重复代码,提高开发效率 .</p></li><li><p>MyBatis 是一个半自动化的<strong>ORM框架 (Object Relationship Mapping) –&gt;对象关系映射</strong></p></li><li><p>所有的事情，不用Mybatis依旧可以做到，只是用了它，所有实现会更加简单！<strong>技术没有高低之分，只有使用这个技术的人有高低之别</strong></p></li><li><p>MyBatis的优点</p></li><li><ul><li>简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件就可以了，易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。</li><li>灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。sql写在xml里，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。</li><li>解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。</li><li>提供xml标签，支持编写动态sql。</li><li>…….</li></ul></li><li><p><strong>思路流程：搭建环境–&gt;导入Mybatis—&gt;编写代码—&gt;测试</strong></p></li><li><blockquote><p>代码演示</p></blockquote></li><li><p>1、搭建实验数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE &#96;mybatis&#96;;</span><br><span class="line"></span><br><span class="line">USE &#96;mybatis&#96;;</span><br><span class="line"></span><br><span class="line">DROP TABLE IF EXISTS &#96;user&#96;;</span><br><span class="line"></span><br><span class="line">CREATE TABLE &#96;user&#96; (</span><br><span class="line">&#96;id&#96; int(20) NOT NULL,</span><br><span class="line">&#96;name&#96; varchar(30) DEFAULT NULL,</span><br><span class="line">&#96;pwd&#96; varchar(30) DEFAULT NULL,</span><br><span class="line">PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line"></span><br><span class="line">insert  into &#96;user&#96;(&#96;id&#96;,&#96;name&#96;,&#96;pwd&#96;) values (1,&#39;狂神&#39;,&#39;123456&#39;),(2,&#39;张三&#39;,&#39;abcdef&#39;),(3,&#39;李四&#39;,&#39;987654&#39;);</span><br></pre></td></tr></table></figure></li><li><p>2、导入MyBatis相关 jar 包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>3、编写MyBatis核心配置文件</p><p>查看帮助文档</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">       <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">       <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span>/&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/kuang/dao/userMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>4、编写MyBatis工具类</p><p>查看帮助文档</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           String resource = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">           InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">           sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取SqlSession连接</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSession</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> sqlSessionFactory.openSession();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>5、创建实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> id;  <span class="comment">//id</span></span><br><span class="line">   <span class="keyword">private</span> String name;   <span class="comment">//姓名</span></span><br><span class="line">   <span class="keyword">private</span> String pwd;   <span class="comment">//密码</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">//构造,有参,无参</span></span><br><span class="line">   <span class="comment">//set/get</span></span><br><span class="line">   <span class="comment">//toString()</span></span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>6、编写Mapper接口类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.kuang.pojo.User;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">   <span class="function">List&lt;User&gt; <span class="title">selectUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>7、编写Mapper.xml配置文件</p><p>namespace 十分重要，不能写错！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">       <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">       <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.kuang.dao.UserMapper&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span>&gt;</span></span><br><span class="line">  select * from user</span><br><span class="line"> <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><blockquote><p>问题说明</p></blockquote></li><li><p><strong>可能出现问题说明：Maven静态资源过滤问题</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line">   &lt;resource&gt;</span><br><span class="line">       &lt;directory&gt;src&#x2F;main&#x2F;java&lt;&#x2F;directory&gt;</span><br><span class="line">       &lt;includes&gt;</span><br><span class="line">           &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;</span><br><span class="line">           &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;</span><br><span class="line">       &lt;&#x2F;includes&gt;</span><br><span class="line">       &lt;filtering&gt;false&lt;&#x2F;filtering&gt;</span><br><span class="line">   &lt;&#x2F;resource&gt;</span><br><span class="line">   &lt;resource&gt;</span><br><span class="line">       &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;</span><br><span class="line">       &lt;includes&gt;</span><br><span class="line">           &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;</span><br><span class="line">           &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;</span><br><span class="line">       &lt;&#x2F;includes&gt;</span><br><span class="line">       &lt;filtering&gt;false&lt;&#x2F;filtering&gt;</span><br><span class="line">   &lt;&#x2F;resource&gt;</span><br><span class="line">&lt;&#x2F;resources&gt;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;持久化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;持久化是将程序数据在持久状态和瞬时状态间转换的机制。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是</summary>
      
    
    
    
    <category term="mybatis" scheme="https://cddorz.github.io/categories/mybatis/"/>
    
    
    <category term="mybatis" scheme="https://cddorz.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>少年二字，应与平庸相斥</title>
    <link href="https://cddorz.github.io/2020/11/10/%E5%B0%91%E5%B9%B4%E4%BA%8C%E5%AD%97%EF%BC%8C%E5%BA%94%E4%B8%8E%E5%B9%B3%E5%BA%B8%E7%9B%B8%E6%96%A5/"/>
    <id>https://cddorz.github.io/2020/11/10/%E5%B0%91%E5%B9%B4%E4%BA%8C%E5%AD%97%EF%BC%8C%E5%BA%94%E4%B8%8E%E5%B9%B3%E5%BA%B8%E7%9B%B8%E6%96%A5/</id>
    <published>2020-11-10T08:49:30.000Z</published>
    <updated>2020-11-10T09:24:39.417Z</updated>
    
    <content type="html"><![CDATA[<h2 id="听闻少年二字，应与平庸相斥。"><a href="#听闻少年二字，应与平庸相斥。" class="headerlink" title="听闻少年二字，应与平庸相斥。"></a>听闻少年二字，应与平庸相斥。</h2><p>​        以后会走上怎样的道路尚不确定，只知年少的我们，生活中有诗歌和远方，脚下有坚实的土地，头顶有浩瀚的星空。宁欺白须公，莫欺少年穷，我们有着无限的可能性。</p><p>​        在高中，总有人在你身后催促着你前进，奔跑途中，身边也是与你一起冲向梦想的同学，但到了大学，似乎一切都变了。一个人在外，没有人在你身后看着你，身边的人也有了各自的目标和方向，大一的我迷茫了……</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-585af38a5f78e8a4fb027f998ac84df2_720w.jpg?source=1940ef5c" alt="img"></p><p>​        大一上，我上课玩手机，回寝室也是玩手机。点外卖，瘫坐在吊椅上无所事事，成了常态，看着室友自律的样子，也曾想做出过改变，但还是挡不住外在的诱惑（也许还幼稚），就这样浑浑噩噩的过了半年，最终成绩也只是中等。大一下，疫情爆发了，不得不在家里上网课，这导致我更加肆无忌惮的放松自己，慢性死亡，上网课没精神，看小说，几乎不出屋子，时时刻刻都在床上。这就是我的大一。</p><p>​        大二上，惊讶的发现室友有了惊天的变化，在我慢性死亡的时候，他有了自己的目标，并且为此做出了巨大的改变和努力，coding能力变得很强（发量可以看出），自己去加了学校的工作室，做了很多的业务，也得了很多的奖，那时，我才懂，他已经站在了只有少部分人站的高处，所以我也做出了改变，想清自己想要什么。现在的我，也算是刚刚起步，跳出了自己的舒适圈，<strong>希望自己能越来越好，上进且不平庸，不白来世间一趟</strong>，谨以此文激励自己。</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic3.zhimg.com/80/v2-65bedd063f12030d068046b72e425e08_720w.jpg?source=1940ef5c" alt="img"></p><p><strong>你本来就是太阳，无需凭借谁的光。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;听闻少年二字，应与平庸相斥。&quot;&gt;&lt;a href=&quot;#听闻少年二字，应与平庸相斥。&quot; class=&quot;headerlink&quot; title=&quot;听闻少年二字，应与平庸相斥。&quot;&gt;&lt;/a&gt;听闻少年二字，应与平庸相斥。&lt;/h2&gt;&lt;p&gt;​        以后会走上怎样的道路尚不确</summary>
      
    
    
    
    <category term="随笔" scheme="https://cddorz.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="少年" scheme="https://cddorz.github.io/tags/%E5%B0%91%E5%B9%B4/"/>
    
  </entry>
  
  <entry>
    <title>Java集合框架</title>
    <link href="https://cddorz.github.io/2020/11/06/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    <id>https://cddorz.github.io/2020/11/06/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</id>
    <published>2020-11-06T07:33:44.000Z</published>
    <updated>2020-11-12T03:46:54.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-集合框架"><a href="#Java-集合框架" class="headerlink" title="Java 集合框架"></a>Java 集合框架</h1><p><img src= "/img/loading.gif" data-lazy-src="https://www.runoob.com/wp-content/uploads/2014/01/2243690-9cd9c896e0d512ed.gif" alt="img"></p><ul><li><strong>接口：</strong>是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象</li><li><strong>实现（类）：</strong>是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。</li><li><strong>算法：</strong>是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。</li></ul><h4 id="一、Set和List的区别："><a href="#一、Set和List的区别：" class="headerlink" title="一、Set和List的区别："></a>一、Set和List的区别：</h4><ul><li>Set 接口实例存储的是无序的，不重复的数据。List 接口实例存储的是有序的，可以重复的元素</li><li> Set检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 <strong>&lt;实现类有HashSet,TreeSet&gt;</strong></li><li>List和数组类似，可以动态增长，根据实际存储的数据的长度自动增长List的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变 <strong>&lt;实现类有ArrayList,LinkedList,Vector&gt;</strong> </li></ul><h4 id="二、如何使用迭代器："><a href="#二、如何使用迭代器：" class="headerlink" title="二、如何使用迭代器："></a>二、如何使用迭代器：</h4><h5 id="遍历-ArrayList"><a href="#遍历-ArrayList" class="headerlink" title="遍历 ArrayList"></a>遍历 ArrayList</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">     list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">     list.add(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">     list.add(<span class="string">&quot;HAHAHAHA&quot;</span>);</span><br><span class="line">     <span class="comment">//第一种遍历方法使用 For-Each 遍历 List</span></span><br><span class="line">     <span class="keyword">for</span> (String str : list) &#123;            <span class="comment">//也可以改写 for(int i=0;i&lt;list.size();i++) 这种形式</span></span><br><span class="line">        System.out.println(str);</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//第二种遍历，把链表变为数组相关的内容进行遍历</span></span><br><span class="line">     String[] strArray=<span class="keyword">new</span> String[list.size()];</span><br><span class="line">     list.toArray(strArray);</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strArray.length;i++) <span class="comment">//这里也可以改写为  for(String str:strArray) 这种形式</span></span><br><span class="line">     &#123;</span><br><span class="line">        System.out.println(strArray[i]);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//第三种遍历 使用迭代器进行相关遍历,该方法可以不用担心在遍历的过程中会超出集合的长度。</span></span><br><span class="line">     </span><br><span class="line">     Iterator&lt;String&gt; ite=list.iterator();</span><br><span class="line">     <span class="keyword">while</span>(ite.hasNext())<span class="comment">//判断下一个元素之后有值</span></span><br><span class="line">     &#123;</span><br><span class="line">         System.out.println(ite.next());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="遍历-Map"><a href="#遍历-Map" class="headerlink" title="遍历 Map"></a>遍历 Map</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">      map.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">      map.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">      map.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;value3&quot;</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//第一种：普遍使用，二次取值</span></span><br><span class="line">      System.out.println(<span class="string">&quot;通过Map.keySet遍历key和value：&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;key= &quot;</span>+ key + <span class="string">&quot; and value= &quot;</span> + map.get(key));</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//第二种</span></span><br><span class="line">      System.out.println(<span class="string">&quot;通过Map.entrySet使用iterator遍历key和value：&quot;</span>);</span><br><span class="line">      Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line">      <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">       Map.Entry&lt;String, String&gt; entry = it.next();</span><br><span class="line">       System.out.println(<span class="string">&quot;key= &quot;</span> + entry.getKey() + <span class="string">&quot; and value= &quot;</span> + entry.getValue());</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//第三种：推荐，尤其是容量大时</span></span><br><span class="line">      System.out.println(<span class="string">&quot;通过Map.entrySet遍历key和value&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;key= &quot;</span> + entry.getKey() + <span class="string">&quot; and value= &quot;</span> + entry.getValue());</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">//第四种</span></span><br><span class="line">      System.out.println(<span class="string">&quot;通过Map.values()遍历所有的value，但不能遍历key&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (String v : map.values()) &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;value= &quot;</span> + v);</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、ArrayList"><a href="#三、ArrayList" class="headerlink" title="三、ArrayList"></a>三、ArrayList</h4><p>ArrayList类是一个可以动态修改的副本，与普通副本的区别就是它是没有固定大小的限制，我们可以添加或删除元素。</p><h6 id="1、基本实现"><a href="#1、基本实现" class="headerlink" title="1、基本实现"></a>1、基本实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunoobTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; sites = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        sites.add(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Weibo&quot;</span>);</span><br><span class="line">        System.out.println(sites);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="2、常用方法"><a href="#2、常用方法" class="headerlink" title="2、常用方法"></a>2、常用方法</h6><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/java/java-arraylist-add.html">add()</a></td><td>将元素插入到指定位置的 arraylist 中</td></tr><tr><td><a href="https://www.runoob.com/java/java-arraylist-get.html">get()</a></td><td>通过索引值获取 arraylist 中的元素</td></tr><tr><td><a href="https://www.runoob.com/java/java-arraylist-remove.html">remove()</a></td><td>删除 arraylist 里的单个元素</td></tr><tr><td><a href="https://www.runoob.com/java/java-arraylist-size.html">size()</a></td><td>返回 arraylist 里元素数量</td></tr><tr><td><a href="https://www.runoob.com/java/java-arraylist-set.html">set()</a></td><td>替换 arraylist 中指定索引的元素</td></tr><tr><td><a href="https://www.runoob.com/java/java-arraylist-tostring.html">toString()</a></td><td>将 arraylist 转换为字符串</td></tr></tbody></table><h4 id="四、LinkedList"><a href="#四、LinkedList" class="headerlink" title="四、LinkedList"></a>四、LinkedList</h4><p>链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的地址。</p><p>链表可分为单向链表和双向链表。</p><p>一个单向链表包含两个值: 当前节点的值和一个指向下一个节点的链接。</p><p><img src= "/img/loading.gif" data-lazy-src="https://www.runoob.com/wp-content/uploads/2020/06/408px-Singly-linked-list.svg_.png" alt="img"></p><p>一个双向链表有三个整数值: 数值、向后的节点链接、向前的节点链接。</p><p><img src= "/img/loading.gif" data-lazy-src="https://www.runoob.com/wp-content/uploads/2020/06/610px-Doubly-linked-list.svg_.png" alt="img"></p><p>Java LinkedList（链表） 类似于 ArrayList，是一种常用的数据容器。</p><p>与 ArrayList 相比，LinkedList 的增加和删除对操作效率更高，而查找和修改的操作效率较低。</p><p><strong>以下情况使用 ArrayList :</strong></p><ul><li>频繁访问列表中的某一个元素。</li><li>只需要在列表末尾进行添加和删除元素操作。</li></ul><p><strong>以下情况使用 LinkedList :</strong></p><ul><li>你需要通过循环迭代来访问列表中的某些元素。</li><li>需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作。</li></ul><h6 id="1、创建一个简单的链表实例"><a href="#1、创建一个简单的链表实例" class="headerlink" title="1、创建一个简单的链表实例"></a>1、创建一个简单的链表实例</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunoobTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; sites = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        sites.add(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Weibo&quot;</span>);</span><br><span class="line">        System.out.println(sites);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="2、常用方法-1"><a href="#2、常用方法-1" class="headerlink" title="2、常用方法"></a>2、常用方法</h6><table><thead><tr><th align="left">方法</th><th>描述</th></tr></thead><tbody><tr><td align="left">public int size()</td><td>返回链表元素个数。</td></tr><tr><td align="left">public E set(int index, E element)</td><td>设置指定位置的元素。</td></tr><tr><td align="left">public Object clone()</td><td>克隆该列表。</td></tr><tr><td align="left">public boolean add(E e)</td><td>链表末尾添加元素，返回是否成功，成功为 true，失败为 false。</td></tr><tr><td align="left">public void add(int index, E element)</td><td>向指定位置插入元素。</td></tr><tr><td align="left">public void addFirst(E e)</td><td>元素添加到头部</td></tr><tr><td align="left">public boolean offer(E e)</td><td>向链表末尾添加元素，返回是否成功，成功为 true，失败为 false。</td></tr><tr><td align="left">public void clear()</td><td>清空链表。</td></tr><tr><td align="left">public boolean remove(Object o)</td><td>删除某一元素，返回是否成功，成功为 true，失败为 false。</td></tr><tr><td align="left">public E remove(int index)</td><td>删除指定位置的元素。</td></tr><tr><td align="left">public E remove()</td><td>删除并返回第一个元素。</td></tr><tr><td align="left">public E get(int index)</td><td>返回指定位置的元素。</td></tr></tbody></table><h4 id="五、HashMap"><a href="#五、HashMap" class="headerlink" title="五、HashMap"></a>五、HashMap</h4><h6 id="1、基本内容："><a href="#1、基本内容：" class="headerlink" title="1、基本内容："></a>1、基本内容：</h6><p>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。</p><p>HashMap 实现了 Map 接口，根据键的 HashCode 值存储数据，具有很快的访问速度，最多允许一条记录的键为 null，不支持线程同步。</p><p>HashMap 是无序的，即不会记录插入的顺序。</p><p>HashMap 继承于AbstractMap，实现了 Map、Cloneable、java.io.Serializable 接口。</p><h6 id="2、HashMap-的-key-与-value-类型可以相同也可以不同，可以是字符串（String）类型的-key-和-value，也可以是整型（Integer）的-key-和字符串（String）类型的-value。"><a href="#2、HashMap-的-key-与-value-类型可以相同也可以不同，可以是字符串（String）类型的-key-和-value，也可以是整型（Integer）的-key-和字符串（String）类型的-value。" class="headerlink" title="2、HashMap 的 key 与 value 类型可以相同也可以不同，可以是字符串（String）类型的 key 和 value，也可以是整型（Integer）的 key 和字符串（String）类型的 value。"></a>2、HashMap 的 key 与 value 类型可以相同也可以不同，可以是字符串（String）类型的 key 和 value，也可以是整型（Integer）的 key 和字符串（String）类型的 value。</h6><h6 id="3、HashMap-中的元素实际上是对象，一些常见的基本类型可以使用它的包装类。"><a href="#3、HashMap-中的元素实际上是对象，一些常见的基本类型可以使用它的包装类。" class="headerlink" title="3、HashMap 中的元素实际上是对象，一些常见的基本类型可以使用它的包装类。"></a>3、HashMap 中的元素实际上是对象，一些常见的基本类型可以使用它的包装类。</h6><table><thead><tr><th>基本类型</th><th>引用类型</th></tr></thead><tbody><tr><td>boolean</td><td>Boolean</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character</td></tr></tbody></table><h6 id="4、例："><a href="#4、例：" class="headerlink" title="4、例："></a>4、例：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 HashMap 类      </span></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunoobTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 HashMap 对象 Sites</span></span><br><span class="line">        HashMap&lt;Integer, String&gt; Sites = <span class="keyword">new</span> HashMap&lt;Integer, String&gt;();</span><br><span class="line">        <span class="comment">// 添加键值对</span></span><br><span class="line">        Sites.put(<span class="number">1</span>, <span class="string">&quot;Google&quot;</span>);</span><br><span class="line">        Sites.put(<span class="number">2</span>, <span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">        Sites.put(<span class="number">3</span>, <span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">        Sites.put(<span class="number">4</span>, <span class="string">&quot;Zhihu&quot;</span>);</span><br><span class="line">        System.out.println(Sites);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：&#123;1=Google, 2=Runoob, 3=Taobao, 4=Zhihu&#125;</span></span><br></pre></td></tr></table></figure><h6 id="5、常用方法："><a href="#5、常用方法：" class="headerlink" title="5、常用方法："></a>5、常用方法：</h6><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/java/java-hashmap-clear.html">clear()</a></td><td>删除 hashMap 中的所有键/值对</td></tr><tr><td><a href="https://www.runoob.com/java/java-hashmap-clone.html">clone()</a></td><td>复制一份 hashMap</td></tr><tr><td><a href="https://www.runoob.com/java/java-hashmap-isempty.html">isEmpty()</a></td><td>判断 hashMap 是否为空</td></tr><tr><td><a href="https://www.runoob.com/java/java-hashmap-size.html">size()</a></td><td>计算 hashMap 中键/值对的数量</td></tr><tr><td><a href="https://www.runoob.com/java/java-hashmap-put.html">put()</a></td><td>将键/值对添加到 hashMap 中</td></tr><tr><td><a href="https://www.runoob.com/java/java-hashmap-remove.html">remove()</a></td><td>删除 hashMap 中指定键 key 的映射关系</td></tr><tr><td><a href="https://www.runoob.com/java/java-hashmap-replace.html">replace()</a></td><td>替换 hashMap 中是指定的 key 对应的 value。</td></tr><tr><td><a href="https://www.runoob.com/java/java-hashmap-get.html">get()</a></td><td>获取指定 key 对应对 value</td></tr><tr><td><a href="https://www.runoob.com/java/java-hashmap-entryset.html">entrySet()</a></td><td>返回 hashMap 中所有映射项的集合集合视图。</td></tr><tr><td><a href="https://www.runoob.com/java/java-hashmap-keyset.html">keySet</a>()</td><td>返回 hashMap 中所有 key 组成的集合视图。</td></tr><tr><td><a href="https://www.runoob.com/java/java-hashmap-values.html">values()</a></td><td>返回 hashMap 中存在的所有 value 值。</td></tr></tbody></table><p><a href="https://www.runoob.com/java/java-hashmap.html">参考文章</a></p><h4 id="六、Hashcode方法与equals方法"><a href="#六、Hashcode方法与equals方法" class="headerlink" title="六、Hashcode方法与equals方法"></a>六、Hashcode方法与equals方法</h4><h5 id="（一）、hashcode是什么？"><a href="#（一）、hashcode是什么？" class="headerlink" title="（一）、hashcode是什么？"></a>（一）、hashcode是什么？</h5><h6 id="1、hash和hash表是什么"><a href="#1、hash和hash表是什么" class="headerlink" title="1、hash和hash表是什么"></a>1、hash和hash表是什么</h6><p>hash是一个函数，该函数中的实现就是一种算法，就是通过一系列的算法来得到一个hash值。这个时候，我们就需要知道另一个东西，hash表，通过hash算法得到的hash值就在这张hash表中，也就是说，hash表就是所有的hash值组成的，有很多种hash函数，也就代表着有很多种算法得到hash值</p><h6 id="2、hashcode"><a href="#2、hashcode" class="headerlink" title="2、hashcode"></a>2、hashcode</h6><p>hashcode就是通过hash函数得来的，通俗的说，就是通过某一种算法得到的，hashcode就是在hash表中有对应的位置。</p><p><strong>每个对象都有hashcode，对象的hashcode怎么得来的呢？</strong></p><p>首先一个对象肯定有物理地址，对象的物理地址跟这个hashcode地址不一样，<strong>hashcode代表对象的地址说的是对象在hash表中的位置，物理地址说的对象存放在内存中的地址</strong></p><p>通过对象的内部地址(也就是物理地址)转换成一个整数，然后该整数通过hash函数的算法就得到了hashcode。<strong>所以，hashcode就是在hash表中对应的位置。</strong></p><p>举个例子，hash表中有 hashcode为1、hashcode为2、(…)3、4、5、6、7、8这样八个位置，有一个对象A，A的物理地址转换为一个整数17(这是假如)，就通过直接取余算法，17%8=1，那么A的hashcode就为1，且A就在hash表中1的位置。</p><h5 id="（二）、hashcode有什么作用"><a href="#（二）、hashcode有什么作用" class="headerlink" title="（二）、hashcode有什么作用"></a>（二）、hashcode有什么作用</h5><p><strong>HashCode的存在主要是为了查找的快捷性，HashCode是用来在散列存储结构中确定对象的存储地址的(后半句说的用hashcode来代表对象就是在hash表中的位置)</strong></p><p>比如：我们有一个能存放1000个数这样大的内存中，在其中要存放1000个不一样的数字，用最笨的方法，就是存一个数字，就遍历一遍，看有没有相同得数，当存了900个数字，开始存901个数字的时候，就需要跟900个数字进行对比，这样就很麻烦，很是消耗时间，用hashcode来记录对象的位置，来看一下。</p><p>hash表中有1、2、3、4、5、6、7、8个位置，存第一个数，hashcode为1，该数就放在hash表中1的位置，存到100个数字，hash表中8个位置会有很多数字了，1中可能有20个数字，存101个数字时，他先查hashcode值对应的位置，假设为1，那么就有20个数字和他的hashcode相同，他只需要跟这20个数字相比较(equals)，如果每一个相同，那么就放在1这个位置，这样比较的次数就少了很多，实际上hash表中有很多位置，这里只是举例只有8个，实际上，如果hash表很大，那么比较的次数就很少很少了。</p><p><strong><em>！！！值如果相等那么hashcode一定相等，所以先比较hashcode再用equals方法比较</em></strong></p><h5 id="（三）、equals方法和hashcode的关系"><a href="#（三）、equals方法和hashcode的关系" class="headerlink" title="（三）、equals方法和hashcode的关系"></a>（三）、equals方法和hashcode的关系</h5><p>通过前面这个例子，大概可以知道，先通过hashcode来比较，如果hashcode相等，那么就用equals方法来比较两个对象是否相等。</p><p>用个例子说明：上面说的hash表中的8个位置，就好比8个桶，每个桶里能装很多的对象，对象A通过hash函数算法得到将它放到1号桶中，当然肯定有别的对象也会放到1号桶中，如果对象B也通过算法分到了1号桶，那么它如何识别桶中其他对象是否和它一样呢，这时候就需要equals方法来进行筛选了。</p><p>1、如果两个对象equals相等，那么这两个对象的HashCode一定也相同</p><p>2、如果两个对象的HashCode相同，不代表两个对象就相同，只能说明这两个对象在散列存储结构中，存放于同一个位置</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-集合框架&quot;&gt;&lt;a href=&quot;#Java-集合框架&quot; class=&quot;headerlink&quot; title=&quot;Java 集合框架&quot;&gt;&lt;/a&gt;Java 集合框架&lt;/h1&gt;&lt;p&gt;&lt;img src= &quot;/img/loading.gif&quot; data-lazy-src</summary>
      
    
    
    
    <category term="Java" scheme="https://cddorz.github.io/categories/Java/"/>
    
    
    <category term="总结" scheme="https://cddorz.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>青鸢面基大会</title>
    <link href="https://cddorz.github.io/2020/10/31/%E9%9D%92%E9%B8%A2%E9%9D%A2%E5%9F%BA%E5%A4%A7%E4%BC%9A/"/>
    <id>https://cddorz.github.io/2020/10/31/%E9%9D%92%E9%B8%A2%E9%9D%A2%E5%9F%BA%E5%A4%A7%E4%BC%9A/</id>
    <published>2020-10-31T13:32:30.000Z</published>
    <updated>2020-11-13T11:40:20.137Z</updated>
    
    <content type="html"><![CDATA[<h2 id="青鸢面基大会"><a href="#青鸢面基大会" class="headerlink" title="青鸢面基大会"></a>青鸢面基大会</h2><h4 id="10-30青鸢工作室面基大会。西安电子科技大学青鸢工作室nb！"><a href="#10-30青鸢工作室面基大会。西安电子科技大学青鸢工作室nb！" class="headerlink" title="10.30青鸢工作室面基大会。西安电子科技大学青鸢工作室nb！"></a>10.30青鸢工作室面基大会。西安电子科技大学青鸢工作室nb！</h4><p>18：30——19：00是学长树总给大家说一下工作室的代码规范。</p><p>​    之后的聚餐才是真正的重点！因为有美团大四工作学长和字节大三实习学长来和我们一起聊天。</p><p>虽然一开始大家都不是很熟悉的时候，没聊啥，但随着学长们分享去大场工作的经验，大家的兴趣也都提了起来，对大厂有抑制不住的幻想hhhhh，也了解到很多的神。</p><p>​    感觉这次聚餐之后，对字节有了更多的期望，一人一导师的制度真的感觉很好，然后在知乎上看到在字节成长度会真的很高，所有现阶段目标就是为了字节而努力，那个大三学长也是十月份才开始觉醒。</p><p>​    就感觉对未来充满了希望和有了目标吧。qwq。</p><hr><p><strong>2020.11.12更新</strong>：也算是对业务有了最基本的了解，也写了几个功能，回头看到了学长给的建议，还是想写下来: </p><p><strong>首先：面试的准备工作</strong></p><p>1、去字节招聘网站，搜索日常实习生，找java 岗位要求，多看几个岗位要求，大概就知道现在大厂要求你干嘛了，然后再根据你不会的 去针对学习。</p><p>2、背高频面试题</p><p><u><strong>其次，是坚持二字尤为重要！！</strong></u></p><p><strong>最后，学习的路</strong></p><p>工作室的业务，做一两个来练手，熟悉基本流程，更重要的是自己扎实基础，找找项目难点，寻找优化点，做的时候多想一点，不是单纯为了做功能而做，多思考为什么要这样做。</p><hr><p><a href="https://www.huxiu.com/article/267100.html">阿里云的这群疯子</a></p><p>希望大家看到的都能花一点时间去看看这篇文章。，文采不足就用其中的几句话来概括我的感受：</p><p><strong>创业维艰，唯有曾和死神擦肩而过的人，余生才会用十倍的速度奔跑。</strong></p><p><strong>认输，你才真的输了。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;青鸢面基大会&quot;&gt;&lt;a href=&quot;#青鸢面基大会&quot; class=&quot;headerlink&quot; title=&quot;青鸢面基大会&quot;&gt;&lt;/a&gt;青鸢面基大会&lt;/h2&gt;&lt;h4 id=&quot;10-30青鸢工作室面基大会。西安电子科技大学青鸢工作室nb！&quot;&gt;&lt;a href=&quot;#10-30青</summary>
      
    
    
    
    <category term="随笔" scheme="https://cddorz.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="总结" scheme="https://cddorz.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>一天的心得</title>
    <link href="https://cddorz.github.io/2020/10/29/%E4%B8%80%E5%A4%A9%E7%9A%84%E5%BF%83%E5%BE%97/"/>
    <id>https://cddorz.github.io/2020/10/29/%E4%B8%80%E5%A4%A9%E7%9A%84%E5%BF%83%E5%BE%97/</id>
    <published>2020-10-29T08:57:59.000Z</published>
    <updated>2020-11-02T10:07:22.687Z</updated>
    
    <content type="html"><![CDATA[<h3 id="First-step"><a href="#First-step" class="headerlink" title="First step"></a>First step</h3><p>​    一个晚上和一个白天的成果，初步搭建好了自己的博客，虽然挺累的，也算是走出舒适圈的第一步了，也第一次体验到了找bug的痛苦！！！</p><p>​    总结一下今天遇到的问题，希望可以帮助到同样有这些问题的人：</p><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>​        1)、如果遇到你改了某个地方之后，登录你部属的网站发现十个空网站，那么问题应该是你_config.yml文件某个部署错了，可以先本地运行一下然后看看报错（今天问的一个巨佬，orz）。</p><p>​        2)、部署新东西或之后：</p><p>​                    所在文件夹用git命令：hexo g   hexo d</p><p>​        3)、hexo clean万能的命令，有时候刷新不出来新内容可以等到或者hexo clean。可以先在本地看看效果，如果本地效果出来了，那么就只是时间问题啦。</p><p>呜呜呜，第一篇blog，markdown很多语法还不熟悉，所以就先这样吧，害，以后会变得更强的！</p><p><em>少年鲜衣怒马， 不负韶华！！！！</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;First-step&quot;&gt;&lt;a href=&quot;#First-step&quot; class=&quot;headerlink&quot; title=&quot;First step&quot;&gt;&lt;/a&gt;First step&lt;/h3&gt;&lt;p&gt;​    一个晚上和一个白天的成果，初步搭建好了自己的博客，虽然挺累的，也算</summary>
      
    
    
    
    <category term="随笔" scheme="https://cddorz.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="总结" scheme="https://cddorz.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
</feed>

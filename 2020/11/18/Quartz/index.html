<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Quartz | HLY-Blog</title><meta name="keywords" content="定时任务"><meta name="author" content="HLY"><meta name="copyright" content="HLY"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="一、Quartz概念Quartz是OpenSymphony开源组织在Job scheduling领域又一个开源项目，它可以与J2EE与J2SE应用程序相结合，也可以单独使用。 Quartz是开源且具有丰富特性的“任务调度库”，能够集成于任何的Java应用，小到独立的应用，大至电子商业系统。Quartz能够创建亦简单亦复杂的调度，以执行上十、上百，甚至上万的任务。任务job被定义为标准的Java组件">
<meta property="og:type" content="article">
<meta property="og:title" content="Quartz">
<meta property="og:url" content="https://cddorz.github.io/2020/11/18/Quartz/index.html">
<meta property="og:site_name" content="HLY-Blog">
<meta property="og:description" content="一、Quartz概念Quartz是OpenSymphony开源组织在Job scheduling领域又一个开源项目，它可以与J2EE与J2SE应用程序相结合，也可以单独使用。 Quartz是开源且具有丰富特性的“任务调度库”，能够集成于任何的Java应用，小到独立的应用，大至电子商业系统。Quartz能够创建亦简单亦复杂的调度，以执行上十、上百，甚至上万的任务。任务job被定义为标准的Java组件">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-a196f39112d5287f0214eb50b94563ce_720w.jpg?source=1940ef5c">
<meta property="article:published_time" content="2020-11-18T02:43:41.000Z">
<meta property="article:modified_time" content="2020-11-18T02:46:28.535Z">
<meta property="article:author" content="HLY">
<meta property="article:tag" content="定时任务">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic1.zhimg.com/80/v2-a196f39112d5287f0214eb50b94563ce_720w.jpg?source=1940ef5c"><link rel="shortcut icon" href="/img/tubiao.jpg"><link rel="canonical" href="https://cddorz.github.io/2020/11/18/Quartz/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: {"text":"I,LOVE,YOU","fontSize":"15px"},
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-11-18 10:46:28'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><link rel="stylesheet" href="/clock/css/clock.css"/><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="HLY-Blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/tubiao.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/-%E9%9F%B3%E4%B9%90"><i class="fa-fw /music/"></i><span> 清单|| fa fa-heartbeat</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://pic1.zhimg.com/80/v2-a196f39112d5287f0214eb50b94563ce_720w.jpg?source=1940ef5c)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">HLY-Blog</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/-%E9%9F%B3%E4%B9%90"><i class="fa-fw /music/"></i><span> 清单|| fa fa-heartbeat</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">Quartz</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-11-18T02:43:41.000Z" title="发表于 2020-11-18 10:43:41">2020-11-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-11-18T02:46:28.535Z" title="更新于 2020-11-18 10:46:28">2020-11-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/springboot/">springboot</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2020/11/18/Quartz/#post-comment"><span class="gitalk-comment-count comment-count"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="一、Quartz概念"><a href="#一、Quartz概念" class="headerlink" title="一、Quartz概念"></a>一、Quartz概念</h2><p>Quartz是OpenSymphony开源组织在Job scheduling领域又一个开源项目，它可以与J2EE与J2SE应用程序相结合，也可以单独使用。</p>
<p>Quartz是开源且具有丰富特性的“任务调度库”，能够集成于任何的Java应用，小到独立的应用，大至电子商业系统。Quartz能够创建亦简单亦复杂的调度，以执行上十、上百，甚至上万的任务。任务job被定义为标准的Java组件，能够执行任何你想要实现的功能。Quartz调度框架包含许多企业级的特性，如JTA事务、集群的支持。</p>
<p>简而言之，Quartz就是基于Java实现的任务调度框架，用于执行你想要执行的任何任务。</p>
<p>官网： <a target="_blank" rel="noopener" href="http://www.quartz-scheduler.org/">http://www.quartz-scheduler.org</a></p>
<h2 id="二、Quartz运行环境"><a href="#二、Quartz运行环境" class="headerlink" title="二、Quartz运行环境"></a>二、Quartz运行环境</h2><ul>
<li>Quartz可以运行嵌入在另一个独立式应用程序</li>
<li>Quartz可以在应用程序服务器（或Servlet容器）内被实例化，并且参与事务</li>
<li>Quartz可以作为一个独立的程序运行（其自己的Java虚拟机内），可以通过RMI使用</li>
<li>Quartz可以被实例化，作为独立的项目集群（负载平衡和故障转移功能），用于作业的执行</li>
</ul>
<h2 id="三、Quartz设计模式"><a href="#三、Quartz设计模式" class="headerlink" title="三、Quartz设计模式"></a>三、Quartz设计模式</h2><ul>
<li>Builder模式</li>
<li>Factory模式</li>
<li>组件模式</li>
<li>链式编程</li>
</ul>
<h2 id="四、Quartz学习的核心概念"><a href="#四、Quartz学习的核心概念" class="headerlink" title="四、Quartz学习的核心概念"></a>四、Quartz学习的核心概念</h2><ul>
<li>任务Job</li>
</ul>
<p>Job就是你想要实现的任务类，每一个Job必须实现org.quartz.job接口，且只需实现接口定义的execute()方法。</p>
<ul>
<li>触发器Trigger</li>
</ul>
<p>Trigger为你执行任务的触发器，比如你想每天定时3点发送一份统计邮件，Trigger将会设置3点执行该任务。 + Trigger主要包含两种SimplerTrigger和CronTrigger两种。关于二者的区别和使用场景，后续课程会进行讨论。</p>
<ul>
<li>调度器Scheduler</li>
</ul>
<p>Scheduler为任务的调度器，它会将任务Job及触发器Trigger整合起来，负责基于Trigger设定的时间来执行Job。</p>
<h2 id="五、Quartz的体系结构"><a href="#五、Quartz的体系结构" class="headerlink" title="五、Quartz的体系结构"></a>五、Quartz的体系结构</h2><p><a target="_blank" rel="noopener" href="https://github.com/lan7916/itlan_quartz/blob/master/imgs/01.jpg"><img src= "/img/loading.gif" data-lazy-src="https://github.com/lan7916/itlan_quartz/raw/master/imgs/01.jpg" alt="avatar"></a></p>
<h2 id="六、Quartz的几个常用API"><a href="#六、Quartz的几个常用API" class="headerlink" title="六、Quartz的几个常用API"></a>六、Quartz的几个常用API</h2><p>以下是Quartz编程API几个重要接口，也是Quartz的重要组件。</p>
<ul>
<li>Scheduler 用于与调度程序交互的主程序接口。 + Scheduler调度程序-任务执行计划表，只有安排进执行计划的任务Job（通过scheduler.scheduleJob方法安排进执行计划），当它预先定义的执行时间到了的时候（任务触发Trigger），该任务才会执行。</li>
<li>Job 我们预先定义的希望在未来时间能被调度程序执行的任务类，我们可以自定义。</li>
<li>JobDetail 使用JobDetail来定义定时任务的实例，JobDetail实例是通过JobBuilder类创建的。</li>
<li>JobDataMap 可以包含不限量的（序列化的）数据对象，在Job实例执行的时候，可以使用其中的数据；JobDataMap是Java Map接口的一个实现，额外增加了一些便于存取基本类型的数据的方法。</li>
<li>Trigger 触发器，Trigger对象是用来触发执行Job的。当调度一个Job时，我们实例一个触发器，然后调整它的属性来满足Job执行的条件。表明任务在什么时候会执行。定义了一个已经被安排的任务将会在什么时候执行的时间条件，比如每2秒就执行一次。</li>
<li>JobBuilder 用于声明一个任务实例，也可以定义关于该任务的详情，比如任务名、组名等，这个声明的实例将会作为一个实际执行的任务。</li>
<li>TriggerBuilder 触发器创建器，用于创建触发器Trigger实例。</li>
<li>JobListener、TriggerListener、SchedulerListener监听器，用于对组件的监听。</li>
</ul>
<h2 id="七、Quart的使用"><a href="#七、Quart的使用" class="headerlink" title="七、Quart的使用"></a>七、Quart的使用</h2><h3 id="1、准备工作"><a href="#1、准备工作" class="headerlink" title="1、准备工作"></a>1、准备工作</h3><p>新建maven工程</p>
<p><a target="_blank" rel="noopener" href="https://github.com/lan7916/itlan_quartz/blob/master/imgs/02.jpg"><img src= "/img/loading.gif" data-lazy-src="https://github.com/lan7916/itlan_quartz/raw/master/imgs/02.jpg" alt="avatar"></a> <a target="_blank" rel="noopener" href="https://github.com/lan7916/itlan_quartz/blob/master/imgs/03.jpg"><img src= "/img/loading.gif" data-lazy-src="https://github.com/lan7916/itlan_quartz/raw/master/imgs/03.jpg" alt="avatar"></a></p>
<p>查找： <a target="_blank" rel="noopener" href="https://mvnrepository.com/">https://mvnrepository.com/</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/lan7916/itlan_quartz/blob/master/imgs/04.jpg"><img src= "/img/loading.gif" data-lazy-src="https://github.com/lan7916/itlan_quartz/raw/master/imgs/04.jpg" alt="avatar"></a></p>
<h3 id="2、引入Quartz的jar包"><a href="#2、引入Quartz的jar包" class="headerlink" title="2、引入Quartz的jar包"></a>2、引入Quartz的jar包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!-- Quartz 核心包 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.quartz-scheduler&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;quartz&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.3.0&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;!-- Quartz 工具包 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.quartz-scheduler&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;quartz-jobs&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.3.0&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;!-- log4j --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;slf4j-log4j12&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.7.25&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;log4j&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;log4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.2.17&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.7.0&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;target&gt;1.8&lt;&#x2F;target&gt;</span><br><span class="line">                &lt;source&gt;1.8&lt;&#x2F;source&gt;</span><br><span class="line">            &lt;&#x2F;configuration&gt;</span><br><span class="line">        &lt;&#x2F;plugin&gt;</span><br><span class="line">    &lt;&#x2F;plugins&gt;</span><br><span class="line">&lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure>

<p>导入log4j.properties日志文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">### direct log messages to stdout ###</span><br><span class="line">log4j.appender.stdout&#x3D;org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.Target&#x3D;System.out</span><br><span class="line">log4j.appender.stdout.layout&#x3D;org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern&#x3D;%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n</span><br><span class="line"></span><br><span class="line">### direct log file mylog.log ###</span><br><span class="line">log4j.appender.file&#x3D;org.apache.log4j.FileAppender</span><br><span class="line">log4j.appender.file.File&#x3D;.&#x2F;mylog.log</span><br><span class="line">log4j.appender.file.layout&#x3D;org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.file.layout.ConversionPattern&#x3D;%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n</span><br><span class="line"></span><br><span class="line">*** set log levels - for more verbose logging change &#39;info&#39; to &#39;debug&#39; ###</span><br><span class="line"></span><br><span class="line">log4j.rootLogger&#x3D;info, stdout</span><br></pre></td></tr></table></figure>

<h3 id="3、入门案例"><a href="#3、入门案例" class="headerlink" title="3、入门案例"></a>3、入门案例</h3><p>（1）创建HelloJob任务类</p>
<p><a target="_blank" rel="noopener" href="https://github.com/lan7916/itlan_quartz/blob/master/imgs/05.jpg"><img src= "/img/loading.gif" data-lazy-src="https://github.com/lan7916/itlan_quartz/raw/master/imgs/05.jpg" alt="avatar"></a></p>
<p>HelloJob.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义任务类</span><br><span class="line">public class HelloJob implements Job &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void execute(JobExecutionContext arg0) throws JobExecutionException &#123;</span><br><span class="line">        &#x2F;&#x2F; 输出当前时间</span><br><span class="line">        Date date &#x3D; new Date();</span><br><span class="line">        SimpleDateFormat dateFormat &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        String dateString &#x3D; dateFormat.format(date);</span><br><span class="line">        &#x2F;&#x2F; 工作内容</span><br><span class="line">        System.out.println(&quot;正在进行数据库的备份工作，备份数据库的时间是：&quot; +dateString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）创建任务调度类HelloSchedulerDemo + HelloSchedulerDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class HelloSchedulerDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 1、调度器（Scheduler），从工厂中获取调度的实例（默认：实例化new StdSchedulerFactory();）</span><br><span class="line">        Scheduler scheduler &#x3D; StdSchedulerFactory.getDefaultScheduler();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 2、任务实例（JobDetail）定义一个任务调度实例，将该实例与HelloJob绑定，任务类需要实现Job接口</span><br><span class="line">        JobDetail jobDetail &#x3D; JobBuilder.newJob() &#x2F;&#x2F; 加载任务类，与HelloJob完成绑定，要求HelloJob实现Job接口</span><br><span class="line">                .withIdentity(&quot;job1&quot;, &quot;group1&quot;) &#x2F;&#x2F; 参数1：任务的名称（唯一实例）；参数2：任务组的名称</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 3、触发器（Trigger）定义触发器，马上执行，然后每5秒重复执行一次</span><br><span class="line">        Trigger trigger &#x3D; TriggerBuilder.newTrigger()</span><br><span class="line">                .withIdentity(&quot;trigger1&quot;, &quot;group1&quot;) &#x2F;&#x2F; 参数1：触发器的名称（唯一实例）；参数2：触发器组的名称</span><br><span class="line">                .startNow() &#x2F;&#x2F; 马上启动触发器</span><br><span class="line">                .withSchedule(SimpleScheduleBuilder.simpleSchedule().repeatSecondlyForever(5)) &#x2F;&#x2F; 每5秒重复执行一次</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 4、让调度器关联任务和触发器，保证按照触发器定义的调整执行任务</span><br><span class="line">        scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 5、启动</span><br><span class="line">        scheduler.start();</span><br><span class="line">        &#x2F;&#x2F; 关闭</span><br><span class="line">        &#x2F;&#x2F;scheduler.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）实现效果</p>
<p><a target="_blank" rel="noopener" href="https://github.com/lan7916/itlan_quartz/blob/master/imgs/06.jpg"><img src= "/img/loading.gif" data-lazy-src="https://github.com/lan7916/itlan_quartz/raw/master/imgs/06.jpg" alt="avatar"></a></p>
<h3 id="4、Job和JobDetail介绍"><a href="#4、Job和JobDetail介绍" class="headerlink" title="4、Job和JobDetail介绍"></a>4、Job和JobDetail介绍</h3><ul>
<li>Job：工作任务调度的接口，任务了需要实现该接口。该接口中定义execute方法，类似JDK提供的TimeTask类的run方法。在里面编写任务执行的业务逻辑。</li>
<li>Job实例在Quartz中的声明周期：每次调度器执行Job时，它在调用execute方法前会创建一个新的Job实例，当调用完成后，关联的Job对象实例会被释放，释放的实例会被垃圾回收机制回收。</li>
<li>JobDetail：JobDetail为Job实例提供了许多设置属性，以及JobDataMap成员变量属性，它用来存储特定Job实例的状态信息，调度器需要借助JobDetail对象来添加Job实例。</li>
<li>JobDetail重要属性：name、group、jobClass、JobDataMap</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JobDetail job &#x3D; JobBuilder.newJob(HelloJob.class)</span><br><span class="line">        .withIdentity(&quot;job1&quot;, &quot;group1&quot;) &#x2F;&#x2F; 定义该实例唯一标识，并指定一个组</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;name:&quot; +job.getKey().getName());</span><br><span class="line">System.out.println(&quot;group:&quot; +job.getKey().getGroup());</span><br><span class="line">System.out.println(&quot;jobClass:&quot; +job.getJobClass().getName());</span><br></pre></td></tr></table></figure>

<h3 id="5、JobExecutionContext介绍"><a href="#5、JobExecutionContext介绍" class="headerlink" title="5、JobExecutionContext介绍"></a>5、JobExecutionContext介绍</h3><ul>
<li>当Scheduler调用一个Job，就会将JobExecutionContext传递给Job的execute()方法；</li>
<li>Job能通过JobExecutionContext对象访问到Quartz运行时候的环境以及Job本身的明细数据。</li>
</ul>
<h3 id="6、JobDataMap介绍"><a href="#6、JobDataMap介绍" class="headerlink" title="6、JobDataMap介绍"></a>6、JobDataMap介绍</h3><p>（1）使用Map获取</p>
<ul>
<li>在进行任务调度时，JobDataMap存储在JobExecutionContext中，非常方便获取。</li>
<li>JobDataMap可以用来装载任何可序列化的数据对象，当Job实例对象被执行时这些参数对象会传递给它。</li>
<li>JobDataMap实现了JDK的Map接口，并且添加了非常方便的方法用来存取基本数据类型。</li>
</ul>
<p>HelloSchedulerDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 2：任务实例（JobDetail）定义一个任务调度实例，将该实例与HelloJob绑定，任务类需要实现Job接口</span><br><span class="line">JobDetail job &#x3D; JobBuilder.newJob(HelloJob.class)</span><br><span class="line">        .withIdentity(&quot;job1&quot;, &quot;group1&quot;) &#x2F;&#x2F; 定义该实例唯一标识，并指定一个组</span><br><span class="line">        .usingJobData(&quot;message&quot;, &quot;打印日志&quot;)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3：触发器（Trigger）定义触发器，马上执行，然后每5秒重复执行一次</span><br><span class="line">Trigger trigger &#x3D; TriggerBuilder.newTrigger()</span><br><span class="line">        .withIdentity(&quot;trigger1&quot;, &quot;group1&quot;) &#x2F;&#x2F; 定义该实例唯一标识</span><br><span class="line">        .startNow() &#x2F;&#x2F; 马上启动触发器</span><br><span class="line">        &#x2F;&#x2F;.startAt(triggerStartTime) &#x2F;&#x2F; 针对某个时刻执行</span><br><span class="line">        .withSchedule(SimpleScheduleBuilder.simpleSchedule().repeatSecondlyForever(5)) &#x2F;&#x2F; 每5秒重复执行一次</span><br><span class="line">        .usingJobData(&quot;message&quot;, &quot;simple触发器&quot;)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>

<p>HelloJob.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">JobKey jobKey &#x3D; context.getJobDetail().getKey();</span><br><span class="line">System.out.println(&quot;工作任务名称：&quot; +jobKey.getName() +&quot;；    工作任务组：&quot; +jobKey.getGroup());</span><br><span class="line">System.out.println(&quot;任务类名称（带包名）：&quot; +context.getJobDetail().getJobClass().getName());</span><br><span class="line">System.out.println(&quot;任务类名称：&quot; +context.getJobDetail().getJobClass().getSimpleName());</span><br><span class="line">System.out.println(&quot;当前任务执行时间：&quot; +context.getFireTime());</span><br><span class="line">System.out.println(&quot;下一任务执行时间：&quot; +context.getNextFireTime());</span><br><span class="line"></span><br><span class="line">TriggerKey triggerKey &#x3D; context.getTrigger().getKey();</span><br><span class="line">System.out.println(&quot;触发器名称：&quot; +triggerKey.getName() +&quot;；    触发器组：&quot; +triggerKey.getGroup());</span><br><span class="line"></span><br><span class="line">JobDataMap jobDataMap &#x3D; context.getJobDetail().getJobDataMap();</span><br><span class="line">String jobDataMessage &#x3D; jobDataMap.getString(&quot;message&quot;);</span><br><span class="line">System.out.println(&quot;任务参数消息值：&quot; +jobDataMessage);</span><br><span class="line"></span><br><span class="line">JobDataMap triggerDataMap &#x3D; context.getTrigger().getJobDataMap();</span><br><span class="line">String triggerDataMessage &#x3D; triggerDataMap.getString(&quot;message&quot;);</span><br><span class="line">System.out.println(&quot;触发器参数消息值：&quot; +triggerDataMessage);</span><br></pre></td></tr></table></figure>

<p>（2）Job实现类中添加setter方法对应JobDataMap的键值，Quartz框架默认的JobFactory实现类在初始化Job实例对象时会自动调用这些setter方法。</p>
<p>HelloJob.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private String message;</span><br><span class="line"></span><br><span class="line">public void setMessage(String message) &#123;</span><br><span class="line">    this.message &#x3D; message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果遇到同名的key，Trigger中的.usingJobData(“message”, “simple触发器”)会覆盖JobDetail中的.usingJobData(“message”, “打印日志”)。</p>
</blockquote>
<h3 id="7、有状态的Job和无状态的Job"><a href="#7、有状态的Job和无状态的Job" class="headerlink" title="7、有状态的Job和无状态的Job"></a>7、有状态的Job和无状态的Job</h3><p>@PersistJobDataAfterExecution注解的使用</p>
<p>有状态的Job可以理解为多次Job调用期间可以持有一些状态信息，这些状态信息存储在JobDataMap中，而默认的无状态Job每次调用时都会创建一个新的JobDataMap。</p>
<p>（1）修改HelloSchedulerDemo.java。添加.usingJobData(“count”, 0)，表示计数器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JobDetail job &#x3D; JobBuilder.newJob(HelloJob.class)</span><br><span class="line">        .withIdentity(&quot;job1&quot;, &quot;group1&quot;) &#x2F;&#x2F; 定义该实例唯一标识，并指定一个组</span><br><span class="line">        .usingJobData(&quot;message&quot;, &quot;打印日志&quot;)</span><br><span class="line">        .usingJobData(&quot;count&quot;, 0)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>

<p>（2）修改HelloJob.java</p>
<p>添加count的setter方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private Integer count;</span><br><span class="line">public void setCount(Integer count) &#123;</span><br><span class="line">    this.count &#x3D; count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在public void execute(JobExecutionContext context) throws JobExecutionException的方法中添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">++count;</span><br><span class="line">System.out.println(&quot;count的数量：&quot; +count);</span><br><span class="line">context.getJobDetail().getJobDataMap().put(&quot;count&quot;, count);</span><br></pre></td></tr></table></figure>

<p>HelloJob类没有添加@PersistJobDataAfterExecution注解，每次调用时都会创建一个新的JobDataMap。不会累加。</p>
<p>HelloJob类添加@PersistJobDataAfterExecution注解，多次调用期间可以持有一些状态信息，即可以实现count的累加。</p>
<h3 id="8、Trigger介绍"><a href="#8、Trigger介绍" class="headerlink" title="8、Trigger介绍"></a>8、Trigger介绍</h3><p><a target="_blank" rel="noopener" href="https://github.com/lan7916/itlan_quartz/blob/master/imgs/07.jpg"><img src= "/img/loading.gif" data-lazy-src="https://github.com/lan7916/itlan_quartz/raw/master/imgs/07.jpg" alt="avatar"></a></p>
<p>Quartz有一些不同的触发器类型，不过，用得最多的是SimpleTrigger和CronTrigger。</p>
<p>（1）jobKey + 表示Job实例的标识，触发器被触发时，该指定的Job实例会被执行。</p>
<p>（2）startTime + 表示触发器的时间表，第一次开始被触发的时间，它的数据类型是java.util.Date。</p>
<p>（3）endTime + 指定触发器终止被触发的时间，它的数据类型是java.util.Date。</p>
<p>案例：</p>
<p>HelloJobTrigger.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义任务类</span><br><span class="line">public class HelloJobTrigger implements Job &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void execute(JobExecutionContext context) throws JobExecutionException &#123;</span><br><span class="line">        &#x2F;&#x2F; 输出当前时间</span><br><span class="line">        Date date &#x3D; new Date();</span><br><span class="line">        SimpleDateFormat dateFormat &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        String dateString &#x3D; dateFormat.format(date);</span><br><span class="line">        &#x2F;&#x2F; 工作内容</span><br><span class="line">        System.out.println(&quot;正在进行数据库的备份工作，备份数据库的时间是：&quot; +dateString);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 获取jobKey、startTime、endTime</span><br><span class="line">        Trigger trigger &#x3D; context.getTrigger();</span><br><span class="line">        System.out.println(&quot;jobKey的名称：&quot; +trigger.getJobKey().getName() +&quot;;    jobKey的组名称：&quot; +trigger.getJobKey().getGroup());</span><br><span class="line">        System.out.println(&quot;任务的开始时间：&quot; +dateFormat.format(trigger.getStartTime()) +&quot;;    任务的结束时间：&quot; +dateFormat.format(trigger.getEndTime()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HelloSchedulerDemoTrigger.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class HelloSchedulerDemoTrigger &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 1、调度器（Scheduler），从工厂中获取调度的实例（默认：实例化new StdSchedulerFactory();）</span><br><span class="line">        Scheduler scheduler &#x3D; StdSchedulerFactory.getDefaultScheduler();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 设置任务的开始时间</span><br><span class="line">        Date startDate &#x3D; new Date();</span><br><span class="line">        &#x2F;&#x2F; 任务的开始时间推迟3秒</span><br><span class="line">        startDate.setTime(startDate.getTime() +3000);</span><br><span class="line">        &#x2F;&#x2F; 设置任务的结束时间</span><br><span class="line">        Date endDate &#x3D; new Date();</span><br><span class="line">        &#x2F;&#x2F; 任务的结束时间推迟10秒（10秒后停止）</span><br><span class="line">        endDate.setTime(endDate.getTime() +10000);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 2、任务实例（JobDetail）定义一个任务调度实例，将该实例与HelloJobTrigger绑定，任务类需要实现Job接口</span><br><span class="line">        JobDetail jobDetail &#x3D; JobBuilder.newJob(HelloJobTrigger.class) &#x2F;&#x2F; 加载任务类，与HelloJob完成绑定，要求HelloJob实现Job接口</span><br><span class="line">                .withIdentity(&quot;job1&quot;, &quot;group1&quot;) &#x2F;&#x2F; 参数1：任务的名称（唯一实例）；参数2：任务组的名称</span><br><span class="line">                .usingJobData(&quot;message&quot;, &quot;打印日志&quot;) &#x2F;&#x2F; 传递参数，名称message</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 3、触发器（Trigger）定义触发器，马上执行，然后每5秒重复执行一次</span><br><span class="line">        Trigger trigger &#x3D; TriggerBuilder.newTrigger()</span><br><span class="line">                .withIdentity(&quot;trigger1&quot;, &quot;group1&quot;) &#x2F;&#x2F; 参数1：触发器的名称（唯一实例）；参数2：触发器组的名称</span><br><span class="line">                &#x2F;&#x2F;.startNow() &#x2F;&#x2F; 马上启动触发器</span><br><span class="line">                .withSchedule(SimpleScheduleBuilder.simpleSchedule().repeatSecondlyForever(5)) &#x2F;&#x2F; 5秒重复执行一次</span><br><span class="line">                .startAt(startDate) &#x2F;&#x2F; 设置任务的开始时间</span><br><span class="line">                .endAt(endDate)</span><br><span class="line">                .build();</span><br><span class="line">        &#x2F;&#x2F; 4、让调度器关联任务和触发器，保证按照触发器定义的调整执行任务</span><br><span class="line">        scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 5、启动</span><br><span class="line">        scheduler.start();</span><br><span class="line">        &#x2F;&#x2F; 关闭</span><br><span class="line">        &#x2F;&#x2F;scheduler.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9、SimpleTrigger触发器"><a href="#9、SimpleTrigger触发器" class="headerlink" title="9、SimpleTrigger触发器"></a>9、SimpleTrigger触发器</h3><p>SimpleTrigger对于设置和使用是最为简单的一种QuartzTrigger。</p>
<p>它是为那种需要在特定的日期/时间启动，且以一个可能的间隔时间重复执行n此的Job所设计的。</p>
<p>案例一：表示在一个指定的时间段内，执行一次作业任务；</p>
<p>HelloJobSimpleTrigger.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义任务类</span><br><span class="line">public class HelloJobSimpleTrigger implements Job &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void execute(JobExecutionContext context) throws JobExecutionException &#123;</span><br><span class="line">        &#x2F;&#x2F; 输出当前时间</span><br><span class="line">        Date date &#x3D; new Date();</span><br><span class="line">        SimpleDateFormat dateFormat &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        String dateString &#x3D; dateFormat.format(date);</span><br><span class="line">        &#x2F;&#x2F; 工作内容</span><br><span class="line">        System.out.println(&quot;正在进行数据库的备份工作，备份数据库的时间是：&quot; +dateString);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HelloSchedulerDemoSimpleTrigger.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class HelloSchedulerDemoSimpleTrigger &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 1、调度器（Scheduler），从工厂中获取调度的实例（默认：实例化new StdSchedulerFactory();）</span><br><span class="line">        Scheduler scheduler &#x3D; StdSchedulerFactory.getDefaultScheduler();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 设置任务的开始时间</span><br><span class="line">        Date startDate &#x3D; new Date();</span><br><span class="line">        &#x2F;&#x2F; 任务的开始时间推迟3秒</span><br><span class="line">        startDate.setTime(startDate.getTime() +3000);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 2、任务实例（JobDetail）定义一个任务调度实例，将该实例与HelloJobSimpleTrigger绑定，任务类需要实现Job接口</span><br><span class="line">        JobDetail jobDetail &#x3D; JobBuilder.newJob(HelloJobSimpleTrigger.class) &#x2F;&#x2F; 加载任务类，与HelloJob完成绑定，要求HelloJob实现Job接口</span><br><span class="line">                .withIdentity(&quot;job1&quot;, &quot;group1&quot;) &#x2F;&#x2F; 参数1：任务的名称（唯一实例）；参数2：任务组的名称</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 3、触发器（Trigger）定义触发器，马上执行，然后每5秒重复执行一次</span><br><span class="line">        Trigger trigger &#x3D; TriggerBuilder.newTrigger()</span><br><span class="line">                .withIdentity(&quot;trigger1&quot;, &quot;group1&quot;) &#x2F;&#x2F; 参数1：触发器的名称（唯一实例）；参数2：触发器组的名称</span><br><span class="line">                .startAt(startDate) &#x2F;&#x2F; 设置任务的开始时间</span><br><span class="line">                .build();</span><br><span class="line">        &#x2F;&#x2F; 4、让调度器关联任务和触发器，保证按照触发器定义的调整执行任务</span><br><span class="line">        scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 5、启动</span><br><span class="line">        scheduler.start();</span><br><span class="line">        &#x2F;&#x2F; 关闭</span><br><span class="line">        &#x2F;&#x2F;scheduler.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例二：或在指定的时间间隔内多次执行作业任务。</p>
<p>修改HelloSchedulerDemoSimpleTrigger.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 3、触发器（Trigger）定义触发器，马上执行，然后每5秒重复执行一次</span><br><span class="line">Trigger trigger &#x3D; TriggerBuilder.newTrigger()</span><br><span class="line">        .withIdentity(&quot;trigger1&quot;, &quot;group1&quot;) &#x2F;&#x2F; 参数1：触发器的名称（唯一实例）；参数2：触发器组的名称</span><br><span class="line">        .startAt(startDate) &#x2F;&#x2F; 设置任务的开始时间</span><br><span class="line">        .withSchedule(SimpleScheduleBuilder.simpleSchedule().repeatSecondlyForever(5).withRepeatCount(2))  &#x2F;&#x2F; 每5秒执行一次，连续执行3次后停止，默认是0</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>

<p>案例三：指定任务的结束时间。</p>
<p>修改HelloSchedulerDemoSimpleTrigger.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 设置任务的结束时间</span><br><span class="line">Date endDate &#x3D; new Date();</span><br><span class="line">&#x2F;&#x2F; 启动结束，任务在当前时间10秒后停止</span><br><span class="line">endDate.setTime(endDate.getTime() +10000);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2、任务实例（JobDetail）定义一个任务调度实例，将该实例与HelloJobSimpleTrigger绑定，任务类需要实现Job接口</span><br><span class="line">JobDetail jobDetail &#x3D; JobBuilder.newJob(HelloJobSimpleTrigger.class) &#x2F;&#x2F; 加载任务类，与HelloJob完成绑定，要求HelloJob实现Job接口</span><br><span class="line">        .withIdentity(&quot;job1&quot;, &quot;group1&quot;) &#x2F;&#x2F; 参数1：任务的名称（唯一实例）；参数2：任务组的名称</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3、触发器（Trigger）定义触发器，马上执行，然后每5秒重复执行一次</span><br><span class="line">Trigger trigger &#x3D; TriggerBuilder.newTrigger()</span><br><span class="line">        .withIdentity(&quot;trigger1&quot;, &quot;group1&quot;) &#x2F;&#x2F; 参数1：触发器的名称（唯一实例）；参数2：触发器组的名称</span><br><span class="line">        .startAt(startDate) &#x2F;&#x2F; 设置任务的开始时间</span><br><span class="line">        .endAt(endDate) &#x2F;&#x2F; 设置任务的结束时间</span><br><span class="line">        .withSchedule(SimpleScheduleBuilder.simpleSchedule().repeatSecondlyForever(5).withRepeatCount(2))  &#x2F;&#x2F; 每5秒执行一次，连续执行3次后停止，默认是0</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的点</p>
</blockquote>
<ul>
<li>SimpleTrigger的属性有：开始时间、结束时间、重复次数和重复的时间间隔。</li>
<li>重复次数属性的值可以为0、正整数、或常量SimpleTrigger.REPEAT_INDEFINITELY。</li>
<li>重复的时间间隔属性值必须为大于0或者长整形的正整数，以毫秒作为时间单位，当重复的时间间隔为0时，意味着与Trigger同时触发执行。</li>
<li>如果有指定结束时间属性值，则结束时间属性优先于重复次数属性，这样的好处在于：当我们需要创建一个每间隔10秒触发一次直到指定的结束时间的Trigger，而无需去计算从开始到结束的所重复的次数，我们只需简单的指定结束时间和使用REPEAT_INDEFINITELY作为重复次数的属性值即可。</li>
</ul>
<h3 id="10、CronTrigger触发器"><a href="#10、CronTrigger触发器" class="headerlink" title="10、CronTrigger触发器"></a>10、CronTrigger触发器</h3><p>如果你需要像日历那样按日程来触发任务，而不是像SimpleTrigger那样每隔特定的间隔时间触发，CronTrigger通常比SimpleTrigger更有用，因为它是基于日历的作业调度器。</p>
<p>使用CronTrigger，你可以指定诸如“每个周五中午”，或者“每个工作日的9:30”或者“从每个周一、周三、周五的上午9:00到上午10:00之间每个五分钟”这样日程安排来触发。甚至，像SimpleTrigger一样，CronTrigger也有一个startTime以指定日程从什么时候开始，也有一个（可选的）endTime以指定何时日程不再继续。</p>
<p>（1）Cron Expressions——Cron表达式</p>
<p>Cron表达式被用来配置CronTrigger实例。Cron表达式是一个由7个子表达式组成的字符串。每个子表达式都描述了一个单独的日程细节。这些子表达式用空格分隔，分别表示：</p>
<p>. Seconds 秒 . Minutes 分钟 . Hours 小时 . Day-of-Month 月中的天 . Month 月 . Day-of-Week 周中的天 . Year（optional field）年（可选的域）</p>
<p>取值：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/lan7916/itlan_quartz/blob/master/imgs/08.jpg"><img src= "/img/loading.gif" data-lazy-src="https://github.com/lan7916/itlan_quartz/raw/master/imgs/08.jpg" alt="avatar"></a></p>
<p>单个子表达式可以包含范围或者列表。例如：前面例子中的周中的天这个域（这里是“WED”）可以被替换为“MON-FRI”，“MON,WED,FRI”或者甚至“MON-WED,SAT”。</p>
<p>所有的域中的值都有特定的合法范围，这些值的合法范围相当明显，例如：秒和分域的合法值为0到59，小时的合法范围是0到23，Day-of-Month中值的合法范围是1到31，但是需要注意不同的月份中的天数不同。月份的合法值是1到12.或者用字符串JAN,FEB,MAR,APR,MAY,JUN,JUL,AUG,SEP,OCT,NOV及DEC来表示。Day-of-Week可以用1到7来表示（1=星期日）或者用字符串SUN,MON,TUE,WED,THU,FRI和SAT来表示。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/lan7916/itlan_quartz/blob/master/imgs/09.jpg"><img src= "/img/loading.gif" data-lazy-src="https://github.com/lan7916/itlan_quartz/raw/master/imgs/09.jpg" alt="avatar"></a></p>
<p>练习一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&quot;0 0 10,14,16 * * ?&quot; 每天上午10点，下午2点，4点</span><br><span class="line">&quot;0 0&#x2F;30 9-17 * * ?&quot; 朝九晚五工作时间内每半小时，从0分开始每隔30分钟发送一次</span><br><span class="line">&quot;0 0 12 ? * WED&quot; 表示每个星期三中午12点</span><br><span class="line">&quot;0 0 12 * * ?&quot; 每天中午12点触发</span><br><span class="line">&quot;0 15 10 ? * *&quot; 每天上午10:15触发</span><br><span class="line">&quot;0 15 10 * * ?&quot; 每天上午10:15触发</span><br><span class="line">&quot;0 15 10 * * ? *&quot; 每天上午10:15触发</span><br><span class="line">&quot;0 15 10 * * ? 2005&quot; 2005年的每天上午10:15触发</span><br><span class="line">&quot;0 * 14 * * ?&quot; 在每天下午2点到下午2:59期间的每1分钟触发</span><br><span class="line">&quot;0 0&#x2F;55 14 * * ?&quot; 在每天下午2点到下午2:59期间，从0开始到55分钟触发</span><br><span class="line">&quot;0 0&#x2F;55 14,18 * * ?&quot; 在每天下午2点到下午2:59期间和下午6点到6:55期间，从0开始到55分钟触发</span><br><span class="line">&quot;0 0-5 14 * * ?&quot; 在每天下午2点到下午2:05期间的每1分钟触发</span><br><span class="line">&quot;0 10,44 14 ? 3 WED&quot; 每年3月的星期三的下午2:10和2:44触发</span><br><span class="line">&quot;0 15 10 ? * MON-FRI&quot; 周一到周五的上午10:15触发</span><br><span class="line">&quot;0 15 10 15 * ?&quot; 每月15日上午10:15触发</span><br><span class="line">&quot;0 15 10 L * ?&quot; 每月最后一日的上午10:15触发</span><br><span class="line">&quot;0 15 10 ? * 6L&quot; 每月的最后一个星期五上午10:15触发</span><br><span class="line">&quot;0 15 10 ? * 6L 2002-2005&quot; 2002年至2005年的每月的最后一个星期五上午10:15触发</span><br><span class="line">&quot;0 15 10 ? * 6#3&quot; 每月的第三个星期五上午10:15触发</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<p>HelloJobCronTrigger.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义任务类</span><br><span class="line">public class HelloJobCronTrigger implements Job &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void execute(JobExecutionContext context) throws JobExecutionException &#123;</span><br><span class="line">        &#x2F;&#x2F; 输出当前时间</span><br><span class="line">        Date date &#x3D; new Date();</span><br><span class="line">        SimpleDateFormat dateFormat &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        String dateString &#x3D; dateFormat.format(date);</span><br><span class="line">        &#x2F;&#x2F; 工作内容</span><br><span class="line">        System.out.println(&quot;正在进行数据库的备份工作，备份数据库的时间是：&quot; +dateString);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HelloSchedulerDemoCronTrigger.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class HelloSchedulerDemoCronTrigger &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 1、调度器（Scheduler），从工厂中获取调度的实例（默认：实例化new StdSchedulerFactory();）</span><br><span class="line">        Scheduler scheduler &#x3D; StdSchedulerFactory.getDefaultScheduler();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 2、任务实例（JobDetail）定义一个任务调度实例，将该实例与HelloJobSimpleTrigger绑定，任务类需要实现Job接口</span><br><span class="line">        JobDetail jobDetail &#x3D; JobBuilder.newJob(HelloJobCronTrigger.class) &#x2F;&#x2F; 加载任务类，与HelloJob完成绑定，要求HelloJob实现Job接口</span><br><span class="line">                .withIdentity(&quot;job1&quot;, &quot;group1&quot;) &#x2F;&#x2F; 参数1：任务的名称（唯一实例）；参数2：任务组的名称</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 3、触发器（Trigger）定义触发器，马上执行，然后每5秒重复执行一次</span><br><span class="line">        Trigger trigger &#x3D; TriggerBuilder.newTrigger()</span><br><span class="line">                .withIdentity(&quot;trigger1&quot;, &quot;group1&quot;) &#x2F;&#x2F; 参数1：触发器的名称（唯一实例）；参数2：触发器组的名称</span><br><span class="line">                .withSchedule(CronScheduleBuilder.cronSchedule(&quot;0&#x2F;5 * * * * ?&quot;))  &#x2F;&#x2F; 日历</span><br><span class="line">                .build();</span><br><span class="line">        &#x2F;&#x2F; 4、让调度器关联任务和触发器，保证按照触发器定义的调整执行任务</span><br><span class="line">        scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 5、启动</span><br><span class="line">        scheduler.start();</span><br><span class="line">        &#x2F;&#x2F; 关闭</span><br><span class="line">        &#x2F;&#x2F;scheduler.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小提示</p>
</blockquote>
<ul>
<li>“L”和“W”可以一起使用。（企业可用在工资计算）</li>
<li>“#”可表示月中第几个周几。（企业可用在计算母亲节和父亲节）</li>
<li>周字段英文字母不区分大小写，例如MON=mon</li>
<li>利用工具，在线生成</li>
</ul>
<h3 id="11、配置、资源SchedulerFactory"><a href="#11、配置、资源SchedulerFactory" class="headerlink" title="11、配置、资源SchedulerFactory"></a>11、配置、资源SchedulerFactory</h3><p>Quartz以模块方式架构，因此，要使它运行，几个组件必须很好的咬合在一起。幸运的是，已经有了一些现存的助手可以完成这些工作。</p>
<p>所有的Scheduler实例由SchedulerFactory创建。</p>
<p>Quartz的三个核心概念：调度器、任务、触发器，三者之间的关系是：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/lan7916/itlan_quartz/blob/master/imgs/10.jpg"><img src= "/img/loading.gif" data-lazy-src="https://github.com/lan7916/itlan_quartz/raw/master/imgs/10.jpg" alt="avatar"></a></p>
<p>大家都知道，一个作业，比较重要的三个要素就是Scheduler，JobDetail，Trigger；而Trigger对于Job而言就好比一个驱动器，没有触发器来定时驱动作业，作业就无法运行；对于Job而言，一个Job可以对应多个Trigger，但对于Trigger而言，一个Trigger只能对应一个Job，所以一个Trigger只能被指派给一个Job；如果你需要一个更负责的触发计划，你可以创建多个Trigger并指派它们给同一个Job。</p>
<p>Scheduler的创建方式：</p>
<p>（1）StdSchedulerFactory：</p>
<p>Quartz默认的SchedulerFactory</p>
<ul>
<li>使用一组参数（java.util.Properties）来创建和初始化Quartz调度器</li>
<li>配置参数一般存储在quartz.properties文件中</li>
<li>调用getScheduler方法就能创建和初始化调度器对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SchedulerFactory schedulerFactory &#x3D; new StdSchedulerFactory();</span><br><span class="line">Scheduler scheduler &#x3D; schedulerFactory.getScheduler();</span><br></pre></td></tr></table></figure>

<p>用法一：输出调度器开始的时间（重要：使得任务和触发器进行关联）：</p>
<p>Date schedulerjob(JobDetail jobDetail, Trigger trigger)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat dateFormat &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">System.out.println(&quot;调度器的开始时间是： &quot; +dateFormat.format(schedulerjob(jobDetail, trigger)));</span><br></pre></td></tr></table></figure>

<p>用法二：启动任务调度：</p>
<p>void start();</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheduler.start();</span><br></pre></td></tr></table></figure>

<p>用法三：任务调度挂起，即暂停操作</p>
<p>void standby();</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Scheduler执行2秒后挂起</span><br><span class="line">Thread.sleep(2000L);</span><br><span class="line">scheduler.standby();</span><br><span class="line">&#x2F;&#x2F; Scheduler执行5秒后自动开启</span><br><span class="line">Thread.sleep(5000L);</span><br><span class="line">scheduler.start();</span><br></pre></td></tr></table></figure>

<p>用法四：关闭任务调度</p>
<p>void shutdown();</p>
<p>shutdown(true)：表示等待所有正在执行的Job执行完毕之后，再关闭Scheduler + shutdown(false)： 表示直接关闭Scheduler</p>
<p>测试一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Scheduler执行2秒后挂起</span><br><span class="line">Thread.sleep(2000L);</span><br><span class="line">scheduler.shutdown();</span><br><span class="line">&#x2F;&#x2F; Scheduler执行5秒后自动开启</span><br><span class="line">Thread.sleep(5000L);</span><br><span class="line">scheduler.start();</span><br></pre></td></tr></table></figure>

<p>测试二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Scheduler执行2秒后挂起</span><br><span class="line">Thread.sleep(2000L);</span><br><span class="line">&#x2F;**</span><br><span class="line"> * shutdown(true)：表示等待所有正在执行的Job执行完毕之后，再关闭Scheduler</span><br><span class="line"> * shutdown(false)： 表示直接关闭Scheduler</span><br><span class="line"> *&#x2F;</span><br><span class="line">scheduler.shutdown(false);</span><br><span class="line">System.out.println(&quot;Scheduler是否被关闭：&quot; +scheduler.isShutdown());</span><br></pre></td></tr></table></figure>

<p>同时修改HelloJobScheduler.java + 任务调度延迟5秒执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 延迟任务执行的时间，推迟5秒后执行</span><br><span class="line">try &#123;</span><br><span class="line">    Thread.sleep(5000L);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">    &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）DirectSchedulerFactory（了解）：</p>
<p>DirectSchedulerFactory是对SchedulerFactory的直接实现，通过它可以直接构建Scheduler、ThreadPool等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DirectSchedulerFactory directSchedulerFactory &#x3D; DirectSchedulerFactory.getInstance();</span><br><span class="line">Scheduler scheduler &#x3D; directSchedulerFactory.getScheduler();</span><br></pre></td></tr></table></figure>

<h3 id="12、Quartz-properties"><a href="#12、Quartz-properties" class="headerlink" title="12、Quartz.properties"></a>12、Quartz.properties</h3><p>默认路径：quartz-2.3.0中的org.quartz中的quartz.properties</p>
<p><a target="_blank" rel="noopener" href="https://github.com/lan7916/itlan_quartz/blob/master/imgs/11.jpg"><img src= "/img/loading.gif" data-lazy-src="https://github.com/lan7916/itlan_quartz/raw/master/imgs/11.jpg" alt="avatar"></a></p>
<p>我们也可以在项目的资源下添加quartz.properties文件，去覆盖底层的配置文件。</p>
<p><em>组成部分：</em></p>
<ul>
<li>调度器属性</li>
</ul>
<p>org.quartz.scheduler.instanceName属性用来区分特定的调度器实例，可以按照功能用途来给调度器起名。</p>
<p>org.quartz.scheduler.instanceId属性和前者一样，也允许任何字符串，但这个值必须在所有调度器实例中是唯一的，尤其是在一个集群环境中，所为集群的唯一key。假如你想Quartz帮你生成这个值的话，可以设置为AUTO。</p>
<ul>
<li>线程池设置</li>
</ul>
<p>threadCount + 处理Job的线程个数，至少为1，但最多的话最好不要超过100，在多数机器上设置该值超过100的话就会显得相当不实用了，特别是在你的Job执行时间较长的情况下。</p>
<p>threadPriority + 线程的优先级，优先级别高的线程比级别低的线程优先得到执行。最小为1，最大为10，默认为5</p>
<p>org.quartz.threadPool.class + 一个实现了org.quartz.spi.threadPool接口的类，Quartz自带的线程池实现类是org.quartz.simpl.SimpleThreadPool</p>
<ul>
<li>作业存储设置</li>
</ul>
<p>描述了在调度器实例的生命周期中，Job和Trigger信息是如何被存储的。</p>
<ul>
<li>插件配置</li>
</ul>
<p>满足特定需求用到的Quartz插件的配置。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">#Configure Main Scheduler Properties 调度器属性</span><br><span class="line">#&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">#调度器的实例名</span><br><span class="line">org.quartz.scheduler.instanceName &#x3D; QuartzScheduler</span><br><span class="line">#调度器的实例ID，大多数情况设置为AUTO即可</span><br><span class="line">org.quartz.scheduler.instanceId &#x3D; AUTO</span><br><span class="line"></span><br><span class="line">#&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">#Configure ThreadPool 线程池属性</span><br><span class="line">#&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">#处理Job的线程个数，至少为1，但最多的话最好不要超过100，在多数机器上设置该值超过100的话显得相当不实用了，特别是在你的Job执行时间较长的情况下</span><br><span class="line">org.quartz.threadPool.threadCount &#x3D;  5</span><br><span class="line">#线程的优先级，优先级别搞的线程比优先级别低的线程优先得到执行。最小为1，最大为10，默认为5</span><br><span class="line">org.quartz.threadPool.threadPriority &#x3D; 5</span><br><span class="line">#一个实现了org.quartz.spi.threadPool接口的类，Quartz自带的线程池实现类是org.quartz.simpl.SimpleThreadPool</span><br><span class="line">org.quartz.threadPool.class &#x3D; org.quartz.simpl.SimpleThreadPool</span><br><span class="line"></span><br><span class="line">#&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">#Configure JobStore 作业存储设置</span><br><span class="line">#&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">#要使Job存储在内存中需要通过设置org.quartz.jobStore.class 属性为org.quartz.simpl.RAMJobStore</span><br><span class="line">org.quartz.jobStore.class &#x3D; org.quartz.simpl.RAMJobStore</span><br><span class="line"></span><br><span class="line">#&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">#Configure Plugins 插件配置</span><br><span class="line">#&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">org.quartz.plugin.jobInitializer.class &#x3D; org.quartz.plugins.xml.JobInitializationPlugin</span><br><span class="line"></span><br><span class="line">org.quartz.plugin.jobInitializer.overWriteExistingJobs &#x3D; true</span><br><span class="line">org.quartz.plugin.jobInitializer.failOnFileNotFound &#x3D; true</span><br><span class="line">org.quartz.plugin.jobInitializer.validating&#x3D;false</span><br></pre></td></tr></table></figure>

<p>也可以编写程序代码操作quartz.properties文件的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class QuartzProperties &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 创建工厂实例</span><br><span class="line">        StdSchedulerFactory schedulerFactory &#x3D; new StdSchedulerFactory();</span><br><span class="line">        &#x2F;&#x2F; 创建配置工厂的属性的对象</span><br><span class="line">        Properties prop &#x3D; new Properties();</span><br><span class="line">        prop.put(StdSchedulerFactory.PROP_THREAD_POOL_CLASS, &quot;org.quartz.simpl.SimpleThreadPool&quot;);</span><br><span class="line">        prop.put(&quot;org.quartz.threadPool.threadCount&quot;, &quot;5&quot;);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 加载上面定义的属性</span><br><span class="line">            schedulerFactory.initialize(prop);</span><br><span class="line"></span><br><span class="line">            Scheduler scheduler &#x3D; schedulerFactory.getScheduler();</span><br><span class="line"></span><br><span class="line">            scheduler.start();</span><br><span class="line">        &#125; catch (SchedulerException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过Properties设置工厂属性的缺点在于用硬编码，假如需要修改例子中线程数量，将不得不修改代码，然后重新编译。我们这里不推荐使用。</p>
<h2 id="八、Quartz监听器"><a href="#八、Quartz监听器" class="headerlink" title="八、Quartz监听器"></a>八、Quartz监听器</h2><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><p>Quartz的监听器用于当任务调度中你所关注事件发生时，能够及时获取这一事件的通知。类似于任务执行过程中的邮件、短信类的提醒。Quartz监听器主要由JobListener、TriggerListener、SchedulerListener三种，顾名思义，分布表示任务、触发器、调度器对应的监听器。三者的使用方法类似，在开始介绍三种监听器之前，需要明确两个概念：全局监听器与非全局监听器，二者的区别在于：</p>
<ul>
<li>全局监听器能够接收到所有的Job/Trigger的事件通知</li>
<li>而非全局监听器只能接收到在其上注册的Job或者Trigger的事件，不在其上注册的Job或Trigger则不会进行监听。</li>
</ul>
<p>本课程关于全局与非全局的监听器的使用，将一一介绍。</p>
<h3 id="2、JobListener"><a href="#2、JobListener" class="headerlink" title="2、JobListener"></a>2、JobListener</h3><p>任务调度过程中，与任务Job相关的事件包括：Job开始要执行的提示；Job执行完成的提示等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface JobListener &#123;</span><br><span class="line">    public String getName();</span><br><span class="line">    public void jobToBeExecuted(JobExecutionContext context);</span><br><span class="line">    public void jobExecutionVetoed(JobExecutionContext context);</span><br><span class="line">    public void jobWasExecuted(JobExecutionContext context, JobExecutionException jobException);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>其中：</em></p>
<p>. getName方法：用于获取该JobListener的名称。 . jobToBeExecuted方法：Scheduler在JobDetail将要被执行时调用这个方法。 . jobExecutionVetoed方法：Scheduler在JobDetail即将被执行，但又被TriggerListener否决时会调用该方法。 . jobWasExecuted方法：Scheduler在JobDetail被执行之后调用这个方法。</p>
<p>示例：</p>
<p>HelloJobListener.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义任务类</span><br><span class="line">public class HelloJobListener implements Job &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void execute(JobExecutionContext context) throws JobExecutionException &#123;</span><br><span class="line">        &#x2F;&#x2F; 输出当前时间</span><br><span class="line">        Date date &#x3D; new Date();</span><br><span class="line">        SimpleDateFormat dateFormat &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        String dateString &#x3D; dateFormat.format(date);</span><br><span class="line">        &#x2F;&#x2F; 工作内容</span><br><span class="line">        System.out.println(&quot;正在进行数据库的备份工作，备份数据库的时间是：&quot; +dateString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建自定义的JobListener</p>
<p>MyJobListener.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class MyJobListener implements JobListener &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        String name &#x3D; this.getClass().getSimpleName();</span><br><span class="line">        System.out.println(&quot;监听器的名称是：&quot; +name);</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void jobToBeExecuted(JobExecutionContext context) &#123;</span><br><span class="line">        String name &#x3D; context.getJobDetail().getKey().getName();</span><br><span class="line">        System.out.println(&quot;Job的名称是：&quot; +name + &quot;          Scheduler在JobDetail将要被执行时调用的方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void jobExecutionVetoed(JobExecutionContext context) &#123;</span><br><span class="line">        String name &#x3D; context.getJobDetail().getKey().getName();</span><br><span class="line">        System.out.println(&quot;Job的名称是：&quot; +name + &quot;          Scheduler在JobDetail即将被执行，但又被TriggerListener否决时会调用该方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void jobWasExecuted(JobExecutionContext context, JobExecutionException jobException) &#123;</span><br><span class="line">        String name &#x3D; context.getJobDetail().getKey().getName();</span><br><span class="line">        System.out.println(&quot;Job的名称是：&quot; +name + &quot;          Scheduler在JobDetail被执行之后调用这个方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行调度器</p>
<p>HelloSchedulerDemoJobListener.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class HelloSchedulerDemoJobListener &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 1、调度器（Scheduler），从工厂中获取调度的实例（默认：实例化new StdSchedulerFactory();）</span><br><span class="line">        Scheduler scheduler &#x3D; StdSchedulerFactory.getDefaultScheduler();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 2、任务实例（JobDetail）定义一个任务调度实例，将该实例与HelloJobSimpleTrigger绑定，任务类需要实现Job接口</span><br><span class="line">        JobDetail jobDetail &#x3D; JobBuilder.newJob(HelloJobListener.class) &#x2F;&#x2F; 加载任务类，与HelloJob完成绑定，要求HelloJob实现Job接口</span><br><span class="line">                .withIdentity(&quot;job1&quot;, &quot;group1&quot;) &#x2F;&#x2F; 参数1：任务的名称（唯一实例）；参数2：任务组的名称</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 3、触发器（Trigger）定义触发器，马上执行，然后每5秒重复执行一次</span><br><span class="line">        Trigger trigger &#x3D; TriggerBuilder.newTrigger()</span><br><span class="line">                .withIdentity(&quot;trigger1&quot;, &quot;group1&quot;) &#x2F;&#x2F; 参数1：触发器的名称（唯一实例）；参数2：触发器组的名称</span><br><span class="line">                .startNow()</span><br><span class="line">                .withSchedule(SimpleScheduleBuilder.simpleSchedule().repeatSecondlyForever(5).withRepeatCount(2))  &#x2F;&#x2F; 每5秒执行一次，连续执行3次后停止，默认是0</span><br><span class="line">                .build();</span><br><span class="line">        &#x2F;&#x2F; 4、让调度器关联任务和触发器，保证按照触发器定义的调整执行任务</span><br><span class="line">        scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 创建并注册一个全局的Job Listener</span><br><span class="line">        &#x2F;&#x2F; scheduler.getListenerManager().addJobListener(new MyJobListener(), EverythingMatcher.allJobs());</span><br><span class="line">        &#x2F;&#x2F; 创建并注册一个局部的Job Listener，表示指定的任务Job</span><br><span class="line">        scheduler.getListenerManager().addJobListener(new MyJobListener(), KeyMatcher.keyEquals(JobKey.jobKey(&quot;job1&quot;, &quot;group1&quot;)));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 5、启动</span><br><span class="line">        scheduler.start();</span><br><span class="line">        &#x2F;&#x2F; 关闭</span><br><span class="line">        &#x2F;&#x2F;scheduler.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、TriggerListener"><a href="#3、TriggerListener" class="headerlink" title="3、TriggerListener"></a>3、TriggerListener</h3><p>任务调度过程中，与触发器Trigger相关的事件包括：触发器触发、触发器未正确触发、触发器完成等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface TriggerListener &#123;</span><br><span class="line">    public String getName();</span><br><span class="line">    public void triggerFired(Trigger trigger, JobExecutionContext context);</span><br><span class="line">    public boolean vetoJobExecution(Trigger trigger, JobExecutionContext context);</span><br><span class="line">    public void triggerMisfired(Trigger trigger);</span><br><span class="line">    public void triggerComplete(Trigger trigger, JobExecutionContext context,            CompletedExecutionInstruction triggerInstructionCode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>其中：</em></p>
<p>. getName方法：用于获取触发器的名称。 . triggerFired方法：当与监听器关联的Trigger被触发，Job上的Execute()方法将被执行时，Scheduler就调用该方法。 . vetoJobExecution方法：在Trigger触发后，Job将要执行时由Scheduler调用这个方法。TriggerListener给了一个选择去否决Job的执行。假如这个方法返回true，这个Job将不会为此次Trigger触发而得到执行。 . triggerMisfired方法：Scheduler调用这个方法是在Trigger错过触发时。你应该关注此方法中持续时间长的逻辑：在出现许多错过触发的Trigger时，长逻辑会导致骨牌效应。你应当保持这个方法尽量的小。 . triggerComplete方法：Trigger被触发并且完成了Job的执行时，Scheduler调用这个方法。</p>
<p>示例：</p>
<p>下面的例子简单展示了TriggerListener的使用，其中创建并注册TriggerListener与JobListener几乎类似。</p>
<p>HelloJobListener.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义任务类</span><br><span class="line">public class HelloJobListener implements Job &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void execute(JobExecutionContext context) throws JobExecutionException &#123;</span><br><span class="line">        &#x2F;&#x2F; 输出当前时间</span><br><span class="line">        Date date &#x3D; new Date();</span><br><span class="line">        SimpleDateFormat dateFormat &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        String dateString &#x3D; dateFormat.format(date);</span><br><span class="line">        &#x2F;&#x2F; 工作内容</span><br><span class="line">        System.out.println(&quot;正在进行数据库的备份工作，备份数据库的时间是：&quot; +dateString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MyTriggerListener.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class MyTriggerListener implements TriggerListener &#123;</span><br><span class="line">    </span><br><span class="line">    private String name;</span><br><span class="line">    &#x2F;&#x2F; 构造方法，自定义传递触发器的名称，默认是类的名称</span><br><span class="line">    public MyTriggerListener(String name) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return this.name;  &#x2F;&#x2F; 不返还会抛出一个名称为空的异常</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;    @Override</span><br><span class="line">&#x2F;&#x2F;    public String getName() &#123;</span><br><span class="line">&#x2F;&#x2F;        String name &#x3D; this.getClass().getSimpleName();</span><br><span class="line">&#x2F;&#x2F;        System.out.println(&quot;触发器的名称：&quot; +name);</span><br><span class="line">&#x2F;&#x2F;        return name;  &#x2F;&#x2F; 不返还会抛出一个名称为空的异常</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void triggerFired(Trigger trigger, JobExecutionContext context) &#123;</span><br><span class="line">        String name &#x3D; this.getClass().getSimpleName();</span><br><span class="line">        System.out.println(name +&quot;被触发&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean vetoJobExecution(Trigger trigger, JobExecutionContext context) &#123;</span><br><span class="line">        String name &#x3D; this.getClass().getSimpleName();</span><br><span class="line">        &#x2F;&#x2F; TriggerListener给了一个选择去否决Job的执行。假如这个方法返回true，这个Job将不会为此次Trigger触发而得到执行。</span><br><span class="line">        System.out.println(name +&quot; 没有被触发&quot;);</span><br><span class="line">        return false;  &#x2F;&#x2F; true:表示不会执行Job的方法</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void triggerMisfired(Trigger trigger) &#123;</span><br><span class="line">        String name &#x3D; this.getClass().getSimpleName();</span><br><span class="line">        &#x2F;&#x2F; Scheduler调用这个方法是在Trigger错过触发时</span><br><span class="line">        System.out.println(name +&quot; 错过触发&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void triggerComplete(Trigger trigger, JobExecutionContext context,</span><br><span class="line">            CompletedExecutionInstruction triggerInstructionCode) &#123;</span><br><span class="line">        String name &#x3D; this.getClass().getSimpleName();</span><br><span class="line">        &#x2F;&#x2F; Trigger被触发并且完成了Job的执行时，Scheduler调用这个方法。</span><br><span class="line">        System.out.println(name +&quot; 完成之后触发&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HelloSchedulerDemoTriggerListener.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class HelloSchedulerDemoTriggerListener &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 1、调度器（Scheduler），从工厂中获取调度的实例（默认：实例化new StdSchedulerFactory();）</span><br><span class="line">        Scheduler scheduler &#x3D; StdSchedulerFactory.getDefaultScheduler();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 2、任务实例（JobDetail）定义一个任务调度实例，将该实例与HelloJobSimpleTrigger绑定，任务类需要实现Job接口</span><br><span class="line">        JobDetail jobDetail &#x3D; JobBuilder.newJob(HelloJobListener.class) &#x2F;&#x2F; 加载任务类，与HelloJob完成绑定，要求HelloJob实现Job接口</span><br><span class="line">                .withIdentity(&quot;job1&quot;, &quot;group1&quot;) &#x2F;&#x2F; 参数1：任务的名称（唯一实例）；参数2：任务组的名称</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 3、触发器（Trigger）定义触发器，马上执行，然后每5秒重复执行一次</span><br><span class="line">        Trigger trigger &#x3D; TriggerBuilder.newTrigger()</span><br><span class="line">                .withIdentity(&quot;trigger1&quot;, &quot;group1&quot;) &#x2F;&#x2F; 参数1：触发器的名称（唯一实例）；参数2：触发器组的名称</span><br><span class="line">                .startNow()</span><br><span class="line">                .withSchedule(SimpleScheduleBuilder.simpleSchedule().repeatSecondlyForever(5).withRepeatCount(2))  &#x2F;&#x2F; 每5秒执行一次，连续执行3次后停止，默认是0</span><br><span class="line">                .build();</span><br><span class="line">        &#x2F;&#x2F; 4、让调度器关联任务和触发器，保证按照触发器定义的调整执行任务</span><br><span class="line">        scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 创建并注册一个全局的Trigger Listener</span><br><span class="line">        &#x2F;&#x2F; scheduler.getListenerManager().addTriggerListener(new MyTriggerListener(), EverythingMatcher.allTriggers());</span><br><span class="line">        &#x2F;&#x2F; 创建并注册一个局部的Trigger Listener</span><br><span class="line">        scheduler.getListenerManager().addTriggerListener(new MyTriggerListener(), KeyMatcher.keyEquals(TriggerKey.triggerKey(&quot;trigger1&quot;, &quot;group1&quot;)));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 5、启动</span><br><span class="line">        scheduler.start();</span><br><span class="line">        &#x2F;&#x2F; 关闭</span><br><span class="line">        &#x2F;&#x2F;scheduler.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、SchedulerListener"><a href="#4、SchedulerListener" class="headerlink" title="4、SchedulerListener"></a>4、SchedulerListener</h3><p>SchedulerListener会在Scheduler的生命周期中关键事件发生时被调用。与Scheduler有关的事件包括：增加一个Job/Trigger，删除一个Job/Trigger，Scheduler发生严重错误，关闭Scheduler等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public interface SchedulerListener &#123;</span><br><span class="line">    public void jobScheduled(Trigger trigger);</span><br><span class="line">    public void jobUnscheduled(TriggerKey triggerKey);</span><br><span class="line">    public void triggerFinalized(Trigger trigger);</span><br><span class="line">    public void triggersPaused(String triggerGroup);</span><br><span class="line">    public void triggersResumed(String triggerGroup);</span><br><span class="line">    public void jobsPaused(String jobGroup);</span><br><span class="line">    public void jobsResumed(String jobGroup);</span><br><span class="line">    public void schedulerError(String msg, SchedulerException cause);</span><br><span class="line">    public void schedulerStarted();</span><br><span class="line">    public void schedulerInStandbyMode();</span><br><span class="line">    public void schedulerShutdown();</span><br><span class="line">    public void schedulingDataCleared()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>其中：</em></p>
<p>. jobScheduled方法：用于部署JobDetail时调用。 . jobUnscheduled方法：用于卸载JobDetail时调用。 . triggerFinalized方法：当一个Trigger来到了再也不会触发的状态时调用这个方法。除非这个Job已设置成了持久性，否则它就会从Scheduler中移除。 . triggersPaused方法：Scheduler调用这个方法是发生在一个Trigger或Trigger组被暂停时。假如是Trigger组的话，triggerName参数将为null。 . triggersResumed方法：Scheduler调用这个方法是发生在一个Trigger或Trigger组从暂停中恢复时。假如是Trigger组的话，triggerName参数将为null。 . jobsPaused方法：当一个或一组JobDetail暂停时调用这个方法。 . jobsResumed方法：当一个或一组Job从暂停上恢复时调用这个方法。假如是一个Job组，jobName将为null。 . schedulerError方法：在Scheduler的正常运行期间产生一个严重错误时调用这个方法。 . schedulerStarted方法：当Scheduler开启时，调用该方法。 . schedulerInStandbyMode方法：当Scheduler处于StandBy模式时，调用该方法。 . schedulerShutdown方法：当Scheduler停止时，调用该方法。 . schedulingDataCleared方法：当Scheduler中的数据被清除时，调用该方法。</p>
<p>示例：</p>
<p>下面的代码简单描述了如何使用SchedulerListener方法：</p>
<p>HelloJobListener.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义任务类</span><br><span class="line">public class HelloJobListener implements Job &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void execute(JobExecutionContext context) throws JobExecutionException &#123;</span><br><span class="line">        &#x2F;&#x2F; 输出当前时间</span><br><span class="line">        Date date &#x3D; new Date();</span><br><span class="line">        SimpleDateFormat dateFormat &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        String dateString &#x3D; dateFormat.format(date);</span><br><span class="line">        &#x2F;&#x2F; 工作内容</span><br><span class="line">        System.out.println(&quot;正在进行数据库的备份工作，备份数据库的时间是：&quot; +dateString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MySchedulerListener.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">public class MySchedulerListener implements SchedulerListener &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void jobScheduled(Trigger trigger) &#123;</span><br><span class="line">        String name &#x3D; trigger.getKey().getName();</span><br><span class="line">        &#x2F;&#x2F; 用于部署JobDetail时调用</span><br><span class="line">        System.out.println(name +&quot; 完成部署&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void jobUnscheduled(TriggerKey triggerKey) &#123;</span><br><span class="line">        String name &#x3D; triggerKey.getName();</span><br><span class="line">        &#x2F;&#x2F; 用于卸载JobDetail时调用</span><br><span class="line">        System.out.println(name +&quot; 完成卸载&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void triggerFinalized(Trigger trigger) &#123;</span><br><span class="line">        String name &#x3D; trigger.getKey().getName();</span><br><span class="line">        &#x2F;&#x2F; 当一个Trigger来到了再也不会触发的状态时调用这个方法。除非这个Job已设置成了持久性，否则它就会从Scheduler中移除。</span><br><span class="line">        System.out.println(name +&quot; 触发器被移除&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void triggerPaused(TriggerKey triggerKey) &#123;</span><br><span class="line">        String name &#x3D; triggerKey.getName();</span><br><span class="line">        &#x2F;&#x2F; Scheduler调用这个方法是发生在一个Trigger或Trigger组被暂停时。假如是Trigger组的话，triggerName参数将为null。</span><br><span class="line">        System.out.println(name +&quot; 正在被暂停&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void triggersPaused(String triggerGroup) &#123;</span><br><span class="line">        &#x2F;&#x2F; Scheduler调用这个方法是发生在一个Trigger或Trigger组被暂停时。假如是Trigger组的话，triggerName参数将为null。</span><br><span class="line">        System.out.println(&quot;触发器组&quot; +triggerGroup +&quot; 正在被暂停&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void triggerResumed(TriggerKey triggerKey) &#123;</span><br><span class="line">        &#x2F;&#x2F; Scheduler调用这个方法是发生在一个Trigger或Trigger组从暂停中恢复时。假如是Trigger组的话，triggerName参数将为null。参数将为null。</span><br><span class="line">        String name &#x3D; triggerKey.getName();</span><br><span class="line">        System.out.println(name +&quot; 正在从暂停中恢复&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void triggersResumed(String triggerGroup) &#123;</span><br><span class="line">        &#x2F;&#x2F; Scheduler调用这个方法是发生在一个Trigger或Trigger组从暂停中恢复时。假如是Trigger组的话，triggerName参数将为null。参数将为null。</span><br><span class="line">        System.out.println(&quot;触发器组&quot; +triggerGroup +&quot; 正在从暂停中恢复&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void jobAdded(JobDetail jobDetail) &#123;</span><br><span class="line">        &#x2F;&#x2F; </span><br><span class="line">        System.out.println(jobDetail.getKey() +&quot; 添加工作任务&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void jobDeleted(JobKey jobKey) &#123;</span><br><span class="line">        &#x2F;&#x2F; </span><br><span class="line">        System.out.println(jobKey +&quot; 删除工作任务&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void jobPaused(JobKey jobKey) &#123;</span><br><span class="line">        &#x2F;&#x2F; </span><br><span class="line">        System.out.println(jobKey +&quot; 工作任务正在被暂停&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void jobsPaused(String jobGroup) &#123;</span><br><span class="line">        &#x2F;&#x2F; </span><br><span class="line">        System.out.println(&quot;工作组&quot; +jobGroup +&quot; 正在被暂停&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void jobResumed(JobKey jobKey) &#123;</span><br><span class="line">        &#x2F;&#x2F; </span><br><span class="line">        System.out.println(jobKey +&quot; 正在从暂停中恢复&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void jobsResumed(String jobGroup) &#123;</span><br><span class="line">        &#x2F;&#x2F; </span><br><span class="line">        System.out.println(&quot;工作组&quot; +jobGroup +&quot; 正在从暂停中恢复&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void schedulerError(String msg, SchedulerException cause) &#123;</span><br><span class="line">        &#x2F;&#x2F; 在Scheduler的正常运行期间产生一个严重错误时调用这个方法。</span><br><span class="line">        System.out.println(&quot;产生严重错误的时候调用&quot; +msg +&quot;    &quot; +cause.getUnderlyingException());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void schedulerInStandbyMode() &#123;</span><br><span class="line">        &#x2F;&#x2F; 当Scheduler处于StandBy模式时，调用该方法。</span><br><span class="line">        System.out.println(&quot;调度器被挂起模式的时候调用&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void schedulerStarted() &#123;</span><br><span class="line">        &#x2F;&#x2F; 当Scheduler开启时，调用该方法</span><br><span class="line">        System.out.println(&quot;调度器开启的时候调用&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void schedulerStarting() &#123;</span><br><span class="line">        &#x2F;&#x2F; </span><br><span class="line">        System.out.println(&quot;调度器正在开启的时候调用&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void schedulerShutdown() &#123;</span><br><span class="line">        &#x2F;&#x2F; </span><br><span class="line">        System.out.println(&quot;调度器关闭的时候调用&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void schedulerShuttingdown() &#123;</span><br><span class="line">        &#x2F;&#x2F; </span><br><span class="line">        System.out.println(&quot;调度器正在关闭的时候调用&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void schedulingDataCleared() &#123;</span><br><span class="line">        &#x2F;&#x2F; 当Scheduler中的数据被清除时，调用该方法</span><br><span class="line">        System.out.println(&quot;调度器数据被清除的时候调用&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HelloSchedulerDemoTriggerListener.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class HelloSchedulerDemoTriggerListener &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 1、调度器（Scheduler），从工厂中获取调度的实例（默认：实例化new StdSchedulerFactory();）</span><br><span class="line">        Scheduler scheduler &#x3D; StdSchedulerFactory.getDefaultScheduler();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 2、任务实例（JobDetail）定义一个任务调度实例，将该实例与HelloJobSimpleTrigger绑定，任务类需要实现Job接口</span><br><span class="line">        JobDetail jobDetail &#x3D; JobBuilder.newJob(HelloJobListener.class) &#x2F;&#x2F; 加载任务类，与HelloJob完成绑定，要求HelloJob实现Job接口</span><br><span class="line">                .withIdentity(&quot;job1&quot;, &quot;group1&quot;) &#x2F;&#x2F; 参数1：任务的名称（唯一实例）；参数2：任务组的名称</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 3、触发器（Trigger）定义触发器，马上执行，然后每5秒重复执行一次</span><br><span class="line">        Trigger trigger &#x3D; TriggerBuilder.newTrigger()</span><br><span class="line">                .withIdentity(&quot;trigger1&quot;, &quot;group1&quot;) &#x2F;&#x2F; 参数1：触发器的名称（唯一实例）；参数2：触发器组的名称</span><br><span class="line">                .startNow()</span><br><span class="line">                .withSchedule(SimpleScheduleBuilder.simpleSchedule().repeatSecondlyForever(5).withRepeatCount(2))  &#x2F;&#x2F; 每5秒执行一次，连续执行3次后停止，默认是0</span><br><span class="line">                .build();</span><br><span class="line">        &#x2F;&#x2F; 4、让调度器关联任务和触发器，保证按照触发器定义的调整执行任务</span><br><span class="line">        scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 创建调度器的监听</span><br><span class="line">        scheduler.getListenerManager().addSchedulerListener(new MySchedulerListener());</span><br><span class="line">        &#x2F;&#x2F; 移除对应的调度器的监听</span><br><span class="line">        &#x2F;&#x2F; scheduler.getListenerManager().removeSchedulerListener(new MySchedulerListener());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 5、启动</span><br><span class="line">        scheduler.start();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 线程延迟7秒后关闭</span><br><span class="line">        Thread.sleep(7000L);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 关闭</span><br><span class="line">        scheduler.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="参考文档：https-github-com-lan7916-itlan-quartz"><a href="#参考文档：https-github-com-lan7916-itlan-quartz" class="headerlink" title="参考文档：https://github.com/lan7916/itlan_quartz"></a>参考文档：<a target="_blank" rel="noopener" href="https://github.com/lan7916/itlan_quartz">https://github.com/lan7916/itlan_quartz</a></h6></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">HLY</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://cddorz.github.io/2020/11/18/Quartz/">https://cddorz.github.io/2020/11/18/Quartz/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://cddorz.github.io" target="_blank">HLY-Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/">定时任务</a></div><div class="post_share"><div class="social-share" data-image="https://pic1.zhimg.com/80/v2-a196f39112d5287f0214eb50b94563ce_720w.jpg?source=1940ef5c" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2020/11/16/Redis/"><img class="next-cover" data-lazy-src="https://pic4.zhimg.com/80/v2-b0c015f49137896301d515bc54e04e0f_720w.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Redis</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" data-lazy-src="/img/tubiao.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"><div class="author-info__name">HLY</div><div class="author-info__description">西电学子努力中</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/cddorz"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/orzcdd" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2878153350@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div></div><div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="clock"><img v-if="!clockshow" src="/images/loading.gif" style="height:120px;width:100%"><table class="clock" v-if="clockshow"><tbody><tr><td class="clockdate">{{date}}</td><td class="weatherimg" align="center" valign="middle"><img id="weatherimg" :src="weatherimg"></td><td class="temperature" align="center" valign="middle">{{temperature+ "*C"}}</td><td class="humidityimg"><img id="humidityimg" :src="humidityimg"></td><td class="humidity">{{humidity + "%"}}</td></tr><tr class="time"><td colspan="5">{{time}}</td></tr><tr><td class="usaqi" colspan="1">{{usaqi + ' ' + 'US' + ' ' +'AQI' }}</td><td class="city" colspan="3">{{city}}</td><td class="daylight" colspan="1">{{daylight}}</td></tr></tbody></table></div></div></div></div></div><div class="sticky_layout"><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">西电大二学生，学习后端开发，对unitiy游戏开发有兴趣，希望大二能去字节实习。</div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2020/11/18/Quartz/" title="Quartz"><img data-lazy-src="https://pic1.zhimg.com/80/v2-a196f39112d5287f0214eb50b94563ce_720w.jpg?source=1940ef5c" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Quartz"></a><div class="content"><a class="title" href="/2020/11/18/Quartz/" title="Quartz">Quartz</a><time datetime="2020-11-18T02:43:41.000Z" title="发表于 2020-11-18 10:43:41">2020-11-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/11/16/Redis/" title="Redis"><img data-lazy-src="https://pic4.zhimg.com/80/v2-b0c015f49137896301d515bc54e04e0f_720w.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis"></a><div class="content"><a class="title" href="/2020/11/16/Redis/" title="Redis">Redis</a><time datetime="2020-11-16T06:23:13.000Z" title="发表于 2020-11-16 14:23:13">2020-11-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/11/14/Linux%E7%9B%B8%E5%85%B3/" title="Linux相关"><img data-lazy-src="https://pic1.zhimg.com/80/v2-1b93504d5cf852aa045cb77f71e2bddc_720w.jpg?source=1940ef5c" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux相关"></a><div class="content"><a class="title" href="/2020/11/14/Linux%E7%9B%B8%E5%85%B3/" title="Linux相关">Linux相关</a><time datetime="2020-11-14T15:46:13.000Z" title="发表于 2020-11-14 23:46:13">2020-11-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/11/12/Mybatis%EF%BC%88%E4%BA%8C%EF%BC%89/" title="Mybatis（二）"><img data-lazy-src="https://pic2.zhimg.com/80/v2-d2a9e345588460086e88b8ea3f1aaf56_720w.jpg?source=1940ef5c" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mybatis（二）"></a><div class="content"><a class="title" href="/2020/11/12/Mybatis%EF%BC%88%E4%BA%8C%EF%BC%89/" title="Mybatis（二）">Mybatis（二）</a><time datetime="2020-11-12T04:02:20.000Z" title="发表于 2020-11-12 12:02:20">2020-11-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/11/11/Mybatis/" title="Mybatis（一）"><img data-lazy-src="https://pic4.zhimg.com/80/v2-7c7fce3b754722fad07c25a1048f7861_720w.jpg?source=1940ef5c" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mybatis（一）"></a><div class="content"><a class="title" href="/2020/11/11/Mybatis/" title="Mybatis（一）">Mybatis（一）</a><time datetime="2020-11-11T11:14:59.000Z" title="发表于 2020-11-11 19:14:59">2020-11-11</time></div></div></div></div></div><div class="card-widget card-categories"><div class="card-content"><div class="item-headline"><i class="fas fa-folder-open"></i><span>分类</span></div><ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Java/"><span class="card-category-list-name">Java</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Redis/"><span class="card-category-list-name">Redis</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/mybatis/"><span class="card-category-list-name">mybatis</span><span class="card-category-list-count">2</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/springboot/"><span class="card-category-list-name">springboot</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E7%B3%BB%E7%BB%9F/"><span class="card-category-list-name">系统</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E9%9A%8F%E7%AC%94/"><span class="card-category-list-name">随笔</span><span class="card-category-list-count">3</span></a></li>
            
            </ul></div></div><div class="card-widget card-tags"><div class="card-content"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/%E6%80%BB%E7%BB%93/" style="font-size: 1.5em; color: rgb(78, 40, 86)">总结</a><a href="/tags/mybatis/" style="font-size: 1.3em; color: rgb(24, 183, 11)">mybatis</a><a href="/tags/%E5%B0%91%E5%B9%B4/" style="font-size: 1.1em; color: rgb(170, 148, 30)">少年</a><a href="/tags/Linux/" style="font-size: 1.1em; color: rgb(194, 68, 99)">Linux</a><a href="/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/" style="font-size: 1.1em; color: rgb(144, 24, 130)">定时任务</a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 1.1em; color: rgb(19, 57, 26)">数据库</a></div></div></div><div class="card-widget card-archives"><div class="card-content"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2020/11/"><span class="card-archive-list-date">十一月 2020</span><span class="card-archive-list-count">7</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2020/10/"><span class="card-archive-list-date">十月 2020</span><span class="card-archive-list-count">2</span></a></li></ul></div></div><div class="card-widget card-webinfo"><div class="card-content"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">9</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2020-11-18T02:47:16.551Z"></div></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://pic1.zhimg.com/80/v2-a196f39112d5287f0214eb50b94563ce_720w.jpg?source=1940ef5c)"><div id="footer-wrap"><div class="copyright">&copy;2020 By HLY</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk({
      clientID: 'bae48c226ba03a6ed416',
      clientSecret: 'a68ce5f4bc785b3c4243dcc9e1abdf3c6ad0b61e',
      repo: 'cddorz.github.io',
      owner: 'cddorz',
      admin: ['cddorz'],
      id: '7d1c93d1e95a65b6a159c07ab9bc2077',
      language: 'zh-CN',
      perPage: 10,
      distractionFreeMode: false,
      pagerDirection: 'last',
      createIssueManually: false,
      updateCountCallback: commentCount
    })
    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    $.getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js', initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/clock/js/vue.min.js"></script><script src="/clock/js/clock.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" async="async" mobile="true"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>